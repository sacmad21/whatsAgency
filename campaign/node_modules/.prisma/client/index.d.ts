
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CompetitorStrategy
 * 
 */
export type CompetitorStrategy = $Result.DefaultSelection<Prisma.$CompetitorStrategyPayload>
/**
 * Model EnterpriseContext
 * 
 */
export type EnterpriseContext = $Result.DefaultSelection<Prisma.$EnterpriseContextPayload>
/**
 * Model AudienceSegment
 * 
 */
export type AudienceSegment = $Result.DefaultSelection<Prisma.$AudienceSegmentPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignObjective
 * 
 */
export type CampaignObjective = $Result.DefaultSelection<Prisma.$CampaignObjectivePayload>
/**
 * Model TargetAudienceSegment
 * 
 */
export type TargetAudienceSegment = $Result.DefaultSelection<Prisma.$TargetAudienceSegmentPayload>
/**
 * Model PromotionType
 * 
 */
export type PromotionType = $Result.DefaultSelection<Prisma.$PromotionTypePayload>
/**
 * Model CampaignOffer
 * 
 */
export type CampaignOffer = $Result.DefaultSelection<Prisma.$CampaignOfferPayload>
/**
 * Model CampaignBudget
 * 
 */
export type CampaignBudget = $Result.DefaultSelection<Prisma.$CampaignBudgetPayload>
/**
 * Model ChannelPlan
 * 
 */
export type ChannelPlan = $Result.DefaultSelection<Prisma.$ChannelPlanPayload>
/**
 * Model CampaignTimeline
 * 
 */
export type CampaignTimeline = $Result.DefaultSelection<Prisma.$CampaignTimelinePayload>
/**
 * Model ComplianceChecklist
 * 
 */
export type ComplianceChecklist = $Result.DefaultSelection<Prisma.$ComplianceChecklistPayload>
/**
 * Model PromotionalMessage
 * 
 */
export type PromotionalMessage = $Result.DefaultSelection<Prisma.$PromotionalMessagePayload>
/**
 * Model CreativeDesignPlan
 * 
 */
export type CreativeDesignPlan = $Result.DefaultSelection<Prisma.$CreativeDesignPlanPayload>
/**
 * Model CreativeAsset
 * 
 */
export type CreativeAsset = $Result.DefaultSelection<Prisma.$CreativeAssetPayload>
/**
 * Model MediaAsset
 * 
 */
export type MediaAsset = $Result.DefaultSelection<Prisma.$MediaAssetPayload>
/**
 * Model ContentCalendar
 * 
 */
export type ContentCalendar = $Result.DefaultSelection<Prisma.$ContentCalendarPayload>
/**
 * Model TeaserContent
 * 
 */
export type TeaserContent = $Result.DefaultSelection<Prisma.$TeaserContentPayload>
/**
 * Model CustomerSegmentList
 * 
 */
export type CustomerSegmentList = $Result.DefaultSelection<Prisma.$CustomerSegmentListPayload>
/**
 * Model InfluencerPlan
 * 
 */
export type InfluencerPlan = $Result.DefaultSelection<Prisma.$InfluencerPlanPayload>
/**
 * Model OperationalChecklist
 * 
 */
export type OperationalChecklist = $Result.DefaultSelection<Prisma.$OperationalChecklistPayload>
/**
 * Model CampaignActivation
 * 
 */
export type CampaignActivation = $Result.DefaultSelection<Prisma.$CampaignActivationPayload>
/**
 * Model CustomerEngagementLog
 * 
 */
export type CustomerEngagementLog = $Result.DefaultSelection<Prisma.$CustomerEngagementLogPayload>
/**
 * Model PerformanceReport
 * 
 */
export type PerformanceReport = $Result.DefaultSelection<Prisma.$PerformanceReportPayload>
/**
 * Model CustomerFeedback
 * 
 */
export type CustomerFeedback = $Result.DefaultSelection<Prisma.$CustomerFeedbackPayload>
/**
 * Model ThankYouMessage
 * 
 */
export type ThankYouMessage = $Result.DefaultSelection<Prisma.$ThankYouMessagePayload>
/**
 * Model RetargetingPlan
 * 
 */
export type RetargetingPlan = $Result.DefaultSelection<Prisma.$RetargetingPlanPayload>
/**
 * Model CampaignExtensionPlan
 * 
 */
export type CampaignExtensionPlan = $Result.DefaultSelection<Prisma.$CampaignExtensionPlanPayload>
/**
 * Model CampaignAnalysisReport
 * 
 */
export type CampaignAnalysisReport = $Result.DefaultSelection<Prisma.$CampaignAnalysisReportPayload>
/**
 * Model CampaignLearnings
 * 
 */
export type CampaignLearnings = $Result.DefaultSelection<Prisma.$CampaignLearningsPayload>
/**
 * Model InternalCampaignReport
 * 
 */
export type InternalCampaignReport = $Result.DefaultSelection<Prisma.$InternalCampaignReportPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CompetitorStrategies
 * const competitorStrategies = await prisma.competitorStrategy.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CompetitorStrategies
   * const competitorStrategies = await prisma.competitorStrategy.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.competitorStrategy`: Exposes CRUD operations for the **CompetitorStrategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompetitorStrategies
    * const competitorStrategies = await prisma.competitorStrategy.findMany()
    * ```
    */
  get competitorStrategy(): Prisma.CompetitorStrategyDelegate<ExtArgs>;

  /**
   * `prisma.enterpriseContext`: Exposes CRUD operations for the **EnterpriseContext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnterpriseContexts
    * const enterpriseContexts = await prisma.enterpriseContext.findMany()
    * ```
    */
  get enterpriseContext(): Prisma.EnterpriseContextDelegate<ExtArgs>;

  /**
   * `prisma.audienceSegment`: Exposes CRUD operations for the **AudienceSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudienceSegments
    * const audienceSegments = await prisma.audienceSegment.findMany()
    * ```
    */
  get audienceSegment(): Prisma.AudienceSegmentDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignObjective`: Exposes CRUD operations for the **CampaignObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignObjectives
    * const campaignObjectives = await prisma.campaignObjective.findMany()
    * ```
    */
  get campaignObjective(): Prisma.CampaignObjectiveDelegate<ExtArgs>;

  /**
   * `prisma.targetAudienceSegment`: Exposes CRUD operations for the **TargetAudienceSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TargetAudienceSegments
    * const targetAudienceSegments = await prisma.targetAudienceSegment.findMany()
    * ```
    */
  get targetAudienceSegment(): Prisma.TargetAudienceSegmentDelegate<ExtArgs>;

  /**
   * `prisma.promotionType`: Exposes CRUD operations for the **PromotionType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionTypes
    * const promotionTypes = await prisma.promotionType.findMany()
    * ```
    */
  get promotionType(): Prisma.PromotionTypeDelegate<ExtArgs>;

  /**
   * `prisma.campaignOffer`: Exposes CRUD operations for the **CampaignOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignOffers
    * const campaignOffers = await prisma.campaignOffer.findMany()
    * ```
    */
  get campaignOffer(): Prisma.CampaignOfferDelegate<ExtArgs>;

  /**
   * `prisma.campaignBudget`: Exposes CRUD operations for the **CampaignBudget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignBudgets
    * const campaignBudgets = await prisma.campaignBudget.findMany()
    * ```
    */
  get campaignBudget(): Prisma.CampaignBudgetDelegate<ExtArgs>;

  /**
   * `prisma.channelPlan`: Exposes CRUD operations for the **ChannelPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelPlans
    * const channelPlans = await prisma.channelPlan.findMany()
    * ```
    */
  get channelPlan(): Prisma.ChannelPlanDelegate<ExtArgs>;

  /**
   * `prisma.campaignTimeline`: Exposes CRUD operations for the **CampaignTimeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignTimelines
    * const campaignTimelines = await prisma.campaignTimeline.findMany()
    * ```
    */
  get campaignTimeline(): Prisma.CampaignTimelineDelegate<ExtArgs>;

  /**
   * `prisma.complianceChecklist`: Exposes CRUD operations for the **ComplianceChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceChecklists
    * const complianceChecklists = await prisma.complianceChecklist.findMany()
    * ```
    */
  get complianceChecklist(): Prisma.ComplianceChecklistDelegate<ExtArgs>;

  /**
   * `prisma.promotionalMessage`: Exposes CRUD operations for the **PromotionalMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionalMessages
    * const promotionalMessages = await prisma.promotionalMessage.findMany()
    * ```
    */
  get promotionalMessage(): Prisma.PromotionalMessageDelegate<ExtArgs>;

  /**
   * `prisma.creativeDesignPlan`: Exposes CRUD operations for the **CreativeDesignPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreativeDesignPlans
    * const creativeDesignPlans = await prisma.creativeDesignPlan.findMany()
    * ```
    */
  get creativeDesignPlan(): Prisma.CreativeDesignPlanDelegate<ExtArgs>;

  /**
   * `prisma.creativeAsset`: Exposes CRUD operations for the **CreativeAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreativeAssets
    * const creativeAssets = await prisma.creativeAsset.findMany()
    * ```
    */
  get creativeAsset(): Prisma.CreativeAssetDelegate<ExtArgs>;

  /**
   * `prisma.mediaAsset`: Exposes CRUD operations for the **MediaAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaAssets
    * const mediaAssets = await prisma.mediaAsset.findMany()
    * ```
    */
  get mediaAsset(): Prisma.MediaAssetDelegate<ExtArgs>;

  /**
   * `prisma.contentCalendar`: Exposes CRUD operations for the **ContentCalendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentCalendars
    * const contentCalendars = await prisma.contentCalendar.findMany()
    * ```
    */
  get contentCalendar(): Prisma.ContentCalendarDelegate<ExtArgs>;

  /**
   * `prisma.teaserContent`: Exposes CRUD operations for the **TeaserContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeaserContents
    * const teaserContents = await prisma.teaserContent.findMany()
    * ```
    */
  get teaserContent(): Prisma.TeaserContentDelegate<ExtArgs>;

  /**
   * `prisma.customerSegmentList`: Exposes CRUD operations for the **CustomerSegmentList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerSegmentLists
    * const customerSegmentLists = await prisma.customerSegmentList.findMany()
    * ```
    */
  get customerSegmentList(): Prisma.CustomerSegmentListDelegate<ExtArgs>;

  /**
   * `prisma.influencerPlan`: Exposes CRUD operations for the **InfluencerPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InfluencerPlans
    * const influencerPlans = await prisma.influencerPlan.findMany()
    * ```
    */
  get influencerPlan(): Prisma.InfluencerPlanDelegate<ExtArgs>;

  /**
   * `prisma.operationalChecklist`: Exposes CRUD operations for the **OperationalChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationalChecklists
    * const operationalChecklists = await prisma.operationalChecklist.findMany()
    * ```
    */
  get operationalChecklist(): Prisma.OperationalChecklistDelegate<ExtArgs>;

  /**
   * `prisma.campaignActivation`: Exposes CRUD operations for the **CampaignActivation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignActivations
    * const campaignActivations = await prisma.campaignActivation.findMany()
    * ```
    */
  get campaignActivation(): Prisma.CampaignActivationDelegate<ExtArgs>;

  /**
   * `prisma.customerEngagementLog`: Exposes CRUD operations for the **CustomerEngagementLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerEngagementLogs
    * const customerEngagementLogs = await prisma.customerEngagementLog.findMany()
    * ```
    */
  get customerEngagementLog(): Prisma.CustomerEngagementLogDelegate<ExtArgs>;

  /**
   * `prisma.performanceReport`: Exposes CRUD operations for the **PerformanceReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceReports
    * const performanceReports = await prisma.performanceReport.findMany()
    * ```
    */
  get performanceReport(): Prisma.PerformanceReportDelegate<ExtArgs>;

  /**
   * `prisma.customerFeedback`: Exposes CRUD operations for the **CustomerFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerFeedbacks
    * const customerFeedbacks = await prisma.customerFeedback.findMany()
    * ```
    */
  get customerFeedback(): Prisma.CustomerFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.thankYouMessage`: Exposes CRUD operations for the **ThankYouMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThankYouMessages
    * const thankYouMessages = await prisma.thankYouMessage.findMany()
    * ```
    */
  get thankYouMessage(): Prisma.ThankYouMessageDelegate<ExtArgs>;

  /**
   * `prisma.retargetingPlan`: Exposes CRUD operations for the **RetargetingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RetargetingPlans
    * const retargetingPlans = await prisma.retargetingPlan.findMany()
    * ```
    */
  get retargetingPlan(): Prisma.RetargetingPlanDelegate<ExtArgs>;

  /**
   * `prisma.campaignExtensionPlan`: Exposes CRUD operations for the **CampaignExtensionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignExtensionPlans
    * const campaignExtensionPlans = await prisma.campaignExtensionPlan.findMany()
    * ```
    */
  get campaignExtensionPlan(): Prisma.CampaignExtensionPlanDelegate<ExtArgs>;

  /**
   * `prisma.campaignAnalysisReport`: Exposes CRUD operations for the **CampaignAnalysisReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignAnalysisReports
    * const campaignAnalysisReports = await prisma.campaignAnalysisReport.findMany()
    * ```
    */
  get campaignAnalysisReport(): Prisma.CampaignAnalysisReportDelegate<ExtArgs>;

  /**
   * `prisma.campaignLearnings`: Exposes CRUD operations for the **CampaignLearnings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignLearnings
    * const campaignLearnings = await prisma.campaignLearnings.findMany()
    * ```
    */
  get campaignLearnings(): Prisma.CampaignLearningsDelegate<ExtArgs>;

  /**
   * `prisma.internalCampaignReport`: Exposes CRUD operations for the **InternalCampaignReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InternalCampaignReports
    * const internalCampaignReports = await prisma.internalCampaignReport.findMany()
    * ```
    */
  get internalCampaignReport(): Prisma.InternalCampaignReportDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CompetitorStrategy: 'CompetitorStrategy',
    EnterpriseContext: 'EnterpriseContext',
    AudienceSegment: 'AudienceSegment',
    Campaign: 'Campaign',
    CampaignObjective: 'CampaignObjective',
    TargetAudienceSegment: 'TargetAudienceSegment',
    PromotionType: 'PromotionType',
    CampaignOffer: 'CampaignOffer',
    CampaignBudget: 'CampaignBudget',
    ChannelPlan: 'ChannelPlan',
    CampaignTimeline: 'CampaignTimeline',
    ComplianceChecklist: 'ComplianceChecklist',
    PromotionalMessage: 'PromotionalMessage',
    CreativeDesignPlan: 'CreativeDesignPlan',
    CreativeAsset: 'CreativeAsset',
    MediaAsset: 'MediaAsset',
    ContentCalendar: 'ContentCalendar',
    TeaserContent: 'TeaserContent',
    CustomerSegmentList: 'CustomerSegmentList',
    InfluencerPlan: 'InfluencerPlan',
    OperationalChecklist: 'OperationalChecklist',
    CampaignActivation: 'CampaignActivation',
    CustomerEngagementLog: 'CustomerEngagementLog',
    PerformanceReport: 'PerformanceReport',
    CustomerFeedback: 'CustomerFeedback',
    ThankYouMessage: 'ThankYouMessage',
    RetargetingPlan: 'RetargetingPlan',
    CampaignExtensionPlan: 'CampaignExtensionPlan',
    CampaignAnalysisReport: 'CampaignAnalysisReport',
    CampaignLearnings: 'CampaignLearnings',
    InternalCampaignReport: 'InternalCampaignReport'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "competitorStrategy" | "enterpriseContext" | "audienceSegment" | "campaign" | "campaignObjective" | "targetAudienceSegment" | "promotionType" | "campaignOffer" | "campaignBudget" | "channelPlan" | "campaignTimeline" | "complianceChecklist" | "promotionalMessage" | "creativeDesignPlan" | "creativeAsset" | "mediaAsset" | "contentCalendar" | "teaserContent" | "customerSegmentList" | "influencerPlan" | "operationalChecklist" | "campaignActivation" | "customerEngagementLog" | "performanceReport" | "customerFeedback" | "thankYouMessage" | "retargetingPlan" | "campaignExtensionPlan" | "campaignAnalysisReport" | "campaignLearnings" | "internalCampaignReport"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CompetitorStrategy: {
        payload: Prisma.$CompetitorStrategyPayload<ExtArgs>
        fields: Prisma.CompetitorStrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompetitorStrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompetitorStrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload>
          }
          findFirst: {
            args: Prisma.CompetitorStrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompetitorStrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload>
          }
          findMany: {
            args: Prisma.CompetitorStrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload>[]
          }
          create: {
            args: Prisma.CompetitorStrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload>
          }
          createMany: {
            args: Prisma.CompetitorStrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompetitorStrategyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload>[]
          }
          delete: {
            args: Prisma.CompetitorStrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload>
          }
          update: {
            args: Prisma.CompetitorStrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload>
          }
          deleteMany: {
            args: Prisma.CompetitorStrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompetitorStrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompetitorStrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorStrategyPayload>
          }
          aggregate: {
            args: Prisma.CompetitorStrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompetitorStrategy>
          }
          groupBy: {
            args: Prisma.CompetitorStrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompetitorStrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompetitorStrategyCountArgs<ExtArgs>
            result: $Utils.Optional<CompetitorStrategyCountAggregateOutputType> | number
          }
        }
      }
      EnterpriseContext: {
        payload: Prisma.$EnterpriseContextPayload<ExtArgs>
        fields: Prisma.EnterpriseContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnterpriseContextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnterpriseContextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload>
          }
          findFirst: {
            args: Prisma.EnterpriseContextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnterpriseContextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload>
          }
          findMany: {
            args: Prisma.EnterpriseContextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload>[]
          }
          create: {
            args: Prisma.EnterpriseContextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload>
          }
          createMany: {
            args: Prisma.EnterpriseContextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnterpriseContextCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload>[]
          }
          delete: {
            args: Prisma.EnterpriseContextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload>
          }
          update: {
            args: Prisma.EnterpriseContextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload>
          }
          deleteMany: {
            args: Prisma.EnterpriseContextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnterpriseContextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnterpriseContextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseContextPayload>
          }
          aggregate: {
            args: Prisma.EnterpriseContextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnterpriseContext>
          }
          groupBy: {
            args: Prisma.EnterpriseContextGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnterpriseContextGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnterpriseContextCountArgs<ExtArgs>
            result: $Utils.Optional<EnterpriseContextCountAggregateOutputType> | number
          }
        }
      }
      AudienceSegment: {
        payload: Prisma.$AudienceSegmentPayload<ExtArgs>
        fields: Prisma.AudienceSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudienceSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudienceSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload>
          }
          findFirst: {
            args: Prisma.AudienceSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudienceSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload>
          }
          findMany: {
            args: Prisma.AudienceSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload>[]
          }
          create: {
            args: Prisma.AudienceSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload>
          }
          createMany: {
            args: Prisma.AudienceSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudienceSegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload>[]
          }
          delete: {
            args: Prisma.AudienceSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload>
          }
          update: {
            args: Prisma.AudienceSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload>
          }
          deleteMany: {
            args: Prisma.AudienceSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudienceSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudienceSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceSegmentPayload>
          }
          aggregate: {
            args: Prisma.AudienceSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudienceSegment>
          }
          groupBy: {
            args: Prisma.AudienceSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudienceSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudienceSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<AudienceSegmentCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignObjective: {
        payload: Prisma.$CampaignObjectivePayload<ExtArgs>
        fields: Prisma.CampaignObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload>
          }
          findFirst: {
            args: Prisma.CampaignObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload>
          }
          findMany: {
            args: Prisma.CampaignObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload>[]
          }
          create: {
            args: Prisma.CampaignObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload>
          }
          createMany: {
            args: Prisma.CampaignObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload>[]
          }
          delete: {
            args: Prisma.CampaignObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload>
          }
          update: {
            args: Prisma.CampaignObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload>
          }
          deleteMany: {
            args: Prisma.CampaignObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignObjectivePayload>
          }
          aggregate: {
            args: Prisma.CampaignObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignObjective>
          }
          groupBy: {
            args: Prisma.CampaignObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignObjectiveCountAggregateOutputType> | number
          }
        }
      }
      TargetAudienceSegment: {
        payload: Prisma.$TargetAudienceSegmentPayload<ExtArgs>
        fields: Prisma.TargetAudienceSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TargetAudienceSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TargetAudienceSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload>
          }
          findFirst: {
            args: Prisma.TargetAudienceSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TargetAudienceSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload>
          }
          findMany: {
            args: Prisma.TargetAudienceSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload>[]
          }
          create: {
            args: Prisma.TargetAudienceSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload>
          }
          createMany: {
            args: Prisma.TargetAudienceSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TargetAudienceSegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload>[]
          }
          delete: {
            args: Prisma.TargetAudienceSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload>
          }
          update: {
            args: Prisma.TargetAudienceSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload>
          }
          deleteMany: {
            args: Prisma.TargetAudienceSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TargetAudienceSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TargetAudienceSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TargetAudienceSegmentPayload>
          }
          aggregate: {
            args: Prisma.TargetAudienceSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTargetAudienceSegment>
          }
          groupBy: {
            args: Prisma.TargetAudienceSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TargetAudienceSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TargetAudienceSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<TargetAudienceSegmentCountAggregateOutputType> | number
          }
        }
      }
      PromotionType: {
        payload: Prisma.$PromotionTypePayload<ExtArgs>
        fields: Prisma.PromotionTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload>
          }
          findFirst: {
            args: Prisma.PromotionTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload>
          }
          findMany: {
            args: Prisma.PromotionTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload>[]
          }
          create: {
            args: Prisma.PromotionTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload>
          }
          createMany: {
            args: Prisma.PromotionTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload>[]
          }
          delete: {
            args: Prisma.PromotionTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload>
          }
          update: {
            args: Prisma.PromotionTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload>
          }
          deleteMany: {
            args: Prisma.PromotionTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionTypePayload>
          }
          aggregate: {
            args: Prisma.PromotionTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotionType>
          }
          groupBy: {
            args: Prisma.PromotionTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionTypeCountAggregateOutputType> | number
          }
        }
      }
      CampaignOffer: {
        payload: Prisma.$CampaignOfferPayload<ExtArgs>
        fields: Prisma.CampaignOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignOfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignOfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload>
          }
          findFirst: {
            args: Prisma.CampaignOfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignOfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload>
          }
          findMany: {
            args: Prisma.CampaignOfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload>[]
          }
          create: {
            args: Prisma.CampaignOfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload>
          }
          createMany: {
            args: Prisma.CampaignOfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignOfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload>[]
          }
          delete: {
            args: Prisma.CampaignOfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload>
          }
          update: {
            args: Prisma.CampaignOfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload>
          }
          deleteMany: {
            args: Prisma.CampaignOfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignOfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignOfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOfferPayload>
          }
          aggregate: {
            args: Prisma.CampaignOfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignOffer>
          }
          groupBy: {
            args: Prisma.CampaignOfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignOfferCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignOfferCountAggregateOutputType> | number
          }
        }
      }
      CampaignBudget: {
        payload: Prisma.$CampaignBudgetPayload<ExtArgs>
        fields: Prisma.CampaignBudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignBudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignBudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload>
          }
          findFirst: {
            args: Prisma.CampaignBudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignBudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload>
          }
          findMany: {
            args: Prisma.CampaignBudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload>[]
          }
          create: {
            args: Prisma.CampaignBudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload>
          }
          createMany: {
            args: Prisma.CampaignBudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignBudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload>[]
          }
          delete: {
            args: Prisma.CampaignBudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload>
          }
          update: {
            args: Prisma.CampaignBudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload>
          }
          deleteMany: {
            args: Prisma.CampaignBudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignBudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignBudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignBudgetPayload>
          }
          aggregate: {
            args: Prisma.CampaignBudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignBudget>
          }
          groupBy: {
            args: Prisma.CampaignBudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignBudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignBudgetCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignBudgetCountAggregateOutputType> | number
          }
        }
      }
      ChannelPlan: {
        payload: Prisma.$ChannelPlanPayload<ExtArgs>
        fields: Prisma.ChannelPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload>
          }
          findFirst: {
            args: Prisma.ChannelPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload>
          }
          findMany: {
            args: Prisma.ChannelPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload>[]
          }
          create: {
            args: Prisma.ChannelPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload>
          }
          createMany: {
            args: Prisma.ChannelPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload>[]
          }
          delete: {
            args: Prisma.ChannelPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload>
          }
          update: {
            args: Prisma.ChannelPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload>
          }
          deleteMany: {
            args: Prisma.ChannelPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPlanPayload>
          }
          aggregate: {
            args: Prisma.ChannelPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelPlan>
          }
          groupBy: {
            args: Prisma.ChannelPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelPlanCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelPlanCountAggregateOutputType> | number
          }
        }
      }
      CampaignTimeline: {
        payload: Prisma.$CampaignTimelinePayload<ExtArgs>
        fields: Prisma.CampaignTimelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignTimelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignTimelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload>
          }
          findFirst: {
            args: Prisma.CampaignTimelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignTimelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload>
          }
          findMany: {
            args: Prisma.CampaignTimelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload>[]
          }
          create: {
            args: Prisma.CampaignTimelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload>
          }
          createMany: {
            args: Prisma.CampaignTimelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignTimelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload>[]
          }
          delete: {
            args: Prisma.CampaignTimelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload>
          }
          update: {
            args: Prisma.CampaignTimelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload>
          }
          deleteMany: {
            args: Prisma.CampaignTimelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignTimelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignTimelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTimelinePayload>
          }
          aggregate: {
            args: Prisma.CampaignTimelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignTimeline>
          }
          groupBy: {
            args: Prisma.CampaignTimelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignTimelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignTimelineCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignTimelineCountAggregateOutputType> | number
          }
        }
      }
      ComplianceChecklist: {
        payload: Prisma.$ComplianceChecklistPayload<ExtArgs>
        fields: Prisma.ComplianceChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload>
          }
          findFirst: {
            args: Prisma.ComplianceChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload>
          }
          findMany: {
            args: Prisma.ComplianceChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload>[]
          }
          create: {
            args: Prisma.ComplianceChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload>
          }
          createMany: {
            args: Prisma.ComplianceChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload>[]
          }
          delete: {
            args: Prisma.ComplianceChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload>
          }
          update: {
            args: Prisma.ComplianceChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload>
          }
          deleteMany: {
            args: Prisma.ComplianceChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplianceChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceChecklistPayload>
          }
          aggregate: {
            args: Prisma.ComplianceChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceChecklist>
          }
          groupBy: {
            args: Prisma.ComplianceChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceChecklistCountAggregateOutputType> | number
          }
        }
      }
      PromotionalMessage: {
        payload: Prisma.$PromotionalMessagePayload<ExtArgs>
        fields: Prisma.PromotionalMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionalMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionalMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload>
          }
          findFirst: {
            args: Prisma.PromotionalMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionalMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload>
          }
          findMany: {
            args: Prisma.PromotionalMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload>[]
          }
          create: {
            args: Prisma.PromotionalMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload>
          }
          createMany: {
            args: Prisma.PromotionalMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionalMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload>[]
          }
          delete: {
            args: Prisma.PromotionalMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload>
          }
          update: {
            args: Prisma.PromotionalMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload>
          }
          deleteMany: {
            args: Prisma.PromotionalMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionalMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionalMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionalMessagePayload>
          }
          aggregate: {
            args: Prisma.PromotionalMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotionalMessage>
          }
          groupBy: {
            args: Prisma.PromotionalMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionalMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionalMessageCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionalMessageCountAggregateOutputType> | number
          }
        }
      }
      CreativeDesignPlan: {
        payload: Prisma.$CreativeDesignPlanPayload<ExtArgs>
        fields: Prisma.CreativeDesignPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreativeDesignPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreativeDesignPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload>
          }
          findFirst: {
            args: Prisma.CreativeDesignPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreativeDesignPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload>
          }
          findMany: {
            args: Prisma.CreativeDesignPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload>[]
          }
          create: {
            args: Prisma.CreativeDesignPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload>
          }
          createMany: {
            args: Prisma.CreativeDesignPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreativeDesignPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload>[]
          }
          delete: {
            args: Prisma.CreativeDesignPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload>
          }
          update: {
            args: Prisma.CreativeDesignPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload>
          }
          deleteMany: {
            args: Prisma.CreativeDesignPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreativeDesignPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreativeDesignPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeDesignPlanPayload>
          }
          aggregate: {
            args: Prisma.CreativeDesignPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreativeDesignPlan>
          }
          groupBy: {
            args: Prisma.CreativeDesignPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreativeDesignPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreativeDesignPlanCountArgs<ExtArgs>
            result: $Utils.Optional<CreativeDesignPlanCountAggregateOutputType> | number
          }
        }
      }
      CreativeAsset: {
        payload: Prisma.$CreativeAssetPayload<ExtArgs>
        fields: Prisma.CreativeAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreativeAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreativeAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload>
          }
          findFirst: {
            args: Prisma.CreativeAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreativeAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload>
          }
          findMany: {
            args: Prisma.CreativeAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload>[]
          }
          create: {
            args: Prisma.CreativeAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload>
          }
          createMany: {
            args: Prisma.CreativeAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreativeAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload>[]
          }
          delete: {
            args: Prisma.CreativeAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload>
          }
          update: {
            args: Prisma.CreativeAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload>
          }
          deleteMany: {
            args: Prisma.CreativeAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreativeAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreativeAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativeAssetPayload>
          }
          aggregate: {
            args: Prisma.CreativeAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreativeAsset>
          }
          groupBy: {
            args: Prisma.CreativeAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreativeAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreativeAssetCountArgs<ExtArgs>
            result: $Utils.Optional<CreativeAssetCountAggregateOutputType> | number
          }
        }
      }
      MediaAsset: {
        payload: Prisma.$MediaAssetPayload<ExtArgs>
        fields: Prisma.MediaAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          findFirst: {
            args: Prisma.MediaAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          findMany: {
            args: Prisma.MediaAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          create: {
            args: Prisma.MediaAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          createMany: {
            args: Prisma.MediaAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          delete: {
            args: Prisma.MediaAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          update: {
            args: Prisma.MediaAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          deleteMany: {
            args: Prisma.MediaAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          aggregate: {
            args: Prisma.MediaAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaAsset>
          }
          groupBy: {
            args: Prisma.MediaAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaAssetCountArgs<ExtArgs>
            result: $Utils.Optional<MediaAssetCountAggregateOutputType> | number
          }
        }
      }
      ContentCalendar: {
        payload: Prisma.$ContentCalendarPayload<ExtArgs>
        fields: Prisma.ContentCalendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentCalendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentCalendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          findFirst: {
            args: Prisma.ContentCalendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentCalendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          findMany: {
            args: Prisma.ContentCalendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>[]
          }
          create: {
            args: Prisma.ContentCalendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          createMany: {
            args: Prisma.ContentCalendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCalendarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>[]
          }
          delete: {
            args: Prisma.ContentCalendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          update: {
            args: Prisma.ContentCalendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          deleteMany: {
            args: Prisma.ContentCalendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentCalendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentCalendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          aggregate: {
            args: Prisma.ContentCalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentCalendar>
          }
          groupBy: {
            args: Prisma.ContentCalendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentCalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCalendarCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCalendarCountAggregateOutputType> | number
          }
        }
      }
      TeaserContent: {
        payload: Prisma.$TeaserContentPayload<ExtArgs>
        fields: Prisma.TeaserContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeaserContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeaserContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload>
          }
          findFirst: {
            args: Prisma.TeaserContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeaserContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload>
          }
          findMany: {
            args: Prisma.TeaserContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload>[]
          }
          create: {
            args: Prisma.TeaserContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload>
          }
          createMany: {
            args: Prisma.TeaserContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeaserContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload>[]
          }
          delete: {
            args: Prisma.TeaserContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload>
          }
          update: {
            args: Prisma.TeaserContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload>
          }
          deleteMany: {
            args: Prisma.TeaserContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeaserContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeaserContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeaserContentPayload>
          }
          aggregate: {
            args: Prisma.TeaserContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeaserContent>
          }
          groupBy: {
            args: Prisma.TeaserContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeaserContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeaserContentCountArgs<ExtArgs>
            result: $Utils.Optional<TeaserContentCountAggregateOutputType> | number
          }
        }
      }
      CustomerSegmentList: {
        payload: Prisma.$CustomerSegmentListPayload<ExtArgs>
        fields: Prisma.CustomerSegmentListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerSegmentListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerSegmentListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload>
          }
          findFirst: {
            args: Prisma.CustomerSegmentListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerSegmentListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload>
          }
          findMany: {
            args: Prisma.CustomerSegmentListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload>[]
          }
          create: {
            args: Prisma.CustomerSegmentListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload>
          }
          createMany: {
            args: Prisma.CustomerSegmentListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerSegmentListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload>[]
          }
          delete: {
            args: Prisma.CustomerSegmentListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload>
          }
          update: {
            args: Prisma.CustomerSegmentListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload>
          }
          deleteMany: {
            args: Prisma.CustomerSegmentListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerSegmentListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerSegmentListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentListPayload>
          }
          aggregate: {
            args: Prisma.CustomerSegmentListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerSegmentList>
          }
          groupBy: {
            args: Prisma.CustomerSegmentListGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerSegmentListGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerSegmentListCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerSegmentListCountAggregateOutputType> | number
          }
        }
      }
      InfluencerPlan: {
        payload: Prisma.$InfluencerPlanPayload<ExtArgs>
        fields: Prisma.InfluencerPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InfluencerPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InfluencerPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload>
          }
          findFirst: {
            args: Prisma.InfluencerPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InfluencerPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload>
          }
          findMany: {
            args: Prisma.InfluencerPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload>[]
          }
          create: {
            args: Prisma.InfluencerPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload>
          }
          createMany: {
            args: Prisma.InfluencerPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InfluencerPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload>[]
          }
          delete: {
            args: Prisma.InfluencerPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload>
          }
          update: {
            args: Prisma.InfluencerPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload>
          }
          deleteMany: {
            args: Prisma.InfluencerPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InfluencerPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InfluencerPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPlanPayload>
          }
          aggregate: {
            args: Prisma.InfluencerPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfluencerPlan>
          }
          groupBy: {
            args: Prisma.InfluencerPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfluencerPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.InfluencerPlanCountArgs<ExtArgs>
            result: $Utils.Optional<InfluencerPlanCountAggregateOutputType> | number
          }
        }
      }
      OperationalChecklist: {
        payload: Prisma.$OperationalChecklistPayload<ExtArgs>
        fields: Prisma.OperationalChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationalChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationalChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload>
          }
          findFirst: {
            args: Prisma.OperationalChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationalChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload>
          }
          findMany: {
            args: Prisma.OperationalChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload>[]
          }
          create: {
            args: Prisma.OperationalChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload>
          }
          createMany: {
            args: Prisma.OperationalChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperationalChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload>[]
          }
          delete: {
            args: Prisma.OperationalChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload>
          }
          update: {
            args: Prisma.OperationalChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload>
          }
          deleteMany: {
            args: Prisma.OperationalChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationalChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperationalChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationalChecklistPayload>
          }
          aggregate: {
            args: Prisma.OperationalChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationalChecklist>
          }
          groupBy: {
            args: Prisma.OperationalChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationalChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationalChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<OperationalChecklistCountAggregateOutputType> | number
          }
        }
      }
      CampaignActivation: {
        payload: Prisma.$CampaignActivationPayload<ExtArgs>
        fields: Prisma.CampaignActivationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignActivationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignActivationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload>
          }
          findFirst: {
            args: Prisma.CampaignActivationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignActivationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload>
          }
          findMany: {
            args: Prisma.CampaignActivationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload>[]
          }
          create: {
            args: Prisma.CampaignActivationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload>
          }
          createMany: {
            args: Prisma.CampaignActivationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignActivationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload>[]
          }
          delete: {
            args: Prisma.CampaignActivationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload>
          }
          update: {
            args: Prisma.CampaignActivationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload>
          }
          deleteMany: {
            args: Prisma.CampaignActivationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignActivationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignActivationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivationPayload>
          }
          aggregate: {
            args: Prisma.CampaignActivationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignActivation>
          }
          groupBy: {
            args: Prisma.CampaignActivationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignActivationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignActivationCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignActivationCountAggregateOutputType> | number
          }
        }
      }
      CustomerEngagementLog: {
        payload: Prisma.$CustomerEngagementLogPayload<ExtArgs>
        fields: Prisma.CustomerEngagementLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerEngagementLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerEngagementLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload>
          }
          findFirst: {
            args: Prisma.CustomerEngagementLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerEngagementLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload>
          }
          findMany: {
            args: Prisma.CustomerEngagementLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload>[]
          }
          create: {
            args: Prisma.CustomerEngagementLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload>
          }
          createMany: {
            args: Prisma.CustomerEngagementLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerEngagementLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload>[]
          }
          delete: {
            args: Prisma.CustomerEngagementLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload>
          }
          update: {
            args: Prisma.CustomerEngagementLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload>
          }
          deleteMany: {
            args: Prisma.CustomerEngagementLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerEngagementLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerEngagementLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerEngagementLogPayload>
          }
          aggregate: {
            args: Prisma.CustomerEngagementLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerEngagementLog>
          }
          groupBy: {
            args: Prisma.CustomerEngagementLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerEngagementLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerEngagementLogCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerEngagementLogCountAggregateOutputType> | number
          }
        }
      }
      PerformanceReport: {
        payload: Prisma.$PerformanceReportPayload<ExtArgs>
        fields: Prisma.PerformanceReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload>
          }
          findFirst: {
            args: Prisma.PerformanceReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload>
          }
          findMany: {
            args: Prisma.PerformanceReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload>[]
          }
          create: {
            args: Prisma.PerformanceReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload>
          }
          createMany: {
            args: Prisma.PerformanceReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload>[]
          }
          delete: {
            args: Prisma.PerformanceReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload>
          }
          update: {
            args: Prisma.PerformanceReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerformanceReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReportPayload>
          }
          aggregate: {
            args: Prisma.PerformanceReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceReport>
          }
          groupBy: {
            args: Prisma.PerformanceReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceReportCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReportCountAggregateOutputType> | number
          }
        }
      }
      CustomerFeedback: {
        payload: Prisma.$CustomerFeedbackPayload<ExtArgs>
        fields: Prisma.CustomerFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload>
          }
          findFirst: {
            args: Prisma.CustomerFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload>
          }
          findMany: {
            args: Prisma.CustomerFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload>[]
          }
          create: {
            args: Prisma.CustomerFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload>
          }
          createMany: {
            args: Prisma.CustomerFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload>[]
          }
          delete: {
            args: Prisma.CustomerFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload>
          }
          update: {
            args: Prisma.CustomerFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.CustomerFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerFeedbackPayload>
          }
          aggregate: {
            args: Prisma.CustomerFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerFeedback>
          }
          groupBy: {
            args: Prisma.CustomerFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerFeedbackCountAggregateOutputType> | number
          }
        }
      }
      ThankYouMessage: {
        payload: Prisma.$ThankYouMessagePayload<ExtArgs>
        fields: Prisma.ThankYouMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThankYouMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThankYouMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload>
          }
          findFirst: {
            args: Prisma.ThankYouMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThankYouMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload>
          }
          findMany: {
            args: Prisma.ThankYouMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload>[]
          }
          create: {
            args: Prisma.ThankYouMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload>
          }
          createMany: {
            args: Prisma.ThankYouMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThankYouMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload>[]
          }
          delete: {
            args: Prisma.ThankYouMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload>
          }
          update: {
            args: Prisma.ThankYouMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload>
          }
          deleteMany: {
            args: Prisma.ThankYouMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThankYouMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ThankYouMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThankYouMessagePayload>
          }
          aggregate: {
            args: Prisma.ThankYouMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThankYouMessage>
          }
          groupBy: {
            args: Prisma.ThankYouMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThankYouMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThankYouMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ThankYouMessageCountAggregateOutputType> | number
          }
        }
      }
      RetargetingPlan: {
        payload: Prisma.$RetargetingPlanPayload<ExtArgs>
        fields: Prisma.RetargetingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RetargetingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RetargetingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload>
          }
          findFirst: {
            args: Prisma.RetargetingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RetargetingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload>
          }
          findMany: {
            args: Prisma.RetargetingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload>[]
          }
          create: {
            args: Prisma.RetargetingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload>
          }
          createMany: {
            args: Prisma.RetargetingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RetargetingPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload>[]
          }
          delete: {
            args: Prisma.RetargetingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload>
          }
          update: {
            args: Prisma.RetargetingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload>
          }
          deleteMany: {
            args: Prisma.RetargetingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RetargetingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RetargetingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetargetingPlanPayload>
          }
          aggregate: {
            args: Prisma.RetargetingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRetargetingPlan>
          }
          groupBy: {
            args: Prisma.RetargetingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<RetargetingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.RetargetingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<RetargetingPlanCountAggregateOutputType> | number
          }
        }
      }
      CampaignExtensionPlan: {
        payload: Prisma.$CampaignExtensionPlanPayload<ExtArgs>
        fields: Prisma.CampaignExtensionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignExtensionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignExtensionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload>
          }
          findFirst: {
            args: Prisma.CampaignExtensionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignExtensionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload>
          }
          findMany: {
            args: Prisma.CampaignExtensionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload>[]
          }
          create: {
            args: Prisma.CampaignExtensionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload>
          }
          createMany: {
            args: Prisma.CampaignExtensionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignExtensionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload>[]
          }
          delete: {
            args: Prisma.CampaignExtensionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload>
          }
          update: {
            args: Prisma.CampaignExtensionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload>
          }
          deleteMany: {
            args: Prisma.CampaignExtensionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignExtensionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignExtensionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignExtensionPlanPayload>
          }
          aggregate: {
            args: Prisma.CampaignExtensionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignExtensionPlan>
          }
          groupBy: {
            args: Prisma.CampaignExtensionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignExtensionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignExtensionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignExtensionPlanCountAggregateOutputType> | number
          }
        }
      }
      CampaignAnalysisReport: {
        payload: Prisma.$CampaignAnalysisReportPayload<ExtArgs>
        fields: Prisma.CampaignAnalysisReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignAnalysisReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignAnalysisReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload>
          }
          findFirst: {
            args: Prisma.CampaignAnalysisReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignAnalysisReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload>
          }
          findMany: {
            args: Prisma.CampaignAnalysisReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload>[]
          }
          create: {
            args: Prisma.CampaignAnalysisReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload>
          }
          createMany: {
            args: Prisma.CampaignAnalysisReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignAnalysisReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload>[]
          }
          delete: {
            args: Prisma.CampaignAnalysisReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload>
          }
          update: {
            args: Prisma.CampaignAnalysisReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload>
          }
          deleteMany: {
            args: Prisma.CampaignAnalysisReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignAnalysisReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignAnalysisReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAnalysisReportPayload>
          }
          aggregate: {
            args: Prisma.CampaignAnalysisReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignAnalysisReport>
          }
          groupBy: {
            args: Prisma.CampaignAnalysisReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignAnalysisReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignAnalysisReportCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignAnalysisReportCountAggregateOutputType> | number
          }
        }
      }
      CampaignLearnings: {
        payload: Prisma.$CampaignLearningsPayload<ExtArgs>
        fields: Prisma.CampaignLearningsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignLearningsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignLearningsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload>
          }
          findFirst: {
            args: Prisma.CampaignLearningsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignLearningsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload>
          }
          findMany: {
            args: Prisma.CampaignLearningsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload>[]
          }
          create: {
            args: Prisma.CampaignLearningsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload>
          }
          createMany: {
            args: Prisma.CampaignLearningsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignLearningsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload>[]
          }
          delete: {
            args: Prisma.CampaignLearningsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload>
          }
          update: {
            args: Prisma.CampaignLearningsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload>
          }
          deleteMany: {
            args: Prisma.CampaignLearningsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignLearningsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignLearningsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLearningsPayload>
          }
          aggregate: {
            args: Prisma.CampaignLearningsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignLearnings>
          }
          groupBy: {
            args: Prisma.CampaignLearningsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignLearningsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignLearningsCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignLearningsCountAggregateOutputType> | number
          }
        }
      }
      InternalCampaignReport: {
        payload: Prisma.$InternalCampaignReportPayload<ExtArgs>
        fields: Prisma.InternalCampaignReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InternalCampaignReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InternalCampaignReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload>
          }
          findFirst: {
            args: Prisma.InternalCampaignReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InternalCampaignReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload>
          }
          findMany: {
            args: Prisma.InternalCampaignReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload>[]
          }
          create: {
            args: Prisma.InternalCampaignReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload>
          }
          createMany: {
            args: Prisma.InternalCampaignReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InternalCampaignReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload>[]
          }
          delete: {
            args: Prisma.InternalCampaignReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload>
          }
          update: {
            args: Prisma.InternalCampaignReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload>
          }
          deleteMany: {
            args: Prisma.InternalCampaignReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InternalCampaignReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InternalCampaignReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalCampaignReportPayload>
          }
          aggregate: {
            args: Prisma.InternalCampaignReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternalCampaignReport>
          }
          groupBy: {
            args: Prisma.InternalCampaignReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<InternalCampaignReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.InternalCampaignReportCountArgs<ExtArgs>
            result: $Utils.Optional<InternalCampaignReportCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    enterpriseContexts: number
    audienceSegments: number
    creativePlans: number
    objectives: number
    audiences: number
    competitors: number
    promotions: number
    offers: number
    budgets: number
    channels: number
    timelines: number
    compliances: number
    creatives: number
    messages: number
    mediaAssets: number
    calendars: number
    teasers: number
    customers: number
    influencers: number
    checklists: number
    activations: number
    engagements: number
    reports: number
    feedbacks: number
    thanks: number
    retargetings: number
    extensions: number
    analysisReports: number
    learnings: number
    internalReports: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enterpriseContexts?: boolean | CampaignCountOutputTypeCountEnterpriseContextsArgs
    audienceSegments?: boolean | CampaignCountOutputTypeCountAudienceSegmentsArgs
    creativePlans?: boolean | CampaignCountOutputTypeCountCreativePlansArgs
    objectives?: boolean | CampaignCountOutputTypeCountObjectivesArgs
    audiences?: boolean | CampaignCountOutputTypeCountAudiencesArgs
    competitors?: boolean | CampaignCountOutputTypeCountCompetitorsArgs
    promotions?: boolean | CampaignCountOutputTypeCountPromotionsArgs
    offers?: boolean | CampaignCountOutputTypeCountOffersArgs
    budgets?: boolean | CampaignCountOutputTypeCountBudgetsArgs
    channels?: boolean | CampaignCountOutputTypeCountChannelsArgs
    timelines?: boolean | CampaignCountOutputTypeCountTimelinesArgs
    compliances?: boolean | CampaignCountOutputTypeCountCompliancesArgs
    creatives?: boolean | CampaignCountOutputTypeCountCreativesArgs
    messages?: boolean | CampaignCountOutputTypeCountMessagesArgs
    mediaAssets?: boolean | CampaignCountOutputTypeCountMediaAssetsArgs
    calendars?: boolean | CampaignCountOutputTypeCountCalendarsArgs
    teasers?: boolean | CampaignCountOutputTypeCountTeasersArgs
    customers?: boolean | CampaignCountOutputTypeCountCustomersArgs
    influencers?: boolean | CampaignCountOutputTypeCountInfluencersArgs
    checklists?: boolean | CampaignCountOutputTypeCountChecklistsArgs
    activations?: boolean | CampaignCountOutputTypeCountActivationsArgs
    engagements?: boolean | CampaignCountOutputTypeCountEngagementsArgs
    reports?: boolean | CampaignCountOutputTypeCountReportsArgs
    feedbacks?: boolean | CampaignCountOutputTypeCountFeedbacksArgs
    thanks?: boolean | CampaignCountOutputTypeCountThanksArgs
    retargetings?: boolean | CampaignCountOutputTypeCountRetargetingsArgs
    extensions?: boolean | CampaignCountOutputTypeCountExtensionsArgs
    analysisReports?: boolean | CampaignCountOutputTypeCountAnalysisReportsArgs
    learnings?: boolean | CampaignCountOutputTypeCountLearningsArgs
    internalReports?: boolean | CampaignCountOutputTypeCountInternalReportsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountEnterpriseContextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnterpriseContextWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountAudienceSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudienceSegmentWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCreativePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreativeDesignPlanWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignObjectiveWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountAudiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetAudienceSegmentWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCompetitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetitorStrategyWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionTypeWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignOfferWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignBudgetWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelPlanWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTimelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTimelineWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCompliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceChecklistWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCreativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreativeAssetWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionalMessageWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMediaAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAssetWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCalendarWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTeasersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeaserContentWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSegmentListWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountInfluencersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfluencerPlanWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountChecklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationalChecklistWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountActivationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignActivationWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountEngagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerEngagementLogWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReportWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerFeedbackWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountThanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThankYouMessageWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountRetargetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetargetingPlanWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountExtensionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignExtensionPlanWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountAnalysisReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignAnalysisReportWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountLearningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLearningsWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountInternalReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternalCampaignReportWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CompetitorStrategy
   */

  export type AggregateCompetitorStrategy = {
    _count: CompetitorStrategyCountAggregateOutputType | null
    _min: CompetitorStrategyMinAggregateOutputType | null
    _max: CompetitorStrategyMaxAggregateOutputType | null
  }

  export type CompetitorStrategyMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    competitor: string | null
    promotionType: string | null
    channels: string | null
    strength: string | null
    weakness: string | null
    createdAt: Date | null
  }

  export type CompetitorStrategyMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    competitor: string | null
    promotionType: string | null
    channels: string | null
    strength: string | null
    weakness: string | null
    createdAt: Date | null
  }

  export type CompetitorStrategyCountAggregateOutputType = {
    id: number
    campaignId: number
    competitor: number
    promotionType: number
    channels: number
    strength: number
    weakness: number
    createdAt: number
    _all: number
  }


  export type CompetitorStrategyMinAggregateInputType = {
    id?: true
    campaignId?: true
    competitor?: true
    promotionType?: true
    channels?: true
    strength?: true
    weakness?: true
    createdAt?: true
  }

  export type CompetitorStrategyMaxAggregateInputType = {
    id?: true
    campaignId?: true
    competitor?: true
    promotionType?: true
    channels?: true
    strength?: true
    weakness?: true
    createdAt?: true
  }

  export type CompetitorStrategyCountAggregateInputType = {
    id?: true
    campaignId?: true
    competitor?: true
    promotionType?: true
    channels?: true
    strength?: true
    weakness?: true
    createdAt?: true
    _all?: true
  }

  export type CompetitorStrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompetitorStrategy to aggregate.
     */
    where?: CompetitorStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorStrategies to fetch.
     */
    orderBy?: CompetitorStrategyOrderByWithRelationInput | CompetitorStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompetitorStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompetitorStrategies
    **/
    _count?: true | CompetitorStrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompetitorStrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompetitorStrategyMaxAggregateInputType
  }

  export type GetCompetitorStrategyAggregateType<T extends CompetitorStrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompetitorStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompetitorStrategy[P]>
      : GetScalarType<T[P], AggregateCompetitorStrategy[P]>
  }




  export type CompetitorStrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetitorStrategyWhereInput
    orderBy?: CompetitorStrategyOrderByWithAggregationInput | CompetitorStrategyOrderByWithAggregationInput[]
    by: CompetitorStrategyScalarFieldEnum[] | CompetitorStrategyScalarFieldEnum
    having?: CompetitorStrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompetitorStrategyCountAggregateInputType | true
    _min?: CompetitorStrategyMinAggregateInputType
    _max?: CompetitorStrategyMaxAggregateInputType
  }

  export type CompetitorStrategyGroupByOutputType = {
    id: string
    campaignId: string
    competitor: string
    promotionType: string
    channels: string
    strength: string
    weakness: string
    createdAt: Date
    _count: CompetitorStrategyCountAggregateOutputType | null
    _min: CompetitorStrategyMinAggregateOutputType | null
    _max: CompetitorStrategyMaxAggregateOutputType | null
  }

  type GetCompetitorStrategyGroupByPayload<T extends CompetitorStrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompetitorStrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompetitorStrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompetitorStrategyGroupByOutputType[P]>
            : GetScalarType<T[P], CompetitorStrategyGroupByOutputType[P]>
        }
      >
    >


  export type CompetitorStrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    competitor?: boolean
    promotionType?: boolean
    channels?: boolean
    strength?: boolean
    weakness?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["competitorStrategy"]>

  export type CompetitorStrategySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    competitor?: boolean
    promotionType?: boolean
    channels?: boolean
    strength?: boolean
    weakness?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["competitorStrategy"]>

  export type CompetitorStrategySelectScalar = {
    id?: boolean
    campaignId?: boolean
    competitor?: boolean
    promotionType?: boolean
    channels?: boolean
    strength?: boolean
    weakness?: boolean
    createdAt?: boolean
  }

  export type CompetitorStrategyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CompetitorStrategyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CompetitorStrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompetitorStrategy"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      competitor: string
      promotionType: string
      channels: string
      strength: string
      weakness: string
      createdAt: Date
    }, ExtArgs["result"]["competitorStrategy"]>
    composites: {}
  }

  type CompetitorStrategyGetPayload<S extends boolean | null | undefined | CompetitorStrategyDefaultArgs> = $Result.GetResult<Prisma.$CompetitorStrategyPayload, S>

  type CompetitorStrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompetitorStrategyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompetitorStrategyCountAggregateInputType | true
    }

  export interface CompetitorStrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompetitorStrategy'], meta: { name: 'CompetitorStrategy' } }
    /**
     * Find zero or one CompetitorStrategy that matches the filter.
     * @param {CompetitorStrategyFindUniqueArgs} args - Arguments to find a CompetitorStrategy
     * @example
     * // Get one CompetitorStrategy
     * const competitorStrategy = await prisma.competitorStrategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompetitorStrategyFindUniqueArgs>(args: SelectSubset<T, CompetitorStrategyFindUniqueArgs<ExtArgs>>): Prisma__CompetitorStrategyClient<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompetitorStrategy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompetitorStrategyFindUniqueOrThrowArgs} args - Arguments to find a CompetitorStrategy
     * @example
     * // Get one CompetitorStrategy
     * const competitorStrategy = await prisma.competitorStrategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompetitorStrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompetitorStrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompetitorStrategyClient<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompetitorStrategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorStrategyFindFirstArgs} args - Arguments to find a CompetitorStrategy
     * @example
     * // Get one CompetitorStrategy
     * const competitorStrategy = await prisma.competitorStrategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompetitorStrategyFindFirstArgs>(args?: SelectSubset<T, CompetitorStrategyFindFirstArgs<ExtArgs>>): Prisma__CompetitorStrategyClient<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompetitorStrategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorStrategyFindFirstOrThrowArgs} args - Arguments to find a CompetitorStrategy
     * @example
     * // Get one CompetitorStrategy
     * const competitorStrategy = await prisma.competitorStrategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompetitorStrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompetitorStrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompetitorStrategyClient<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompetitorStrategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorStrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompetitorStrategies
     * const competitorStrategies = await prisma.competitorStrategy.findMany()
     * 
     * // Get first 10 CompetitorStrategies
     * const competitorStrategies = await prisma.competitorStrategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const competitorStrategyWithIdOnly = await prisma.competitorStrategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompetitorStrategyFindManyArgs>(args?: SelectSubset<T, CompetitorStrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompetitorStrategy.
     * @param {CompetitorStrategyCreateArgs} args - Arguments to create a CompetitorStrategy.
     * @example
     * // Create one CompetitorStrategy
     * const CompetitorStrategy = await prisma.competitorStrategy.create({
     *   data: {
     *     // ... data to create a CompetitorStrategy
     *   }
     * })
     * 
     */
    create<T extends CompetitorStrategyCreateArgs>(args: SelectSubset<T, CompetitorStrategyCreateArgs<ExtArgs>>): Prisma__CompetitorStrategyClient<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompetitorStrategies.
     * @param {CompetitorStrategyCreateManyArgs} args - Arguments to create many CompetitorStrategies.
     * @example
     * // Create many CompetitorStrategies
     * const competitorStrategy = await prisma.competitorStrategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompetitorStrategyCreateManyArgs>(args?: SelectSubset<T, CompetitorStrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompetitorStrategies and returns the data saved in the database.
     * @param {CompetitorStrategyCreateManyAndReturnArgs} args - Arguments to create many CompetitorStrategies.
     * @example
     * // Create many CompetitorStrategies
     * const competitorStrategy = await prisma.competitorStrategy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompetitorStrategies and only return the `id`
     * const competitorStrategyWithIdOnly = await prisma.competitorStrategy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompetitorStrategyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompetitorStrategyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompetitorStrategy.
     * @param {CompetitorStrategyDeleteArgs} args - Arguments to delete one CompetitorStrategy.
     * @example
     * // Delete one CompetitorStrategy
     * const CompetitorStrategy = await prisma.competitorStrategy.delete({
     *   where: {
     *     // ... filter to delete one CompetitorStrategy
     *   }
     * })
     * 
     */
    delete<T extends CompetitorStrategyDeleteArgs>(args: SelectSubset<T, CompetitorStrategyDeleteArgs<ExtArgs>>): Prisma__CompetitorStrategyClient<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompetitorStrategy.
     * @param {CompetitorStrategyUpdateArgs} args - Arguments to update one CompetitorStrategy.
     * @example
     * // Update one CompetitorStrategy
     * const competitorStrategy = await prisma.competitorStrategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompetitorStrategyUpdateArgs>(args: SelectSubset<T, CompetitorStrategyUpdateArgs<ExtArgs>>): Prisma__CompetitorStrategyClient<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompetitorStrategies.
     * @param {CompetitorStrategyDeleteManyArgs} args - Arguments to filter CompetitorStrategies to delete.
     * @example
     * // Delete a few CompetitorStrategies
     * const { count } = await prisma.competitorStrategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompetitorStrategyDeleteManyArgs>(args?: SelectSubset<T, CompetitorStrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompetitorStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorStrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompetitorStrategies
     * const competitorStrategy = await prisma.competitorStrategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompetitorStrategyUpdateManyArgs>(args: SelectSubset<T, CompetitorStrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompetitorStrategy.
     * @param {CompetitorStrategyUpsertArgs} args - Arguments to update or create a CompetitorStrategy.
     * @example
     * // Update or create a CompetitorStrategy
     * const competitorStrategy = await prisma.competitorStrategy.upsert({
     *   create: {
     *     // ... data to create a CompetitorStrategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompetitorStrategy we want to update
     *   }
     * })
     */
    upsert<T extends CompetitorStrategyUpsertArgs>(args: SelectSubset<T, CompetitorStrategyUpsertArgs<ExtArgs>>): Prisma__CompetitorStrategyClient<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompetitorStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorStrategyCountArgs} args - Arguments to filter CompetitorStrategies to count.
     * @example
     * // Count the number of CompetitorStrategies
     * const count = await prisma.competitorStrategy.count({
     *   where: {
     *     // ... the filter for the CompetitorStrategies we want to count
     *   }
     * })
    **/
    count<T extends CompetitorStrategyCountArgs>(
      args?: Subset<T, CompetitorStrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompetitorStrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompetitorStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorStrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompetitorStrategyAggregateArgs>(args: Subset<T, CompetitorStrategyAggregateArgs>): Prisma.PrismaPromise<GetCompetitorStrategyAggregateType<T>>

    /**
     * Group by CompetitorStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorStrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompetitorStrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompetitorStrategyGroupByArgs['orderBy'] }
        : { orderBy?: CompetitorStrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompetitorStrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompetitorStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompetitorStrategy model
   */
  readonly fields: CompetitorStrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompetitorStrategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompetitorStrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompetitorStrategy model
   */ 
  interface CompetitorStrategyFieldRefs {
    readonly id: FieldRef<"CompetitorStrategy", 'String'>
    readonly campaignId: FieldRef<"CompetitorStrategy", 'String'>
    readonly competitor: FieldRef<"CompetitorStrategy", 'String'>
    readonly promotionType: FieldRef<"CompetitorStrategy", 'String'>
    readonly channels: FieldRef<"CompetitorStrategy", 'String'>
    readonly strength: FieldRef<"CompetitorStrategy", 'String'>
    readonly weakness: FieldRef<"CompetitorStrategy", 'String'>
    readonly createdAt: FieldRef<"CompetitorStrategy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompetitorStrategy findUnique
   */
  export type CompetitorStrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorStrategy to fetch.
     */
    where: CompetitorStrategyWhereUniqueInput
  }

  /**
   * CompetitorStrategy findUniqueOrThrow
   */
  export type CompetitorStrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorStrategy to fetch.
     */
    where: CompetitorStrategyWhereUniqueInput
  }

  /**
   * CompetitorStrategy findFirst
   */
  export type CompetitorStrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorStrategy to fetch.
     */
    where?: CompetitorStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorStrategies to fetch.
     */
    orderBy?: CompetitorStrategyOrderByWithRelationInput | CompetitorStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompetitorStrategies.
     */
    cursor?: CompetitorStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompetitorStrategies.
     */
    distinct?: CompetitorStrategyScalarFieldEnum | CompetitorStrategyScalarFieldEnum[]
  }

  /**
   * CompetitorStrategy findFirstOrThrow
   */
  export type CompetitorStrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorStrategy to fetch.
     */
    where?: CompetitorStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorStrategies to fetch.
     */
    orderBy?: CompetitorStrategyOrderByWithRelationInput | CompetitorStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompetitorStrategies.
     */
    cursor?: CompetitorStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompetitorStrategies.
     */
    distinct?: CompetitorStrategyScalarFieldEnum | CompetitorStrategyScalarFieldEnum[]
  }

  /**
   * CompetitorStrategy findMany
   */
  export type CompetitorStrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    /**
     * Filter, which CompetitorStrategies to fetch.
     */
    where?: CompetitorStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorStrategies to fetch.
     */
    orderBy?: CompetitorStrategyOrderByWithRelationInput | CompetitorStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompetitorStrategies.
     */
    cursor?: CompetitorStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorStrategies.
     */
    skip?: number
    distinct?: CompetitorStrategyScalarFieldEnum | CompetitorStrategyScalarFieldEnum[]
  }

  /**
   * CompetitorStrategy create
   */
  export type CompetitorStrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    /**
     * The data needed to create a CompetitorStrategy.
     */
    data: XOR<CompetitorStrategyCreateInput, CompetitorStrategyUncheckedCreateInput>
  }

  /**
   * CompetitorStrategy createMany
   */
  export type CompetitorStrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompetitorStrategies.
     */
    data: CompetitorStrategyCreateManyInput | CompetitorStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompetitorStrategy createManyAndReturn
   */
  export type CompetitorStrategyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompetitorStrategies.
     */
    data: CompetitorStrategyCreateManyInput | CompetitorStrategyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompetitorStrategy update
   */
  export type CompetitorStrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    /**
     * The data needed to update a CompetitorStrategy.
     */
    data: XOR<CompetitorStrategyUpdateInput, CompetitorStrategyUncheckedUpdateInput>
    /**
     * Choose, which CompetitorStrategy to update.
     */
    where: CompetitorStrategyWhereUniqueInput
  }

  /**
   * CompetitorStrategy updateMany
   */
  export type CompetitorStrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompetitorStrategies.
     */
    data: XOR<CompetitorStrategyUpdateManyMutationInput, CompetitorStrategyUncheckedUpdateManyInput>
    /**
     * Filter which CompetitorStrategies to update
     */
    where?: CompetitorStrategyWhereInput
  }

  /**
   * CompetitorStrategy upsert
   */
  export type CompetitorStrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    /**
     * The filter to search for the CompetitorStrategy to update in case it exists.
     */
    where: CompetitorStrategyWhereUniqueInput
    /**
     * In case the CompetitorStrategy found by the `where` argument doesn't exist, create a new CompetitorStrategy with this data.
     */
    create: XOR<CompetitorStrategyCreateInput, CompetitorStrategyUncheckedCreateInput>
    /**
     * In case the CompetitorStrategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompetitorStrategyUpdateInput, CompetitorStrategyUncheckedUpdateInput>
  }

  /**
   * CompetitorStrategy delete
   */
  export type CompetitorStrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    /**
     * Filter which CompetitorStrategy to delete.
     */
    where: CompetitorStrategyWhereUniqueInput
  }

  /**
   * CompetitorStrategy deleteMany
   */
  export type CompetitorStrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompetitorStrategies to delete
     */
    where?: CompetitorStrategyWhereInput
  }

  /**
   * CompetitorStrategy without action
   */
  export type CompetitorStrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
  }


  /**
   * Model EnterpriseContext
   */

  export type AggregateEnterpriseContext = {
    _count: EnterpriseContextCountAggregateOutputType | null
    _min: EnterpriseContextMinAggregateOutputType | null
    _max: EnterpriseContextMaxAggregateOutputType | null
  }

  export type EnterpriseContextMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    companyName: string | null
    domain: string | null
    businessModel: string | null
    background: string | null
    currentPain: string | null
    goals: string | null
    createdAt: Date | null
  }

  export type EnterpriseContextMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    companyName: string | null
    domain: string | null
    businessModel: string | null
    background: string | null
    currentPain: string | null
    goals: string | null
    createdAt: Date | null
  }

  export type EnterpriseContextCountAggregateOutputType = {
    id: number
    campaignId: number
    companyName: number
    domain: number
    businessModel: number
    background: number
    currentPain: number
    goals: number
    createdAt: number
    _all: number
  }


  export type EnterpriseContextMinAggregateInputType = {
    id?: true
    campaignId?: true
    companyName?: true
    domain?: true
    businessModel?: true
    background?: true
    currentPain?: true
    goals?: true
    createdAt?: true
  }

  export type EnterpriseContextMaxAggregateInputType = {
    id?: true
    campaignId?: true
    companyName?: true
    domain?: true
    businessModel?: true
    background?: true
    currentPain?: true
    goals?: true
    createdAt?: true
  }

  export type EnterpriseContextCountAggregateInputType = {
    id?: true
    campaignId?: true
    companyName?: true
    domain?: true
    businessModel?: true
    background?: true
    currentPain?: true
    goals?: true
    createdAt?: true
    _all?: true
  }

  export type EnterpriseContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnterpriseContext to aggregate.
     */
    where?: EnterpriseContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseContexts to fetch.
     */
    orderBy?: EnterpriseContextOrderByWithRelationInput | EnterpriseContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnterpriseContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnterpriseContexts
    **/
    _count?: true | EnterpriseContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnterpriseContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnterpriseContextMaxAggregateInputType
  }

  export type GetEnterpriseContextAggregateType<T extends EnterpriseContextAggregateArgs> = {
        [P in keyof T & keyof AggregateEnterpriseContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnterpriseContext[P]>
      : GetScalarType<T[P], AggregateEnterpriseContext[P]>
  }




  export type EnterpriseContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnterpriseContextWhereInput
    orderBy?: EnterpriseContextOrderByWithAggregationInput | EnterpriseContextOrderByWithAggregationInput[]
    by: EnterpriseContextScalarFieldEnum[] | EnterpriseContextScalarFieldEnum
    having?: EnterpriseContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnterpriseContextCountAggregateInputType | true
    _min?: EnterpriseContextMinAggregateInputType
    _max?: EnterpriseContextMaxAggregateInputType
  }

  export type EnterpriseContextGroupByOutputType = {
    id: string
    campaignId: string
    companyName: string
    domain: string
    businessModel: string
    background: string
    currentPain: string
    goals: string
    createdAt: Date
    _count: EnterpriseContextCountAggregateOutputType | null
    _min: EnterpriseContextMinAggregateOutputType | null
    _max: EnterpriseContextMaxAggregateOutputType | null
  }

  type GetEnterpriseContextGroupByPayload<T extends EnterpriseContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnterpriseContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnterpriseContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnterpriseContextGroupByOutputType[P]>
            : GetScalarType<T[P], EnterpriseContextGroupByOutputType[P]>
        }
      >
    >


  export type EnterpriseContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    companyName?: boolean
    domain?: boolean
    businessModel?: boolean
    background?: boolean
    currentPain?: boolean
    goals?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enterpriseContext"]>

  export type EnterpriseContextSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    companyName?: boolean
    domain?: boolean
    businessModel?: boolean
    background?: boolean
    currentPain?: boolean
    goals?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enterpriseContext"]>

  export type EnterpriseContextSelectScalar = {
    id?: boolean
    campaignId?: boolean
    companyName?: boolean
    domain?: boolean
    businessModel?: boolean
    background?: boolean
    currentPain?: boolean
    goals?: boolean
    createdAt?: boolean
  }

  export type EnterpriseContextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type EnterpriseContextIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $EnterpriseContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnterpriseContext"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      companyName: string
      domain: string
      businessModel: string
      background: string
      currentPain: string
      goals: string
      createdAt: Date
    }, ExtArgs["result"]["enterpriseContext"]>
    composites: {}
  }

  type EnterpriseContextGetPayload<S extends boolean | null | undefined | EnterpriseContextDefaultArgs> = $Result.GetResult<Prisma.$EnterpriseContextPayload, S>

  type EnterpriseContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnterpriseContextFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnterpriseContextCountAggregateInputType | true
    }

  export interface EnterpriseContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnterpriseContext'], meta: { name: 'EnterpriseContext' } }
    /**
     * Find zero or one EnterpriseContext that matches the filter.
     * @param {EnterpriseContextFindUniqueArgs} args - Arguments to find a EnterpriseContext
     * @example
     * // Get one EnterpriseContext
     * const enterpriseContext = await prisma.enterpriseContext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnterpriseContextFindUniqueArgs>(args: SelectSubset<T, EnterpriseContextFindUniqueArgs<ExtArgs>>): Prisma__EnterpriseContextClient<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EnterpriseContext that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnterpriseContextFindUniqueOrThrowArgs} args - Arguments to find a EnterpriseContext
     * @example
     * // Get one EnterpriseContext
     * const enterpriseContext = await prisma.enterpriseContext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnterpriseContextFindUniqueOrThrowArgs>(args: SelectSubset<T, EnterpriseContextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnterpriseContextClient<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EnterpriseContext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseContextFindFirstArgs} args - Arguments to find a EnterpriseContext
     * @example
     * // Get one EnterpriseContext
     * const enterpriseContext = await prisma.enterpriseContext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnterpriseContextFindFirstArgs>(args?: SelectSubset<T, EnterpriseContextFindFirstArgs<ExtArgs>>): Prisma__EnterpriseContextClient<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EnterpriseContext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseContextFindFirstOrThrowArgs} args - Arguments to find a EnterpriseContext
     * @example
     * // Get one EnterpriseContext
     * const enterpriseContext = await prisma.enterpriseContext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnterpriseContextFindFirstOrThrowArgs>(args?: SelectSubset<T, EnterpriseContextFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnterpriseContextClient<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EnterpriseContexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseContextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnterpriseContexts
     * const enterpriseContexts = await prisma.enterpriseContext.findMany()
     * 
     * // Get first 10 EnterpriseContexts
     * const enterpriseContexts = await prisma.enterpriseContext.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enterpriseContextWithIdOnly = await prisma.enterpriseContext.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnterpriseContextFindManyArgs>(args?: SelectSubset<T, EnterpriseContextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EnterpriseContext.
     * @param {EnterpriseContextCreateArgs} args - Arguments to create a EnterpriseContext.
     * @example
     * // Create one EnterpriseContext
     * const EnterpriseContext = await prisma.enterpriseContext.create({
     *   data: {
     *     // ... data to create a EnterpriseContext
     *   }
     * })
     * 
     */
    create<T extends EnterpriseContextCreateArgs>(args: SelectSubset<T, EnterpriseContextCreateArgs<ExtArgs>>): Prisma__EnterpriseContextClient<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EnterpriseContexts.
     * @param {EnterpriseContextCreateManyArgs} args - Arguments to create many EnterpriseContexts.
     * @example
     * // Create many EnterpriseContexts
     * const enterpriseContext = await prisma.enterpriseContext.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnterpriseContextCreateManyArgs>(args?: SelectSubset<T, EnterpriseContextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnterpriseContexts and returns the data saved in the database.
     * @param {EnterpriseContextCreateManyAndReturnArgs} args - Arguments to create many EnterpriseContexts.
     * @example
     * // Create many EnterpriseContexts
     * const enterpriseContext = await prisma.enterpriseContext.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnterpriseContexts and only return the `id`
     * const enterpriseContextWithIdOnly = await prisma.enterpriseContext.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnterpriseContextCreateManyAndReturnArgs>(args?: SelectSubset<T, EnterpriseContextCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EnterpriseContext.
     * @param {EnterpriseContextDeleteArgs} args - Arguments to delete one EnterpriseContext.
     * @example
     * // Delete one EnterpriseContext
     * const EnterpriseContext = await prisma.enterpriseContext.delete({
     *   where: {
     *     // ... filter to delete one EnterpriseContext
     *   }
     * })
     * 
     */
    delete<T extends EnterpriseContextDeleteArgs>(args: SelectSubset<T, EnterpriseContextDeleteArgs<ExtArgs>>): Prisma__EnterpriseContextClient<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EnterpriseContext.
     * @param {EnterpriseContextUpdateArgs} args - Arguments to update one EnterpriseContext.
     * @example
     * // Update one EnterpriseContext
     * const enterpriseContext = await prisma.enterpriseContext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnterpriseContextUpdateArgs>(args: SelectSubset<T, EnterpriseContextUpdateArgs<ExtArgs>>): Prisma__EnterpriseContextClient<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EnterpriseContexts.
     * @param {EnterpriseContextDeleteManyArgs} args - Arguments to filter EnterpriseContexts to delete.
     * @example
     * // Delete a few EnterpriseContexts
     * const { count } = await prisma.enterpriseContext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnterpriseContextDeleteManyArgs>(args?: SelectSubset<T, EnterpriseContextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnterpriseContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnterpriseContexts
     * const enterpriseContext = await prisma.enterpriseContext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnterpriseContextUpdateManyArgs>(args: SelectSubset<T, EnterpriseContextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EnterpriseContext.
     * @param {EnterpriseContextUpsertArgs} args - Arguments to update or create a EnterpriseContext.
     * @example
     * // Update or create a EnterpriseContext
     * const enterpriseContext = await prisma.enterpriseContext.upsert({
     *   create: {
     *     // ... data to create a EnterpriseContext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnterpriseContext we want to update
     *   }
     * })
     */
    upsert<T extends EnterpriseContextUpsertArgs>(args: SelectSubset<T, EnterpriseContextUpsertArgs<ExtArgs>>): Prisma__EnterpriseContextClient<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EnterpriseContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseContextCountArgs} args - Arguments to filter EnterpriseContexts to count.
     * @example
     * // Count the number of EnterpriseContexts
     * const count = await prisma.enterpriseContext.count({
     *   where: {
     *     // ... the filter for the EnterpriseContexts we want to count
     *   }
     * })
    **/
    count<T extends EnterpriseContextCountArgs>(
      args?: Subset<T, EnterpriseContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnterpriseContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnterpriseContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnterpriseContextAggregateArgs>(args: Subset<T, EnterpriseContextAggregateArgs>): Prisma.PrismaPromise<GetEnterpriseContextAggregateType<T>>

    /**
     * Group by EnterpriseContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnterpriseContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnterpriseContextGroupByArgs['orderBy'] }
        : { orderBy?: EnterpriseContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnterpriseContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnterpriseContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnterpriseContext model
   */
  readonly fields: EnterpriseContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnterpriseContext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnterpriseContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnterpriseContext model
   */ 
  interface EnterpriseContextFieldRefs {
    readonly id: FieldRef<"EnterpriseContext", 'String'>
    readonly campaignId: FieldRef<"EnterpriseContext", 'String'>
    readonly companyName: FieldRef<"EnterpriseContext", 'String'>
    readonly domain: FieldRef<"EnterpriseContext", 'String'>
    readonly businessModel: FieldRef<"EnterpriseContext", 'String'>
    readonly background: FieldRef<"EnterpriseContext", 'String'>
    readonly currentPain: FieldRef<"EnterpriseContext", 'String'>
    readonly goals: FieldRef<"EnterpriseContext", 'String'>
    readonly createdAt: FieldRef<"EnterpriseContext", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EnterpriseContext findUnique
   */
  export type EnterpriseContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseContext to fetch.
     */
    where: EnterpriseContextWhereUniqueInput
  }

  /**
   * EnterpriseContext findUniqueOrThrow
   */
  export type EnterpriseContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseContext to fetch.
     */
    where: EnterpriseContextWhereUniqueInput
  }

  /**
   * EnterpriseContext findFirst
   */
  export type EnterpriseContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseContext to fetch.
     */
    where?: EnterpriseContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseContexts to fetch.
     */
    orderBy?: EnterpriseContextOrderByWithRelationInput | EnterpriseContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnterpriseContexts.
     */
    cursor?: EnterpriseContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnterpriseContexts.
     */
    distinct?: EnterpriseContextScalarFieldEnum | EnterpriseContextScalarFieldEnum[]
  }

  /**
   * EnterpriseContext findFirstOrThrow
   */
  export type EnterpriseContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseContext to fetch.
     */
    where?: EnterpriseContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseContexts to fetch.
     */
    orderBy?: EnterpriseContextOrderByWithRelationInput | EnterpriseContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnterpriseContexts.
     */
    cursor?: EnterpriseContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnterpriseContexts.
     */
    distinct?: EnterpriseContextScalarFieldEnum | EnterpriseContextScalarFieldEnum[]
  }

  /**
   * EnterpriseContext findMany
   */
  export type EnterpriseContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    /**
     * Filter, which EnterpriseContexts to fetch.
     */
    where?: EnterpriseContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseContexts to fetch.
     */
    orderBy?: EnterpriseContextOrderByWithRelationInput | EnterpriseContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnterpriseContexts.
     */
    cursor?: EnterpriseContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseContexts.
     */
    skip?: number
    distinct?: EnterpriseContextScalarFieldEnum | EnterpriseContextScalarFieldEnum[]
  }

  /**
   * EnterpriseContext create
   */
  export type EnterpriseContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    /**
     * The data needed to create a EnterpriseContext.
     */
    data: XOR<EnterpriseContextCreateInput, EnterpriseContextUncheckedCreateInput>
  }

  /**
   * EnterpriseContext createMany
   */
  export type EnterpriseContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnterpriseContexts.
     */
    data: EnterpriseContextCreateManyInput | EnterpriseContextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnterpriseContext createManyAndReturn
   */
  export type EnterpriseContextCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EnterpriseContexts.
     */
    data: EnterpriseContextCreateManyInput | EnterpriseContextCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnterpriseContext update
   */
  export type EnterpriseContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    /**
     * The data needed to update a EnterpriseContext.
     */
    data: XOR<EnterpriseContextUpdateInput, EnterpriseContextUncheckedUpdateInput>
    /**
     * Choose, which EnterpriseContext to update.
     */
    where: EnterpriseContextWhereUniqueInput
  }

  /**
   * EnterpriseContext updateMany
   */
  export type EnterpriseContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnterpriseContexts.
     */
    data: XOR<EnterpriseContextUpdateManyMutationInput, EnterpriseContextUncheckedUpdateManyInput>
    /**
     * Filter which EnterpriseContexts to update
     */
    where?: EnterpriseContextWhereInput
  }

  /**
   * EnterpriseContext upsert
   */
  export type EnterpriseContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    /**
     * The filter to search for the EnterpriseContext to update in case it exists.
     */
    where: EnterpriseContextWhereUniqueInput
    /**
     * In case the EnterpriseContext found by the `where` argument doesn't exist, create a new EnterpriseContext with this data.
     */
    create: XOR<EnterpriseContextCreateInput, EnterpriseContextUncheckedCreateInput>
    /**
     * In case the EnterpriseContext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnterpriseContextUpdateInput, EnterpriseContextUncheckedUpdateInput>
  }

  /**
   * EnterpriseContext delete
   */
  export type EnterpriseContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    /**
     * Filter which EnterpriseContext to delete.
     */
    where: EnterpriseContextWhereUniqueInput
  }

  /**
   * EnterpriseContext deleteMany
   */
  export type EnterpriseContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnterpriseContexts to delete
     */
    where?: EnterpriseContextWhereInput
  }

  /**
   * EnterpriseContext without action
   */
  export type EnterpriseContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
  }


  /**
   * Model AudienceSegment
   */

  export type AggregateAudienceSegment = {
    _count: AudienceSegmentCountAggregateOutputType | null
    _min: AudienceSegmentMinAggregateOutputType | null
    _max: AudienceSegmentMaxAggregateOutputType | null
  }

  export type AudienceSegmentMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    label: string | null
    demographics: string | null
    behavior: string | null
    painPoints: string | null
    createdAt: Date | null
  }

  export type AudienceSegmentMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    label: string | null
    demographics: string | null
    behavior: string | null
    painPoints: string | null
    createdAt: Date | null
  }

  export type AudienceSegmentCountAggregateOutputType = {
    id: number
    campaignId: number
    label: number
    demographics: number
    behavior: number
    painPoints: number
    createdAt: number
    _all: number
  }


  export type AudienceSegmentMinAggregateInputType = {
    id?: true
    campaignId?: true
    label?: true
    demographics?: true
    behavior?: true
    painPoints?: true
    createdAt?: true
  }

  export type AudienceSegmentMaxAggregateInputType = {
    id?: true
    campaignId?: true
    label?: true
    demographics?: true
    behavior?: true
    painPoints?: true
    createdAt?: true
  }

  export type AudienceSegmentCountAggregateInputType = {
    id?: true
    campaignId?: true
    label?: true
    demographics?: true
    behavior?: true
    painPoints?: true
    createdAt?: true
    _all?: true
  }

  export type AudienceSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudienceSegment to aggregate.
     */
    where?: AudienceSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudienceSegments to fetch.
     */
    orderBy?: AudienceSegmentOrderByWithRelationInput | AudienceSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudienceSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudienceSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudienceSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudienceSegments
    **/
    _count?: true | AudienceSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudienceSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudienceSegmentMaxAggregateInputType
  }

  export type GetAudienceSegmentAggregateType<T extends AudienceSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAudienceSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudienceSegment[P]>
      : GetScalarType<T[P], AggregateAudienceSegment[P]>
  }




  export type AudienceSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudienceSegmentWhereInput
    orderBy?: AudienceSegmentOrderByWithAggregationInput | AudienceSegmentOrderByWithAggregationInput[]
    by: AudienceSegmentScalarFieldEnum[] | AudienceSegmentScalarFieldEnum
    having?: AudienceSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudienceSegmentCountAggregateInputType | true
    _min?: AudienceSegmentMinAggregateInputType
    _max?: AudienceSegmentMaxAggregateInputType
  }

  export type AudienceSegmentGroupByOutputType = {
    id: string
    campaignId: string
    label: string
    demographics: string
    behavior: string
    painPoints: string
    createdAt: Date
    _count: AudienceSegmentCountAggregateOutputType | null
    _min: AudienceSegmentMinAggregateOutputType | null
    _max: AudienceSegmentMaxAggregateOutputType | null
  }

  type GetAudienceSegmentGroupByPayload<T extends AudienceSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudienceSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudienceSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudienceSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], AudienceSegmentGroupByOutputType[P]>
        }
      >
    >


  export type AudienceSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    label?: boolean
    demographics?: boolean
    behavior?: boolean
    painPoints?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audienceSegment"]>

  export type AudienceSegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    label?: boolean
    demographics?: boolean
    behavior?: boolean
    painPoints?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audienceSegment"]>

  export type AudienceSegmentSelectScalar = {
    id?: boolean
    campaignId?: boolean
    label?: boolean
    demographics?: boolean
    behavior?: boolean
    painPoints?: boolean
    createdAt?: boolean
  }

  export type AudienceSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type AudienceSegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $AudienceSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudienceSegment"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      label: string
      demographics: string
      behavior: string
      painPoints: string
      createdAt: Date
    }, ExtArgs["result"]["audienceSegment"]>
    composites: {}
  }

  type AudienceSegmentGetPayload<S extends boolean | null | undefined | AudienceSegmentDefaultArgs> = $Result.GetResult<Prisma.$AudienceSegmentPayload, S>

  type AudienceSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudienceSegmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudienceSegmentCountAggregateInputType | true
    }

  export interface AudienceSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudienceSegment'], meta: { name: 'AudienceSegment' } }
    /**
     * Find zero or one AudienceSegment that matches the filter.
     * @param {AudienceSegmentFindUniqueArgs} args - Arguments to find a AudienceSegment
     * @example
     * // Get one AudienceSegment
     * const audienceSegment = await prisma.audienceSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudienceSegmentFindUniqueArgs>(args: SelectSubset<T, AudienceSegmentFindUniqueArgs<ExtArgs>>): Prisma__AudienceSegmentClient<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudienceSegment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudienceSegmentFindUniqueOrThrowArgs} args - Arguments to find a AudienceSegment
     * @example
     * // Get one AudienceSegment
     * const audienceSegment = await prisma.audienceSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudienceSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AudienceSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudienceSegmentClient<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudienceSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceSegmentFindFirstArgs} args - Arguments to find a AudienceSegment
     * @example
     * // Get one AudienceSegment
     * const audienceSegment = await prisma.audienceSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudienceSegmentFindFirstArgs>(args?: SelectSubset<T, AudienceSegmentFindFirstArgs<ExtArgs>>): Prisma__AudienceSegmentClient<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudienceSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceSegmentFindFirstOrThrowArgs} args - Arguments to find a AudienceSegment
     * @example
     * // Get one AudienceSegment
     * const audienceSegment = await prisma.audienceSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudienceSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AudienceSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudienceSegmentClient<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudienceSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudienceSegments
     * const audienceSegments = await prisma.audienceSegment.findMany()
     * 
     * // Get first 10 AudienceSegments
     * const audienceSegments = await prisma.audienceSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audienceSegmentWithIdOnly = await prisma.audienceSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudienceSegmentFindManyArgs>(args?: SelectSubset<T, AudienceSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudienceSegment.
     * @param {AudienceSegmentCreateArgs} args - Arguments to create a AudienceSegment.
     * @example
     * // Create one AudienceSegment
     * const AudienceSegment = await prisma.audienceSegment.create({
     *   data: {
     *     // ... data to create a AudienceSegment
     *   }
     * })
     * 
     */
    create<T extends AudienceSegmentCreateArgs>(args: SelectSubset<T, AudienceSegmentCreateArgs<ExtArgs>>): Prisma__AudienceSegmentClient<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudienceSegments.
     * @param {AudienceSegmentCreateManyArgs} args - Arguments to create many AudienceSegments.
     * @example
     * // Create many AudienceSegments
     * const audienceSegment = await prisma.audienceSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudienceSegmentCreateManyArgs>(args?: SelectSubset<T, AudienceSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudienceSegments and returns the data saved in the database.
     * @param {AudienceSegmentCreateManyAndReturnArgs} args - Arguments to create many AudienceSegments.
     * @example
     * // Create many AudienceSegments
     * const audienceSegment = await prisma.audienceSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudienceSegments and only return the `id`
     * const audienceSegmentWithIdOnly = await prisma.audienceSegment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudienceSegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AudienceSegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudienceSegment.
     * @param {AudienceSegmentDeleteArgs} args - Arguments to delete one AudienceSegment.
     * @example
     * // Delete one AudienceSegment
     * const AudienceSegment = await prisma.audienceSegment.delete({
     *   where: {
     *     // ... filter to delete one AudienceSegment
     *   }
     * })
     * 
     */
    delete<T extends AudienceSegmentDeleteArgs>(args: SelectSubset<T, AudienceSegmentDeleteArgs<ExtArgs>>): Prisma__AudienceSegmentClient<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudienceSegment.
     * @param {AudienceSegmentUpdateArgs} args - Arguments to update one AudienceSegment.
     * @example
     * // Update one AudienceSegment
     * const audienceSegment = await prisma.audienceSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudienceSegmentUpdateArgs>(args: SelectSubset<T, AudienceSegmentUpdateArgs<ExtArgs>>): Prisma__AudienceSegmentClient<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudienceSegments.
     * @param {AudienceSegmentDeleteManyArgs} args - Arguments to filter AudienceSegments to delete.
     * @example
     * // Delete a few AudienceSegments
     * const { count } = await prisma.audienceSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudienceSegmentDeleteManyArgs>(args?: SelectSubset<T, AudienceSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudienceSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudienceSegments
     * const audienceSegment = await prisma.audienceSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudienceSegmentUpdateManyArgs>(args: SelectSubset<T, AudienceSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudienceSegment.
     * @param {AudienceSegmentUpsertArgs} args - Arguments to update or create a AudienceSegment.
     * @example
     * // Update or create a AudienceSegment
     * const audienceSegment = await prisma.audienceSegment.upsert({
     *   create: {
     *     // ... data to create a AudienceSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudienceSegment we want to update
     *   }
     * })
     */
    upsert<T extends AudienceSegmentUpsertArgs>(args: SelectSubset<T, AudienceSegmentUpsertArgs<ExtArgs>>): Prisma__AudienceSegmentClient<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudienceSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceSegmentCountArgs} args - Arguments to filter AudienceSegments to count.
     * @example
     * // Count the number of AudienceSegments
     * const count = await prisma.audienceSegment.count({
     *   where: {
     *     // ... the filter for the AudienceSegments we want to count
     *   }
     * })
    **/
    count<T extends AudienceSegmentCountArgs>(
      args?: Subset<T, AudienceSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudienceSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudienceSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudienceSegmentAggregateArgs>(args: Subset<T, AudienceSegmentAggregateArgs>): Prisma.PrismaPromise<GetAudienceSegmentAggregateType<T>>

    /**
     * Group by AudienceSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudienceSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudienceSegmentGroupByArgs['orderBy'] }
        : { orderBy?: AudienceSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudienceSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudienceSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudienceSegment model
   */
  readonly fields: AudienceSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudienceSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudienceSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudienceSegment model
   */ 
  interface AudienceSegmentFieldRefs {
    readonly id: FieldRef<"AudienceSegment", 'String'>
    readonly campaignId: FieldRef<"AudienceSegment", 'String'>
    readonly label: FieldRef<"AudienceSegment", 'String'>
    readonly demographics: FieldRef<"AudienceSegment", 'String'>
    readonly behavior: FieldRef<"AudienceSegment", 'String'>
    readonly painPoints: FieldRef<"AudienceSegment", 'String'>
    readonly createdAt: FieldRef<"AudienceSegment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudienceSegment findUnique
   */
  export type AudienceSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudienceSegment to fetch.
     */
    where: AudienceSegmentWhereUniqueInput
  }

  /**
   * AudienceSegment findUniqueOrThrow
   */
  export type AudienceSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudienceSegment to fetch.
     */
    where: AudienceSegmentWhereUniqueInput
  }

  /**
   * AudienceSegment findFirst
   */
  export type AudienceSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudienceSegment to fetch.
     */
    where?: AudienceSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudienceSegments to fetch.
     */
    orderBy?: AudienceSegmentOrderByWithRelationInput | AudienceSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudienceSegments.
     */
    cursor?: AudienceSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudienceSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudienceSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudienceSegments.
     */
    distinct?: AudienceSegmentScalarFieldEnum | AudienceSegmentScalarFieldEnum[]
  }

  /**
   * AudienceSegment findFirstOrThrow
   */
  export type AudienceSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudienceSegment to fetch.
     */
    where?: AudienceSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudienceSegments to fetch.
     */
    orderBy?: AudienceSegmentOrderByWithRelationInput | AudienceSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudienceSegments.
     */
    cursor?: AudienceSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudienceSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudienceSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudienceSegments.
     */
    distinct?: AudienceSegmentScalarFieldEnum | AudienceSegmentScalarFieldEnum[]
  }

  /**
   * AudienceSegment findMany
   */
  export type AudienceSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which AudienceSegments to fetch.
     */
    where?: AudienceSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudienceSegments to fetch.
     */
    orderBy?: AudienceSegmentOrderByWithRelationInput | AudienceSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudienceSegments.
     */
    cursor?: AudienceSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudienceSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudienceSegments.
     */
    skip?: number
    distinct?: AudienceSegmentScalarFieldEnum | AudienceSegmentScalarFieldEnum[]
  }

  /**
   * AudienceSegment create
   */
  export type AudienceSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AudienceSegment.
     */
    data: XOR<AudienceSegmentCreateInput, AudienceSegmentUncheckedCreateInput>
  }

  /**
   * AudienceSegment createMany
   */
  export type AudienceSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudienceSegments.
     */
    data: AudienceSegmentCreateManyInput | AudienceSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudienceSegment createManyAndReturn
   */
  export type AudienceSegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudienceSegments.
     */
    data: AudienceSegmentCreateManyInput | AudienceSegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudienceSegment update
   */
  export type AudienceSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AudienceSegment.
     */
    data: XOR<AudienceSegmentUpdateInput, AudienceSegmentUncheckedUpdateInput>
    /**
     * Choose, which AudienceSegment to update.
     */
    where: AudienceSegmentWhereUniqueInput
  }

  /**
   * AudienceSegment updateMany
   */
  export type AudienceSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudienceSegments.
     */
    data: XOR<AudienceSegmentUpdateManyMutationInput, AudienceSegmentUncheckedUpdateManyInput>
    /**
     * Filter which AudienceSegments to update
     */
    where?: AudienceSegmentWhereInput
  }

  /**
   * AudienceSegment upsert
   */
  export type AudienceSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AudienceSegment to update in case it exists.
     */
    where: AudienceSegmentWhereUniqueInput
    /**
     * In case the AudienceSegment found by the `where` argument doesn't exist, create a new AudienceSegment with this data.
     */
    create: XOR<AudienceSegmentCreateInput, AudienceSegmentUncheckedCreateInput>
    /**
     * In case the AudienceSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudienceSegmentUpdateInput, AudienceSegmentUncheckedUpdateInput>
  }

  /**
   * AudienceSegment delete
   */
  export type AudienceSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter which AudienceSegment to delete.
     */
    where: AudienceSegmentWhereUniqueInput
  }

  /**
   * AudienceSegment deleteMany
   */
  export type AudienceSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudienceSegments to delete
     */
    where?: AudienceSegmentWhereInput
  }

  /**
   * AudienceSegment without action
   */
  export type AudienceSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enterpriseContexts?: boolean | Campaign$enterpriseContextsArgs<ExtArgs>
    audienceSegments?: boolean | Campaign$audienceSegmentsArgs<ExtArgs>
    creativePlans?: boolean | Campaign$creativePlansArgs<ExtArgs>
    objectives?: boolean | Campaign$objectivesArgs<ExtArgs>
    audiences?: boolean | Campaign$audiencesArgs<ExtArgs>
    competitors?: boolean | Campaign$competitorsArgs<ExtArgs>
    promotions?: boolean | Campaign$promotionsArgs<ExtArgs>
    offers?: boolean | Campaign$offersArgs<ExtArgs>
    budgets?: boolean | Campaign$budgetsArgs<ExtArgs>
    channels?: boolean | Campaign$channelsArgs<ExtArgs>
    timelines?: boolean | Campaign$timelinesArgs<ExtArgs>
    compliances?: boolean | Campaign$compliancesArgs<ExtArgs>
    creatives?: boolean | Campaign$creativesArgs<ExtArgs>
    messages?: boolean | Campaign$messagesArgs<ExtArgs>
    mediaAssets?: boolean | Campaign$mediaAssetsArgs<ExtArgs>
    calendars?: boolean | Campaign$calendarsArgs<ExtArgs>
    teasers?: boolean | Campaign$teasersArgs<ExtArgs>
    customers?: boolean | Campaign$customersArgs<ExtArgs>
    influencers?: boolean | Campaign$influencersArgs<ExtArgs>
    checklists?: boolean | Campaign$checklistsArgs<ExtArgs>
    activations?: boolean | Campaign$activationsArgs<ExtArgs>
    engagements?: boolean | Campaign$engagementsArgs<ExtArgs>
    reports?: boolean | Campaign$reportsArgs<ExtArgs>
    feedbacks?: boolean | Campaign$feedbacksArgs<ExtArgs>
    thanks?: boolean | Campaign$thanksArgs<ExtArgs>
    retargetings?: boolean | Campaign$retargetingsArgs<ExtArgs>
    extensions?: boolean | Campaign$extensionsArgs<ExtArgs>
    analysisReports?: boolean | Campaign$analysisReportsArgs<ExtArgs>
    learnings?: boolean | Campaign$learningsArgs<ExtArgs>
    internalReports?: boolean | Campaign$internalReportsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enterpriseContexts?: boolean | Campaign$enterpriseContextsArgs<ExtArgs>
    audienceSegments?: boolean | Campaign$audienceSegmentsArgs<ExtArgs>
    creativePlans?: boolean | Campaign$creativePlansArgs<ExtArgs>
    objectives?: boolean | Campaign$objectivesArgs<ExtArgs>
    audiences?: boolean | Campaign$audiencesArgs<ExtArgs>
    competitors?: boolean | Campaign$competitorsArgs<ExtArgs>
    promotions?: boolean | Campaign$promotionsArgs<ExtArgs>
    offers?: boolean | Campaign$offersArgs<ExtArgs>
    budgets?: boolean | Campaign$budgetsArgs<ExtArgs>
    channels?: boolean | Campaign$channelsArgs<ExtArgs>
    timelines?: boolean | Campaign$timelinesArgs<ExtArgs>
    compliances?: boolean | Campaign$compliancesArgs<ExtArgs>
    creatives?: boolean | Campaign$creativesArgs<ExtArgs>
    messages?: boolean | Campaign$messagesArgs<ExtArgs>
    mediaAssets?: boolean | Campaign$mediaAssetsArgs<ExtArgs>
    calendars?: boolean | Campaign$calendarsArgs<ExtArgs>
    teasers?: boolean | Campaign$teasersArgs<ExtArgs>
    customers?: boolean | Campaign$customersArgs<ExtArgs>
    influencers?: boolean | Campaign$influencersArgs<ExtArgs>
    checklists?: boolean | Campaign$checklistsArgs<ExtArgs>
    activations?: boolean | Campaign$activationsArgs<ExtArgs>
    engagements?: boolean | Campaign$engagementsArgs<ExtArgs>
    reports?: boolean | Campaign$reportsArgs<ExtArgs>
    feedbacks?: boolean | Campaign$feedbacksArgs<ExtArgs>
    thanks?: boolean | Campaign$thanksArgs<ExtArgs>
    retargetings?: boolean | Campaign$retargetingsArgs<ExtArgs>
    extensions?: boolean | Campaign$extensionsArgs<ExtArgs>
    analysisReports?: boolean | Campaign$analysisReportsArgs<ExtArgs>
    learnings?: boolean | Campaign$learningsArgs<ExtArgs>
    internalReports?: boolean | Campaign$internalReportsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      enterpriseContexts: Prisma.$EnterpriseContextPayload<ExtArgs>[]
      audienceSegments: Prisma.$AudienceSegmentPayload<ExtArgs>[]
      creativePlans: Prisma.$CreativeDesignPlanPayload<ExtArgs>[]
      objectives: Prisma.$CampaignObjectivePayload<ExtArgs>[]
      audiences: Prisma.$TargetAudienceSegmentPayload<ExtArgs>[]
      competitors: Prisma.$CompetitorStrategyPayload<ExtArgs>[]
      promotions: Prisma.$PromotionTypePayload<ExtArgs>[]
      offers: Prisma.$CampaignOfferPayload<ExtArgs>[]
      budgets: Prisma.$CampaignBudgetPayload<ExtArgs>[]
      channels: Prisma.$ChannelPlanPayload<ExtArgs>[]
      timelines: Prisma.$CampaignTimelinePayload<ExtArgs>[]
      compliances: Prisma.$ComplianceChecklistPayload<ExtArgs>[]
      creatives: Prisma.$CreativeAssetPayload<ExtArgs>[]
      messages: Prisma.$PromotionalMessagePayload<ExtArgs>[]
      mediaAssets: Prisma.$MediaAssetPayload<ExtArgs>[]
      calendars: Prisma.$ContentCalendarPayload<ExtArgs>[]
      teasers: Prisma.$TeaserContentPayload<ExtArgs>[]
      customers: Prisma.$CustomerSegmentListPayload<ExtArgs>[]
      influencers: Prisma.$InfluencerPlanPayload<ExtArgs>[]
      checklists: Prisma.$OperationalChecklistPayload<ExtArgs>[]
      activations: Prisma.$CampaignActivationPayload<ExtArgs>[]
      engagements: Prisma.$CustomerEngagementLogPayload<ExtArgs>[]
      reports: Prisma.$PerformanceReportPayload<ExtArgs>[]
      feedbacks: Prisma.$CustomerFeedbackPayload<ExtArgs>[]
      thanks: Prisma.$ThankYouMessagePayload<ExtArgs>[]
      retargetings: Prisma.$RetargetingPlanPayload<ExtArgs>[]
      extensions: Prisma.$CampaignExtensionPlanPayload<ExtArgs>[]
      analysisReports: Prisma.$CampaignAnalysisReportPayload<ExtArgs>[]
      learnings: Prisma.$CampaignLearningsPayload<ExtArgs>[]
      internalReports: Prisma.$InternalCampaignReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enterpriseContexts<T extends Campaign$enterpriseContextsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$enterpriseContextsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnterpriseContextPayload<ExtArgs>, T, "findMany"> | Null>
    audienceSegments<T extends Campaign$audienceSegmentsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$audienceSegmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudienceSegmentPayload<ExtArgs>, T, "findMany"> | Null>
    creativePlans<T extends Campaign$creativePlansArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$creativePlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "findMany"> | Null>
    objectives<T extends Campaign$objectivesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$objectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "findMany"> | Null>
    audiences<T extends Campaign$audiencesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$audiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "findMany"> | Null>
    competitors<T extends Campaign$competitorsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$competitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitorStrategyPayload<ExtArgs>, T, "findMany"> | Null>
    promotions<T extends Campaign$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "findMany"> | Null>
    offers<T extends Campaign$offersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "findMany"> | Null>
    budgets<T extends Campaign$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends Campaign$channelsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "findMany"> | Null>
    timelines<T extends Campaign$timelinesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$timelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "findMany"> | Null>
    compliances<T extends Campaign$compliancesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$compliancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "findMany"> | Null>
    creatives<T extends Campaign$creativesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$creativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Campaign$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "findMany"> | Null>
    mediaAssets<T extends Campaign$mediaAssetsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$mediaAssetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findMany"> | Null>
    calendars<T extends Campaign$calendarsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$calendarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findMany"> | Null>
    teasers<T extends Campaign$teasersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$teasersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "findMany"> | Null>
    customers<T extends Campaign$customersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "findMany"> | Null>
    influencers<T extends Campaign$influencersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$influencersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "findMany"> | Null>
    checklists<T extends Campaign$checklistsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$checklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "findMany"> | Null>
    activations<T extends Campaign$activationsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$activationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "findMany"> | Null>
    engagements<T extends Campaign$engagementsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$engagementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Campaign$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "findMany"> | Null>
    feedbacks<T extends Campaign$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    thanks<T extends Campaign$thanksArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$thanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "findMany"> | Null>
    retargetings<T extends Campaign$retargetingsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$retargetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "findMany"> | Null>
    extensions<T extends Campaign$extensionsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$extensionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "findMany"> | Null>
    analysisReports<T extends Campaign$analysisReportsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$analysisReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "findMany"> | Null>
    learnings<T extends Campaign$learningsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$learningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "findMany"> | Null>
    internalReports<T extends Campaign$internalReportsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$internalReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly startDate: FieldRef<"Campaign", 'DateTime'>
    readonly endDate: FieldRef<"Campaign", 'DateTime'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.enterpriseContexts
   */
  export type Campaign$enterpriseContextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseContext
     */
    select?: EnterpriseContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnterpriseContextInclude<ExtArgs> | null
    where?: EnterpriseContextWhereInput
    orderBy?: EnterpriseContextOrderByWithRelationInput | EnterpriseContextOrderByWithRelationInput[]
    cursor?: EnterpriseContextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnterpriseContextScalarFieldEnum | EnterpriseContextScalarFieldEnum[]
  }

  /**
   * Campaign.audienceSegments
   */
  export type Campaign$audienceSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceSegment
     */
    select?: AudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceSegmentInclude<ExtArgs> | null
    where?: AudienceSegmentWhereInput
    orderBy?: AudienceSegmentOrderByWithRelationInput | AudienceSegmentOrderByWithRelationInput[]
    cursor?: AudienceSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudienceSegmentScalarFieldEnum | AudienceSegmentScalarFieldEnum[]
  }

  /**
   * Campaign.creativePlans
   */
  export type Campaign$creativePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    where?: CreativeDesignPlanWhereInput
    orderBy?: CreativeDesignPlanOrderByWithRelationInput | CreativeDesignPlanOrderByWithRelationInput[]
    cursor?: CreativeDesignPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreativeDesignPlanScalarFieldEnum | CreativeDesignPlanScalarFieldEnum[]
  }

  /**
   * Campaign.objectives
   */
  export type Campaign$objectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    where?: CampaignObjectiveWhereInput
    orderBy?: CampaignObjectiveOrderByWithRelationInput | CampaignObjectiveOrderByWithRelationInput[]
    cursor?: CampaignObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignObjectiveScalarFieldEnum | CampaignObjectiveScalarFieldEnum[]
  }

  /**
   * Campaign.audiences
   */
  export type Campaign$audiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    where?: TargetAudienceSegmentWhereInput
    orderBy?: TargetAudienceSegmentOrderByWithRelationInput | TargetAudienceSegmentOrderByWithRelationInput[]
    cursor?: TargetAudienceSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TargetAudienceSegmentScalarFieldEnum | TargetAudienceSegmentScalarFieldEnum[]
  }

  /**
   * Campaign.competitors
   */
  export type Campaign$competitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorStrategy
     */
    select?: CompetitorStrategySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetitorStrategyInclude<ExtArgs> | null
    where?: CompetitorStrategyWhereInput
    orderBy?: CompetitorStrategyOrderByWithRelationInput | CompetitorStrategyOrderByWithRelationInput[]
    cursor?: CompetitorStrategyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompetitorStrategyScalarFieldEnum | CompetitorStrategyScalarFieldEnum[]
  }

  /**
   * Campaign.promotions
   */
  export type Campaign$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    where?: PromotionTypeWhereInput
    orderBy?: PromotionTypeOrderByWithRelationInput | PromotionTypeOrderByWithRelationInput[]
    cursor?: PromotionTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionTypeScalarFieldEnum | PromotionTypeScalarFieldEnum[]
  }

  /**
   * Campaign.offers
   */
  export type Campaign$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    where?: CampaignOfferWhereInput
    orderBy?: CampaignOfferOrderByWithRelationInput | CampaignOfferOrderByWithRelationInput[]
    cursor?: CampaignOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignOfferScalarFieldEnum | CampaignOfferScalarFieldEnum[]
  }

  /**
   * Campaign.budgets
   */
  export type Campaign$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    where?: CampaignBudgetWhereInput
    orderBy?: CampaignBudgetOrderByWithRelationInput | CampaignBudgetOrderByWithRelationInput[]
    cursor?: CampaignBudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignBudgetScalarFieldEnum | CampaignBudgetScalarFieldEnum[]
  }

  /**
   * Campaign.channels
   */
  export type Campaign$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    where?: ChannelPlanWhereInput
    orderBy?: ChannelPlanOrderByWithRelationInput | ChannelPlanOrderByWithRelationInput[]
    cursor?: ChannelPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelPlanScalarFieldEnum | ChannelPlanScalarFieldEnum[]
  }

  /**
   * Campaign.timelines
   */
  export type Campaign$timelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    where?: CampaignTimelineWhereInput
    orderBy?: CampaignTimelineOrderByWithRelationInput | CampaignTimelineOrderByWithRelationInput[]
    cursor?: CampaignTimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignTimelineScalarFieldEnum | CampaignTimelineScalarFieldEnum[]
  }

  /**
   * Campaign.compliances
   */
  export type Campaign$compliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    where?: ComplianceChecklistWhereInput
    orderBy?: ComplianceChecklistOrderByWithRelationInput | ComplianceChecklistOrderByWithRelationInput[]
    cursor?: ComplianceChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceChecklistScalarFieldEnum | ComplianceChecklistScalarFieldEnum[]
  }

  /**
   * Campaign.creatives
   */
  export type Campaign$creativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    where?: CreativeAssetWhereInput
    orderBy?: CreativeAssetOrderByWithRelationInput | CreativeAssetOrderByWithRelationInput[]
    cursor?: CreativeAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreativeAssetScalarFieldEnum | CreativeAssetScalarFieldEnum[]
  }

  /**
   * Campaign.messages
   */
  export type Campaign$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    where?: PromotionalMessageWhereInput
    orderBy?: PromotionalMessageOrderByWithRelationInput | PromotionalMessageOrderByWithRelationInput[]
    cursor?: PromotionalMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionalMessageScalarFieldEnum | PromotionalMessageScalarFieldEnum[]
  }

  /**
   * Campaign.mediaAssets
   */
  export type Campaign$mediaAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    where?: MediaAssetWhereInput
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    cursor?: MediaAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * Campaign.calendars
   */
  export type Campaign$calendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    where?: ContentCalendarWhereInput
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    cursor?: ContentCalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentCalendarScalarFieldEnum | ContentCalendarScalarFieldEnum[]
  }

  /**
   * Campaign.teasers
   */
  export type Campaign$teasersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    where?: TeaserContentWhereInput
    orderBy?: TeaserContentOrderByWithRelationInput | TeaserContentOrderByWithRelationInput[]
    cursor?: TeaserContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeaserContentScalarFieldEnum | TeaserContentScalarFieldEnum[]
  }

  /**
   * Campaign.customers
   */
  export type Campaign$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    where?: CustomerSegmentListWhereInput
    orderBy?: CustomerSegmentListOrderByWithRelationInput | CustomerSegmentListOrderByWithRelationInput[]
    cursor?: CustomerSegmentListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerSegmentListScalarFieldEnum | CustomerSegmentListScalarFieldEnum[]
  }

  /**
   * Campaign.influencers
   */
  export type Campaign$influencersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    where?: InfluencerPlanWhereInput
    orderBy?: InfluencerPlanOrderByWithRelationInput | InfluencerPlanOrderByWithRelationInput[]
    cursor?: InfluencerPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfluencerPlanScalarFieldEnum | InfluencerPlanScalarFieldEnum[]
  }

  /**
   * Campaign.checklists
   */
  export type Campaign$checklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    where?: OperationalChecklistWhereInput
    orderBy?: OperationalChecklistOrderByWithRelationInput | OperationalChecklistOrderByWithRelationInput[]
    cursor?: OperationalChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationalChecklistScalarFieldEnum | OperationalChecklistScalarFieldEnum[]
  }

  /**
   * Campaign.activations
   */
  export type Campaign$activationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    where?: CampaignActivationWhereInput
    orderBy?: CampaignActivationOrderByWithRelationInput | CampaignActivationOrderByWithRelationInput[]
    cursor?: CampaignActivationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignActivationScalarFieldEnum | CampaignActivationScalarFieldEnum[]
  }

  /**
   * Campaign.engagements
   */
  export type Campaign$engagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    where?: CustomerEngagementLogWhereInput
    orderBy?: CustomerEngagementLogOrderByWithRelationInput | CustomerEngagementLogOrderByWithRelationInput[]
    cursor?: CustomerEngagementLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerEngagementLogScalarFieldEnum | CustomerEngagementLogScalarFieldEnum[]
  }

  /**
   * Campaign.reports
   */
  export type Campaign$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    where?: PerformanceReportWhereInput
    orderBy?: PerformanceReportOrderByWithRelationInput | PerformanceReportOrderByWithRelationInput[]
    cursor?: PerformanceReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceReportScalarFieldEnum | PerformanceReportScalarFieldEnum[]
  }

  /**
   * Campaign.feedbacks
   */
  export type Campaign$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    where?: CustomerFeedbackWhereInput
    orderBy?: CustomerFeedbackOrderByWithRelationInput | CustomerFeedbackOrderByWithRelationInput[]
    cursor?: CustomerFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerFeedbackScalarFieldEnum | CustomerFeedbackScalarFieldEnum[]
  }

  /**
   * Campaign.thanks
   */
  export type Campaign$thanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    where?: ThankYouMessageWhereInput
    orderBy?: ThankYouMessageOrderByWithRelationInput | ThankYouMessageOrderByWithRelationInput[]
    cursor?: ThankYouMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThankYouMessageScalarFieldEnum | ThankYouMessageScalarFieldEnum[]
  }

  /**
   * Campaign.retargetings
   */
  export type Campaign$retargetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    where?: RetargetingPlanWhereInput
    orderBy?: RetargetingPlanOrderByWithRelationInput | RetargetingPlanOrderByWithRelationInput[]
    cursor?: RetargetingPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RetargetingPlanScalarFieldEnum | RetargetingPlanScalarFieldEnum[]
  }

  /**
   * Campaign.extensions
   */
  export type Campaign$extensionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    where?: CampaignExtensionPlanWhereInput
    orderBy?: CampaignExtensionPlanOrderByWithRelationInput | CampaignExtensionPlanOrderByWithRelationInput[]
    cursor?: CampaignExtensionPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignExtensionPlanScalarFieldEnum | CampaignExtensionPlanScalarFieldEnum[]
  }

  /**
   * Campaign.analysisReports
   */
  export type Campaign$analysisReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    where?: CampaignAnalysisReportWhereInput
    orderBy?: CampaignAnalysisReportOrderByWithRelationInput | CampaignAnalysisReportOrderByWithRelationInput[]
    cursor?: CampaignAnalysisReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignAnalysisReportScalarFieldEnum | CampaignAnalysisReportScalarFieldEnum[]
  }

  /**
   * Campaign.learnings
   */
  export type Campaign$learningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    where?: CampaignLearningsWhereInput
    orderBy?: CampaignLearningsOrderByWithRelationInput | CampaignLearningsOrderByWithRelationInput[]
    cursor?: CampaignLearningsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLearningsScalarFieldEnum | CampaignLearningsScalarFieldEnum[]
  }

  /**
   * Campaign.internalReports
   */
  export type Campaign$internalReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    where?: InternalCampaignReportWhereInput
    orderBy?: InternalCampaignReportOrderByWithRelationInput | InternalCampaignReportOrderByWithRelationInput[]
    cursor?: InternalCampaignReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternalCampaignReportScalarFieldEnum | InternalCampaignReportScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignObjective
   */

  export type AggregateCampaignObjective = {
    _count: CampaignObjectiveCountAggregateOutputType | null
    _min: CampaignObjectiveMinAggregateOutputType | null
    _max: CampaignObjectiveMaxAggregateOutputType | null
  }

  export type CampaignObjectiveMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    goal: string | null
  }

  export type CampaignObjectiveMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    goal: string | null
  }

  export type CampaignObjectiveCountAggregateOutputType = {
    id: number
    campaignId: number
    goal: number
    _all: number
  }


  export type CampaignObjectiveMinAggregateInputType = {
    id?: true
    campaignId?: true
    goal?: true
  }

  export type CampaignObjectiveMaxAggregateInputType = {
    id?: true
    campaignId?: true
    goal?: true
  }

  export type CampaignObjectiveCountAggregateInputType = {
    id?: true
    campaignId?: true
    goal?: true
    _all?: true
  }

  export type CampaignObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignObjective to aggregate.
     */
    where?: CampaignObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignObjectives to fetch.
     */
    orderBy?: CampaignObjectiveOrderByWithRelationInput | CampaignObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignObjectives
    **/
    _count?: true | CampaignObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignObjectiveMaxAggregateInputType
  }

  export type GetCampaignObjectiveAggregateType<T extends CampaignObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignObjective[P]>
      : GetScalarType<T[P], AggregateCampaignObjective[P]>
  }




  export type CampaignObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignObjectiveWhereInput
    orderBy?: CampaignObjectiveOrderByWithAggregationInput | CampaignObjectiveOrderByWithAggregationInput[]
    by: CampaignObjectiveScalarFieldEnum[] | CampaignObjectiveScalarFieldEnum
    having?: CampaignObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignObjectiveCountAggregateInputType | true
    _min?: CampaignObjectiveMinAggregateInputType
    _max?: CampaignObjectiveMaxAggregateInputType
  }

  export type CampaignObjectiveGroupByOutputType = {
    id: string
    campaignId: string
    goal: string
    _count: CampaignObjectiveCountAggregateOutputType | null
    _min: CampaignObjectiveMinAggregateOutputType | null
    _max: CampaignObjectiveMaxAggregateOutputType | null
  }

  type GetCampaignObjectiveGroupByPayload<T extends CampaignObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type CampaignObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    goal?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignObjective"]>

  export type CampaignObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    goal?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignObjective"]>

  export type CampaignObjectiveSelectScalar = {
    id?: boolean
    campaignId?: boolean
    goal?: boolean
  }

  export type CampaignObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignObjective"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      goal: string
    }, ExtArgs["result"]["campaignObjective"]>
    composites: {}
  }

  type CampaignObjectiveGetPayload<S extends boolean | null | undefined | CampaignObjectiveDefaultArgs> = $Result.GetResult<Prisma.$CampaignObjectivePayload, S>

  type CampaignObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignObjectiveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignObjectiveCountAggregateInputType | true
    }

  export interface CampaignObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignObjective'], meta: { name: 'CampaignObjective' } }
    /**
     * Find zero or one CampaignObjective that matches the filter.
     * @param {CampaignObjectiveFindUniqueArgs} args - Arguments to find a CampaignObjective
     * @example
     * // Get one CampaignObjective
     * const campaignObjective = await prisma.campaignObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignObjectiveFindUniqueArgs>(args: SelectSubset<T, CampaignObjectiveFindUniqueArgs<ExtArgs>>): Prisma__CampaignObjectiveClient<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignObjective that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignObjectiveFindUniqueOrThrowArgs} args - Arguments to find a CampaignObjective
     * @example
     * // Get one CampaignObjective
     * const campaignObjective = await prisma.campaignObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignObjectiveClient<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignObjectiveFindFirstArgs} args - Arguments to find a CampaignObjective
     * @example
     * // Get one CampaignObjective
     * const campaignObjective = await prisma.campaignObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignObjectiveFindFirstArgs>(args?: SelectSubset<T, CampaignObjectiveFindFirstArgs<ExtArgs>>): Prisma__CampaignObjectiveClient<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignObjectiveFindFirstOrThrowArgs} args - Arguments to find a CampaignObjective
     * @example
     * // Get one CampaignObjective
     * const campaignObjective = await prisma.campaignObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignObjectiveClient<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignObjectives
     * const campaignObjectives = await prisma.campaignObjective.findMany()
     * 
     * // Get first 10 CampaignObjectives
     * const campaignObjectives = await prisma.campaignObjective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignObjectiveWithIdOnly = await prisma.campaignObjective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignObjectiveFindManyArgs>(args?: SelectSubset<T, CampaignObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignObjective.
     * @param {CampaignObjectiveCreateArgs} args - Arguments to create a CampaignObjective.
     * @example
     * // Create one CampaignObjective
     * const CampaignObjective = await prisma.campaignObjective.create({
     *   data: {
     *     // ... data to create a CampaignObjective
     *   }
     * })
     * 
     */
    create<T extends CampaignObjectiveCreateArgs>(args: SelectSubset<T, CampaignObjectiveCreateArgs<ExtArgs>>): Prisma__CampaignObjectiveClient<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignObjectives.
     * @param {CampaignObjectiveCreateManyArgs} args - Arguments to create many CampaignObjectives.
     * @example
     * // Create many CampaignObjectives
     * const campaignObjective = await prisma.campaignObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignObjectiveCreateManyArgs>(args?: SelectSubset<T, CampaignObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignObjectives and returns the data saved in the database.
     * @param {CampaignObjectiveCreateManyAndReturnArgs} args - Arguments to create many CampaignObjectives.
     * @example
     * // Create many CampaignObjectives
     * const campaignObjective = await prisma.campaignObjective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignObjectives and only return the `id`
     * const campaignObjectiveWithIdOnly = await prisma.campaignObjective.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignObjective.
     * @param {CampaignObjectiveDeleteArgs} args - Arguments to delete one CampaignObjective.
     * @example
     * // Delete one CampaignObjective
     * const CampaignObjective = await prisma.campaignObjective.delete({
     *   where: {
     *     // ... filter to delete one CampaignObjective
     *   }
     * })
     * 
     */
    delete<T extends CampaignObjectiveDeleteArgs>(args: SelectSubset<T, CampaignObjectiveDeleteArgs<ExtArgs>>): Prisma__CampaignObjectiveClient<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignObjective.
     * @param {CampaignObjectiveUpdateArgs} args - Arguments to update one CampaignObjective.
     * @example
     * // Update one CampaignObjective
     * const campaignObjective = await prisma.campaignObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignObjectiveUpdateArgs>(args: SelectSubset<T, CampaignObjectiveUpdateArgs<ExtArgs>>): Prisma__CampaignObjectiveClient<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignObjectives.
     * @param {CampaignObjectiveDeleteManyArgs} args - Arguments to filter CampaignObjectives to delete.
     * @example
     * // Delete a few CampaignObjectives
     * const { count } = await prisma.campaignObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignObjectiveDeleteManyArgs>(args?: SelectSubset<T, CampaignObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignObjectives
     * const campaignObjective = await prisma.campaignObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignObjectiveUpdateManyArgs>(args: SelectSubset<T, CampaignObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignObjective.
     * @param {CampaignObjectiveUpsertArgs} args - Arguments to update or create a CampaignObjective.
     * @example
     * // Update or create a CampaignObjective
     * const campaignObjective = await prisma.campaignObjective.upsert({
     *   create: {
     *     // ... data to create a CampaignObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignObjective we want to update
     *   }
     * })
     */
    upsert<T extends CampaignObjectiveUpsertArgs>(args: SelectSubset<T, CampaignObjectiveUpsertArgs<ExtArgs>>): Prisma__CampaignObjectiveClient<$Result.GetResult<Prisma.$CampaignObjectivePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignObjectiveCountArgs} args - Arguments to filter CampaignObjectives to count.
     * @example
     * // Count the number of CampaignObjectives
     * const count = await prisma.campaignObjective.count({
     *   where: {
     *     // ... the filter for the CampaignObjectives we want to count
     *   }
     * })
    **/
    count<T extends CampaignObjectiveCountArgs>(
      args?: Subset<T, CampaignObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignObjectiveAggregateArgs>(args: Subset<T, CampaignObjectiveAggregateArgs>): Prisma.PrismaPromise<GetCampaignObjectiveAggregateType<T>>

    /**
     * Group by CampaignObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: CampaignObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignObjective model
   */
  readonly fields: CampaignObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignObjective model
   */ 
  interface CampaignObjectiveFieldRefs {
    readonly id: FieldRef<"CampaignObjective", 'String'>
    readonly campaignId: FieldRef<"CampaignObjective", 'String'>
    readonly goal: FieldRef<"CampaignObjective", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CampaignObjective findUnique
   */
  export type CampaignObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CampaignObjective to fetch.
     */
    where: CampaignObjectiveWhereUniqueInput
  }

  /**
   * CampaignObjective findUniqueOrThrow
   */
  export type CampaignObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CampaignObjective to fetch.
     */
    where: CampaignObjectiveWhereUniqueInput
  }

  /**
   * CampaignObjective findFirst
   */
  export type CampaignObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CampaignObjective to fetch.
     */
    where?: CampaignObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignObjectives to fetch.
     */
    orderBy?: CampaignObjectiveOrderByWithRelationInput | CampaignObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignObjectives.
     */
    cursor?: CampaignObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignObjectives.
     */
    distinct?: CampaignObjectiveScalarFieldEnum | CampaignObjectiveScalarFieldEnum[]
  }

  /**
   * CampaignObjective findFirstOrThrow
   */
  export type CampaignObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CampaignObjective to fetch.
     */
    where?: CampaignObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignObjectives to fetch.
     */
    orderBy?: CampaignObjectiveOrderByWithRelationInput | CampaignObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignObjectives.
     */
    cursor?: CampaignObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignObjectives.
     */
    distinct?: CampaignObjectiveScalarFieldEnum | CampaignObjectiveScalarFieldEnum[]
  }

  /**
   * CampaignObjective findMany
   */
  export type CampaignObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which CampaignObjectives to fetch.
     */
    where?: CampaignObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignObjectives to fetch.
     */
    orderBy?: CampaignObjectiveOrderByWithRelationInput | CampaignObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignObjectives.
     */
    cursor?: CampaignObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignObjectives.
     */
    skip?: number
    distinct?: CampaignObjectiveScalarFieldEnum | CampaignObjectiveScalarFieldEnum[]
  }

  /**
   * CampaignObjective create
   */
  export type CampaignObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignObjective.
     */
    data: XOR<CampaignObjectiveCreateInput, CampaignObjectiveUncheckedCreateInput>
  }

  /**
   * CampaignObjective createMany
   */
  export type CampaignObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignObjectives.
     */
    data: CampaignObjectiveCreateManyInput | CampaignObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignObjective createManyAndReturn
   */
  export type CampaignObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignObjectives.
     */
    data: CampaignObjectiveCreateManyInput | CampaignObjectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignObjective update
   */
  export type CampaignObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignObjective.
     */
    data: XOR<CampaignObjectiveUpdateInput, CampaignObjectiveUncheckedUpdateInput>
    /**
     * Choose, which CampaignObjective to update.
     */
    where: CampaignObjectiveWhereUniqueInput
  }

  /**
   * CampaignObjective updateMany
   */
  export type CampaignObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignObjectives.
     */
    data: XOR<CampaignObjectiveUpdateManyMutationInput, CampaignObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which CampaignObjectives to update
     */
    where?: CampaignObjectiveWhereInput
  }

  /**
   * CampaignObjective upsert
   */
  export type CampaignObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignObjective to update in case it exists.
     */
    where: CampaignObjectiveWhereUniqueInput
    /**
     * In case the CampaignObjective found by the `where` argument doesn't exist, create a new CampaignObjective with this data.
     */
    create: XOR<CampaignObjectiveCreateInput, CampaignObjectiveUncheckedCreateInput>
    /**
     * In case the CampaignObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignObjectiveUpdateInput, CampaignObjectiveUncheckedUpdateInput>
  }

  /**
   * CampaignObjective delete
   */
  export type CampaignObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
    /**
     * Filter which CampaignObjective to delete.
     */
    where: CampaignObjectiveWhereUniqueInput
  }

  /**
   * CampaignObjective deleteMany
   */
  export type CampaignObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignObjectives to delete
     */
    where?: CampaignObjectiveWhereInput
  }

  /**
   * CampaignObjective without action
   */
  export type CampaignObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignObjective
     */
    select?: CampaignObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model TargetAudienceSegment
   */

  export type AggregateTargetAudienceSegment = {
    _count: TargetAudienceSegmentCountAggregateOutputType | null
    _min: TargetAudienceSegmentMinAggregateOutputType | null
    _max: TargetAudienceSegmentMaxAggregateOutputType | null
  }

  export type TargetAudienceSegmentMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    segment: string | null
  }

  export type TargetAudienceSegmentMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    segment: string | null
  }

  export type TargetAudienceSegmentCountAggregateOutputType = {
    id: number
    campaignId: number
    segment: number
    _all: number
  }


  export type TargetAudienceSegmentMinAggregateInputType = {
    id?: true
    campaignId?: true
    segment?: true
  }

  export type TargetAudienceSegmentMaxAggregateInputType = {
    id?: true
    campaignId?: true
    segment?: true
  }

  export type TargetAudienceSegmentCountAggregateInputType = {
    id?: true
    campaignId?: true
    segment?: true
    _all?: true
  }

  export type TargetAudienceSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TargetAudienceSegment to aggregate.
     */
    where?: TargetAudienceSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetAudienceSegments to fetch.
     */
    orderBy?: TargetAudienceSegmentOrderByWithRelationInput | TargetAudienceSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TargetAudienceSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetAudienceSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetAudienceSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TargetAudienceSegments
    **/
    _count?: true | TargetAudienceSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TargetAudienceSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TargetAudienceSegmentMaxAggregateInputType
  }

  export type GetTargetAudienceSegmentAggregateType<T extends TargetAudienceSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTargetAudienceSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTargetAudienceSegment[P]>
      : GetScalarType<T[P], AggregateTargetAudienceSegment[P]>
  }




  export type TargetAudienceSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetAudienceSegmentWhereInput
    orderBy?: TargetAudienceSegmentOrderByWithAggregationInput | TargetAudienceSegmentOrderByWithAggregationInput[]
    by: TargetAudienceSegmentScalarFieldEnum[] | TargetAudienceSegmentScalarFieldEnum
    having?: TargetAudienceSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TargetAudienceSegmentCountAggregateInputType | true
    _min?: TargetAudienceSegmentMinAggregateInputType
    _max?: TargetAudienceSegmentMaxAggregateInputType
  }

  export type TargetAudienceSegmentGroupByOutputType = {
    id: string
    campaignId: string
    segment: string
    _count: TargetAudienceSegmentCountAggregateOutputType | null
    _min: TargetAudienceSegmentMinAggregateOutputType | null
    _max: TargetAudienceSegmentMaxAggregateOutputType | null
  }

  type GetTargetAudienceSegmentGroupByPayload<T extends TargetAudienceSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TargetAudienceSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TargetAudienceSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TargetAudienceSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], TargetAudienceSegmentGroupByOutputType[P]>
        }
      >
    >


  export type TargetAudienceSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    segment?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["targetAudienceSegment"]>

  export type TargetAudienceSegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    segment?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["targetAudienceSegment"]>

  export type TargetAudienceSegmentSelectScalar = {
    id?: boolean
    campaignId?: boolean
    segment?: boolean
  }

  export type TargetAudienceSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type TargetAudienceSegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $TargetAudienceSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TargetAudienceSegment"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      segment: string
    }, ExtArgs["result"]["targetAudienceSegment"]>
    composites: {}
  }

  type TargetAudienceSegmentGetPayload<S extends boolean | null | undefined | TargetAudienceSegmentDefaultArgs> = $Result.GetResult<Prisma.$TargetAudienceSegmentPayload, S>

  type TargetAudienceSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TargetAudienceSegmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TargetAudienceSegmentCountAggregateInputType | true
    }

  export interface TargetAudienceSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TargetAudienceSegment'], meta: { name: 'TargetAudienceSegment' } }
    /**
     * Find zero or one TargetAudienceSegment that matches the filter.
     * @param {TargetAudienceSegmentFindUniqueArgs} args - Arguments to find a TargetAudienceSegment
     * @example
     * // Get one TargetAudienceSegment
     * const targetAudienceSegment = await prisma.targetAudienceSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TargetAudienceSegmentFindUniqueArgs>(args: SelectSubset<T, TargetAudienceSegmentFindUniqueArgs<ExtArgs>>): Prisma__TargetAudienceSegmentClient<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TargetAudienceSegment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TargetAudienceSegmentFindUniqueOrThrowArgs} args - Arguments to find a TargetAudienceSegment
     * @example
     * // Get one TargetAudienceSegment
     * const targetAudienceSegment = await prisma.targetAudienceSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TargetAudienceSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TargetAudienceSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TargetAudienceSegmentClient<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TargetAudienceSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetAudienceSegmentFindFirstArgs} args - Arguments to find a TargetAudienceSegment
     * @example
     * // Get one TargetAudienceSegment
     * const targetAudienceSegment = await prisma.targetAudienceSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TargetAudienceSegmentFindFirstArgs>(args?: SelectSubset<T, TargetAudienceSegmentFindFirstArgs<ExtArgs>>): Prisma__TargetAudienceSegmentClient<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TargetAudienceSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetAudienceSegmentFindFirstOrThrowArgs} args - Arguments to find a TargetAudienceSegment
     * @example
     * // Get one TargetAudienceSegment
     * const targetAudienceSegment = await prisma.targetAudienceSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TargetAudienceSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TargetAudienceSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TargetAudienceSegmentClient<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TargetAudienceSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetAudienceSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TargetAudienceSegments
     * const targetAudienceSegments = await prisma.targetAudienceSegment.findMany()
     * 
     * // Get first 10 TargetAudienceSegments
     * const targetAudienceSegments = await prisma.targetAudienceSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const targetAudienceSegmentWithIdOnly = await prisma.targetAudienceSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TargetAudienceSegmentFindManyArgs>(args?: SelectSubset<T, TargetAudienceSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TargetAudienceSegment.
     * @param {TargetAudienceSegmentCreateArgs} args - Arguments to create a TargetAudienceSegment.
     * @example
     * // Create one TargetAudienceSegment
     * const TargetAudienceSegment = await prisma.targetAudienceSegment.create({
     *   data: {
     *     // ... data to create a TargetAudienceSegment
     *   }
     * })
     * 
     */
    create<T extends TargetAudienceSegmentCreateArgs>(args: SelectSubset<T, TargetAudienceSegmentCreateArgs<ExtArgs>>): Prisma__TargetAudienceSegmentClient<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TargetAudienceSegments.
     * @param {TargetAudienceSegmentCreateManyArgs} args - Arguments to create many TargetAudienceSegments.
     * @example
     * // Create many TargetAudienceSegments
     * const targetAudienceSegment = await prisma.targetAudienceSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TargetAudienceSegmentCreateManyArgs>(args?: SelectSubset<T, TargetAudienceSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TargetAudienceSegments and returns the data saved in the database.
     * @param {TargetAudienceSegmentCreateManyAndReturnArgs} args - Arguments to create many TargetAudienceSegments.
     * @example
     * // Create many TargetAudienceSegments
     * const targetAudienceSegment = await prisma.targetAudienceSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TargetAudienceSegments and only return the `id`
     * const targetAudienceSegmentWithIdOnly = await prisma.targetAudienceSegment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TargetAudienceSegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TargetAudienceSegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TargetAudienceSegment.
     * @param {TargetAudienceSegmentDeleteArgs} args - Arguments to delete one TargetAudienceSegment.
     * @example
     * // Delete one TargetAudienceSegment
     * const TargetAudienceSegment = await prisma.targetAudienceSegment.delete({
     *   where: {
     *     // ... filter to delete one TargetAudienceSegment
     *   }
     * })
     * 
     */
    delete<T extends TargetAudienceSegmentDeleteArgs>(args: SelectSubset<T, TargetAudienceSegmentDeleteArgs<ExtArgs>>): Prisma__TargetAudienceSegmentClient<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TargetAudienceSegment.
     * @param {TargetAudienceSegmentUpdateArgs} args - Arguments to update one TargetAudienceSegment.
     * @example
     * // Update one TargetAudienceSegment
     * const targetAudienceSegment = await prisma.targetAudienceSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TargetAudienceSegmentUpdateArgs>(args: SelectSubset<T, TargetAudienceSegmentUpdateArgs<ExtArgs>>): Prisma__TargetAudienceSegmentClient<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TargetAudienceSegments.
     * @param {TargetAudienceSegmentDeleteManyArgs} args - Arguments to filter TargetAudienceSegments to delete.
     * @example
     * // Delete a few TargetAudienceSegments
     * const { count } = await prisma.targetAudienceSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TargetAudienceSegmentDeleteManyArgs>(args?: SelectSubset<T, TargetAudienceSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TargetAudienceSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetAudienceSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TargetAudienceSegments
     * const targetAudienceSegment = await prisma.targetAudienceSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TargetAudienceSegmentUpdateManyArgs>(args: SelectSubset<T, TargetAudienceSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TargetAudienceSegment.
     * @param {TargetAudienceSegmentUpsertArgs} args - Arguments to update or create a TargetAudienceSegment.
     * @example
     * // Update or create a TargetAudienceSegment
     * const targetAudienceSegment = await prisma.targetAudienceSegment.upsert({
     *   create: {
     *     // ... data to create a TargetAudienceSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TargetAudienceSegment we want to update
     *   }
     * })
     */
    upsert<T extends TargetAudienceSegmentUpsertArgs>(args: SelectSubset<T, TargetAudienceSegmentUpsertArgs<ExtArgs>>): Prisma__TargetAudienceSegmentClient<$Result.GetResult<Prisma.$TargetAudienceSegmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TargetAudienceSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetAudienceSegmentCountArgs} args - Arguments to filter TargetAudienceSegments to count.
     * @example
     * // Count the number of TargetAudienceSegments
     * const count = await prisma.targetAudienceSegment.count({
     *   where: {
     *     // ... the filter for the TargetAudienceSegments we want to count
     *   }
     * })
    **/
    count<T extends TargetAudienceSegmentCountArgs>(
      args?: Subset<T, TargetAudienceSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TargetAudienceSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TargetAudienceSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetAudienceSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TargetAudienceSegmentAggregateArgs>(args: Subset<T, TargetAudienceSegmentAggregateArgs>): Prisma.PrismaPromise<GetTargetAudienceSegmentAggregateType<T>>

    /**
     * Group by TargetAudienceSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetAudienceSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TargetAudienceSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TargetAudienceSegmentGroupByArgs['orderBy'] }
        : { orderBy?: TargetAudienceSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TargetAudienceSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTargetAudienceSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TargetAudienceSegment model
   */
  readonly fields: TargetAudienceSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TargetAudienceSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TargetAudienceSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TargetAudienceSegment model
   */ 
  interface TargetAudienceSegmentFieldRefs {
    readonly id: FieldRef<"TargetAudienceSegment", 'String'>
    readonly campaignId: FieldRef<"TargetAudienceSegment", 'String'>
    readonly segment: FieldRef<"TargetAudienceSegment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TargetAudienceSegment findUnique
   */
  export type TargetAudienceSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TargetAudienceSegment to fetch.
     */
    where: TargetAudienceSegmentWhereUniqueInput
  }

  /**
   * TargetAudienceSegment findUniqueOrThrow
   */
  export type TargetAudienceSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TargetAudienceSegment to fetch.
     */
    where: TargetAudienceSegmentWhereUniqueInput
  }

  /**
   * TargetAudienceSegment findFirst
   */
  export type TargetAudienceSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TargetAudienceSegment to fetch.
     */
    where?: TargetAudienceSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetAudienceSegments to fetch.
     */
    orderBy?: TargetAudienceSegmentOrderByWithRelationInput | TargetAudienceSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TargetAudienceSegments.
     */
    cursor?: TargetAudienceSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetAudienceSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetAudienceSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TargetAudienceSegments.
     */
    distinct?: TargetAudienceSegmentScalarFieldEnum | TargetAudienceSegmentScalarFieldEnum[]
  }

  /**
   * TargetAudienceSegment findFirstOrThrow
   */
  export type TargetAudienceSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TargetAudienceSegment to fetch.
     */
    where?: TargetAudienceSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetAudienceSegments to fetch.
     */
    orderBy?: TargetAudienceSegmentOrderByWithRelationInput | TargetAudienceSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TargetAudienceSegments.
     */
    cursor?: TargetAudienceSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetAudienceSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetAudienceSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TargetAudienceSegments.
     */
    distinct?: TargetAudienceSegmentScalarFieldEnum | TargetAudienceSegmentScalarFieldEnum[]
  }

  /**
   * TargetAudienceSegment findMany
   */
  export type TargetAudienceSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter, which TargetAudienceSegments to fetch.
     */
    where?: TargetAudienceSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetAudienceSegments to fetch.
     */
    orderBy?: TargetAudienceSegmentOrderByWithRelationInput | TargetAudienceSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TargetAudienceSegments.
     */
    cursor?: TargetAudienceSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetAudienceSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetAudienceSegments.
     */
    skip?: number
    distinct?: TargetAudienceSegmentScalarFieldEnum | TargetAudienceSegmentScalarFieldEnum[]
  }

  /**
   * TargetAudienceSegment create
   */
  export type TargetAudienceSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TargetAudienceSegment.
     */
    data: XOR<TargetAudienceSegmentCreateInput, TargetAudienceSegmentUncheckedCreateInput>
  }

  /**
   * TargetAudienceSegment createMany
   */
  export type TargetAudienceSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TargetAudienceSegments.
     */
    data: TargetAudienceSegmentCreateManyInput | TargetAudienceSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TargetAudienceSegment createManyAndReturn
   */
  export type TargetAudienceSegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TargetAudienceSegments.
     */
    data: TargetAudienceSegmentCreateManyInput | TargetAudienceSegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TargetAudienceSegment update
   */
  export type TargetAudienceSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TargetAudienceSegment.
     */
    data: XOR<TargetAudienceSegmentUpdateInput, TargetAudienceSegmentUncheckedUpdateInput>
    /**
     * Choose, which TargetAudienceSegment to update.
     */
    where: TargetAudienceSegmentWhereUniqueInput
  }

  /**
   * TargetAudienceSegment updateMany
   */
  export type TargetAudienceSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TargetAudienceSegments.
     */
    data: XOR<TargetAudienceSegmentUpdateManyMutationInput, TargetAudienceSegmentUncheckedUpdateManyInput>
    /**
     * Filter which TargetAudienceSegments to update
     */
    where?: TargetAudienceSegmentWhereInput
  }

  /**
   * TargetAudienceSegment upsert
   */
  export type TargetAudienceSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TargetAudienceSegment to update in case it exists.
     */
    where: TargetAudienceSegmentWhereUniqueInput
    /**
     * In case the TargetAudienceSegment found by the `where` argument doesn't exist, create a new TargetAudienceSegment with this data.
     */
    create: XOR<TargetAudienceSegmentCreateInput, TargetAudienceSegmentUncheckedCreateInput>
    /**
     * In case the TargetAudienceSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TargetAudienceSegmentUpdateInput, TargetAudienceSegmentUncheckedUpdateInput>
  }

  /**
   * TargetAudienceSegment delete
   */
  export type TargetAudienceSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
    /**
     * Filter which TargetAudienceSegment to delete.
     */
    where: TargetAudienceSegmentWhereUniqueInput
  }

  /**
   * TargetAudienceSegment deleteMany
   */
  export type TargetAudienceSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TargetAudienceSegments to delete
     */
    where?: TargetAudienceSegmentWhereInput
  }

  /**
   * TargetAudienceSegment without action
   */
  export type TargetAudienceSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetAudienceSegment
     */
    select?: TargetAudienceSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TargetAudienceSegmentInclude<ExtArgs> | null
  }


  /**
   * Model PromotionType
   */

  export type AggregatePromotionType = {
    _count: PromotionTypeCountAggregateOutputType | null
    _min: PromotionTypeMinAggregateOutputType | null
    _max: PromotionTypeMaxAggregateOutputType | null
  }

  export type PromotionTypeMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
  }

  export type PromotionTypeMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
  }

  export type PromotionTypeCountAggregateOutputType = {
    id: number
    campaignId: number
    type: number
    _all: number
  }


  export type PromotionTypeMinAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
  }

  export type PromotionTypeMaxAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
  }

  export type PromotionTypeCountAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    _all?: true
  }

  export type PromotionTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionType to aggregate.
     */
    where?: PromotionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionTypes to fetch.
     */
    orderBy?: PromotionTypeOrderByWithRelationInput | PromotionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionTypes
    **/
    _count?: true | PromotionTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionTypeMaxAggregateInputType
  }

  export type GetPromotionTypeAggregateType<T extends PromotionTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionType[P]>
      : GetScalarType<T[P], AggregatePromotionType[P]>
  }




  export type PromotionTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionTypeWhereInput
    orderBy?: PromotionTypeOrderByWithAggregationInput | PromotionTypeOrderByWithAggregationInput[]
    by: PromotionTypeScalarFieldEnum[] | PromotionTypeScalarFieldEnum
    having?: PromotionTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionTypeCountAggregateInputType | true
    _min?: PromotionTypeMinAggregateInputType
    _max?: PromotionTypeMaxAggregateInputType
  }

  export type PromotionTypeGroupByOutputType = {
    id: string
    campaignId: string
    type: string
    _count: PromotionTypeCountAggregateOutputType | null
    _min: PromotionTypeMinAggregateOutputType | null
    _max: PromotionTypeMaxAggregateOutputType | null
  }

  type GetPromotionTypeGroupByPayload<T extends PromotionTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionTypeGroupByOutputType[P]>
        }
      >
    >


  export type PromotionTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionType"]>

  export type PromotionTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionType"]>

  export type PromotionTypeSelectScalar = {
    id?: boolean
    campaignId?: boolean
    type?: boolean
  }

  export type PromotionTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type PromotionTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $PromotionTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionType"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      type: string
    }, ExtArgs["result"]["promotionType"]>
    composites: {}
  }

  type PromotionTypeGetPayload<S extends boolean | null | undefined | PromotionTypeDefaultArgs> = $Result.GetResult<Prisma.$PromotionTypePayload, S>

  type PromotionTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromotionTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromotionTypeCountAggregateInputType | true
    }

  export interface PromotionTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionType'], meta: { name: 'PromotionType' } }
    /**
     * Find zero or one PromotionType that matches the filter.
     * @param {PromotionTypeFindUniqueArgs} args - Arguments to find a PromotionType
     * @example
     * // Get one PromotionType
     * const promotionType = await prisma.promotionType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionTypeFindUniqueArgs>(args: SelectSubset<T, PromotionTypeFindUniqueArgs<ExtArgs>>): Prisma__PromotionTypeClient<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PromotionType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromotionTypeFindUniqueOrThrowArgs} args - Arguments to find a PromotionType
     * @example
     * // Get one PromotionType
     * const promotionType = await prisma.promotionType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionTypeClient<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PromotionType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTypeFindFirstArgs} args - Arguments to find a PromotionType
     * @example
     * // Get one PromotionType
     * const promotionType = await prisma.promotionType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionTypeFindFirstArgs>(args?: SelectSubset<T, PromotionTypeFindFirstArgs<ExtArgs>>): Prisma__PromotionTypeClient<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PromotionType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTypeFindFirstOrThrowArgs} args - Arguments to find a PromotionType
     * @example
     * // Get one PromotionType
     * const promotionType = await prisma.promotionType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionTypeClient<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PromotionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionTypes
     * const promotionTypes = await prisma.promotionType.findMany()
     * 
     * // Get first 10 PromotionTypes
     * const promotionTypes = await prisma.promotionType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionTypeWithIdOnly = await prisma.promotionType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionTypeFindManyArgs>(args?: SelectSubset<T, PromotionTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PromotionType.
     * @param {PromotionTypeCreateArgs} args - Arguments to create a PromotionType.
     * @example
     * // Create one PromotionType
     * const PromotionType = await prisma.promotionType.create({
     *   data: {
     *     // ... data to create a PromotionType
     *   }
     * })
     * 
     */
    create<T extends PromotionTypeCreateArgs>(args: SelectSubset<T, PromotionTypeCreateArgs<ExtArgs>>): Prisma__PromotionTypeClient<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PromotionTypes.
     * @param {PromotionTypeCreateManyArgs} args - Arguments to create many PromotionTypes.
     * @example
     * // Create many PromotionTypes
     * const promotionType = await prisma.promotionType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionTypeCreateManyArgs>(args?: SelectSubset<T, PromotionTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromotionTypes and returns the data saved in the database.
     * @param {PromotionTypeCreateManyAndReturnArgs} args - Arguments to create many PromotionTypes.
     * @example
     * // Create many PromotionTypes
     * const promotionType = await prisma.promotionType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromotionTypes and only return the `id`
     * const promotionTypeWithIdOnly = await prisma.promotionType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PromotionType.
     * @param {PromotionTypeDeleteArgs} args - Arguments to delete one PromotionType.
     * @example
     * // Delete one PromotionType
     * const PromotionType = await prisma.promotionType.delete({
     *   where: {
     *     // ... filter to delete one PromotionType
     *   }
     * })
     * 
     */
    delete<T extends PromotionTypeDeleteArgs>(args: SelectSubset<T, PromotionTypeDeleteArgs<ExtArgs>>): Prisma__PromotionTypeClient<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PromotionType.
     * @param {PromotionTypeUpdateArgs} args - Arguments to update one PromotionType.
     * @example
     * // Update one PromotionType
     * const promotionType = await prisma.promotionType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionTypeUpdateArgs>(args: SelectSubset<T, PromotionTypeUpdateArgs<ExtArgs>>): Prisma__PromotionTypeClient<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PromotionTypes.
     * @param {PromotionTypeDeleteManyArgs} args - Arguments to filter PromotionTypes to delete.
     * @example
     * // Delete a few PromotionTypes
     * const { count } = await prisma.promotionType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionTypeDeleteManyArgs>(args?: SelectSubset<T, PromotionTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionTypes
     * const promotionType = await prisma.promotionType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionTypeUpdateManyArgs>(args: SelectSubset<T, PromotionTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromotionType.
     * @param {PromotionTypeUpsertArgs} args - Arguments to update or create a PromotionType.
     * @example
     * // Update or create a PromotionType
     * const promotionType = await prisma.promotionType.upsert({
     *   create: {
     *     // ... data to create a PromotionType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionType we want to update
     *   }
     * })
     */
    upsert<T extends PromotionTypeUpsertArgs>(args: SelectSubset<T, PromotionTypeUpsertArgs<ExtArgs>>): Prisma__PromotionTypeClient<$Result.GetResult<Prisma.$PromotionTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PromotionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTypeCountArgs} args - Arguments to filter PromotionTypes to count.
     * @example
     * // Count the number of PromotionTypes
     * const count = await prisma.promotionType.count({
     *   where: {
     *     // ... the filter for the PromotionTypes we want to count
     *   }
     * })
    **/
    count<T extends PromotionTypeCountArgs>(
      args?: Subset<T, PromotionTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionTypeAggregateArgs>(args: Subset<T, PromotionTypeAggregateArgs>): Prisma.PrismaPromise<GetPromotionTypeAggregateType<T>>

    /**
     * Group by PromotionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionTypeGroupByArgs['orderBy'] }
        : { orderBy?: PromotionTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionType model
   */
  readonly fields: PromotionTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromotionType model
   */ 
  interface PromotionTypeFieldRefs {
    readonly id: FieldRef<"PromotionType", 'String'>
    readonly campaignId: FieldRef<"PromotionType", 'String'>
    readonly type: FieldRef<"PromotionType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PromotionType findUnique
   */
  export type PromotionTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionType to fetch.
     */
    where: PromotionTypeWhereUniqueInput
  }

  /**
   * PromotionType findUniqueOrThrow
   */
  export type PromotionTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionType to fetch.
     */
    where: PromotionTypeWhereUniqueInput
  }

  /**
   * PromotionType findFirst
   */
  export type PromotionTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionType to fetch.
     */
    where?: PromotionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionTypes to fetch.
     */
    orderBy?: PromotionTypeOrderByWithRelationInput | PromotionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionTypes.
     */
    cursor?: PromotionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionTypes.
     */
    distinct?: PromotionTypeScalarFieldEnum | PromotionTypeScalarFieldEnum[]
  }

  /**
   * PromotionType findFirstOrThrow
   */
  export type PromotionTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionType to fetch.
     */
    where?: PromotionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionTypes to fetch.
     */
    orderBy?: PromotionTypeOrderByWithRelationInput | PromotionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionTypes.
     */
    cursor?: PromotionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionTypes.
     */
    distinct?: PromotionTypeScalarFieldEnum | PromotionTypeScalarFieldEnum[]
  }

  /**
   * PromotionType findMany
   */
  export type PromotionTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionTypes to fetch.
     */
    where?: PromotionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionTypes to fetch.
     */
    orderBy?: PromotionTypeOrderByWithRelationInput | PromotionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionTypes.
     */
    cursor?: PromotionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionTypes.
     */
    skip?: number
    distinct?: PromotionTypeScalarFieldEnum | PromotionTypeScalarFieldEnum[]
  }

  /**
   * PromotionType create
   */
  export type PromotionTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionType.
     */
    data: XOR<PromotionTypeCreateInput, PromotionTypeUncheckedCreateInput>
  }

  /**
   * PromotionType createMany
   */
  export type PromotionTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionTypes.
     */
    data: PromotionTypeCreateManyInput | PromotionTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromotionType createManyAndReturn
   */
  export type PromotionTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PromotionTypes.
     */
    data: PromotionTypeCreateManyInput | PromotionTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionType update
   */
  export type PromotionTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionType.
     */
    data: XOR<PromotionTypeUpdateInput, PromotionTypeUncheckedUpdateInput>
    /**
     * Choose, which PromotionType to update.
     */
    where: PromotionTypeWhereUniqueInput
  }

  /**
   * PromotionType updateMany
   */
  export type PromotionTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionTypes.
     */
    data: XOR<PromotionTypeUpdateManyMutationInput, PromotionTypeUncheckedUpdateManyInput>
    /**
     * Filter which PromotionTypes to update
     */
    where?: PromotionTypeWhereInput
  }

  /**
   * PromotionType upsert
   */
  export type PromotionTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionType to update in case it exists.
     */
    where: PromotionTypeWhereUniqueInput
    /**
     * In case the PromotionType found by the `where` argument doesn't exist, create a new PromotionType with this data.
     */
    create: XOR<PromotionTypeCreateInput, PromotionTypeUncheckedCreateInput>
    /**
     * In case the PromotionType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionTypeUpdateInput, PromotionTypeUncheckedUpdateInput>
  }

  /**
   * PromotionType delete
   */
  export type PromotionTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
    /**
     * Filter which PromotionType to delete.
     */
    where: PromotionTypeWhereUniqueInput
  }

  /**
   * PromotionType deleteMany
   */
  export type PromotionTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionTypes to delete
     */
    where?: PromotionTypeWhereInput
  }

  /**
   * PromotionType without action
   */
  export type PromotionTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionType
     */
    select?: PromotionTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionTypeInclude<ExtArgs> | null
  }


  /**
   * Model CampaignOffer
   */

  export type AggregateCampaignOffer = {
    _count: CampaignOfferCountAggregateOutputType | null
    _avg: CampaignOfferAvgAggregateOutputType | null
    _sum: CampaignOfferSumAggregateOutputType | null
    _min: CampaignOfferMinAggregateOutputType | null
    _max: CampaignOfferMaxAggregateOutputType | null
  }

  export type CampaignOfferAvgAggregateOutputType = {
    offerLimit: number | null
  }

  export type CampaignOfferSumAggregateOutputType = {
    offerLimit: number | null
  }

  export type CampaignOfferMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    description: string | null
    offerLimit: number | null
    offerType: string | null
    successCriteria: string | null
    backupOffer: string | null
    createdAt: Date | null
  }

  export type CampaignOfferMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    description: string | null
    offerLimit: number | null
    offerType: string | null
    successCriteria: string | null
    backupOffer: string | null
    createdAt: Date | null
  }

  export type CampaignOfferCountAggregateOutputType = {
    id: number
    campaignId: number
    description: number
    offerLimit: number
    offerType: number
    successCriteria: number
    backupOffer: number
    createdAt: number
    _all: number
  }


  export type CampaignOfferAvgAggregateInputType = {
    offerLimit?: true
  }

  export type CampaignOfferSumAggregateInputType = {
    offerLimit?: true
  }

  export type CampaignOfferMinAggregateInputType = {
    id?: true
    campaignId?: true
    description?: true
    offerLimit?: true
    offerType?: true
    successCriteria?: true
    backupOffer?: true
    createdAt?: true
  }

  export type CampaignOfferMaxAggregateInputType = {
    id?: true
    campaignId?: true
    description?: true
    offerLimit?: true
    offerType?: true
    successCriteria?: true
    backupOffer?: true
    createdAt?: true
  }

  export type CampaignOfferCountAggregateInputType = {
    id?: true
    campaignId?: true
    description?: true
    offerLimit?: true
    offerType?: true
    successCriteria?: true
    backupOffer?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignOffer to aggregate.
     */
    where?: CampaignOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignOffers to fetch.
     */
    orderBy?: CampaignOfferOrderByWithRelationInput | CampaignOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignOffers
    **/
    _count?: true | CampaignOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignOfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignOfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignOfferMaxAggregateInputType
  }

  export type GetCampaignOfferAggregateType<T extends CampaignOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignOffer[P]>
      : GetScalarType<T[P], AggregateCampaignOffer[P]>
  }




  export type CampaignOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignOfferWhereInput
    orderBy?: CampaignOfferOrderByWithAggregationInput | CampaignOfferOrderByWithAggregationInput[]
    by: CampaignOfferScalarFieldEnum[] | CampaignOfferScalarFieldEnum
    having?: CampaignOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignOfferCountAggregateInputType | true
    _avg?: CampaignOfferAvgAggregateInputType
    _sum?: CampaignOfferSumAggregateInputType
    _min?: CampaignOfferMinAggregateInputType
    _max?: CampaignOfferMaxAggregateInputType
  }

  export type CampaignOfferGroupByOutputType = {
    id: string
    campaignId: string
    description: string
    offerLimit: number | null
    offerType: string | null
    successCriteria: string | null
    backupOffer: string | null
    createdAt: Date
    _count: CampaignOfferCountAggregateOutputType | null
    _avg: CampaignOfferAvgAggregateOutputType | null
    _sum: CampaignOfferSumAggregateOutputType | null
    _min: CampaignOfferMinAggregateOutputType | null
    _max: CampaignOfferMaxAggregateOutputType | null
  }

  type GetCampaignOfferGroupByPayload<T extends CampaignOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignOfferGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignOfferGroupByOutputType[P]>
        }
      >
    >


  export type CampaignOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    description?: boolean
    offerLimit?: boolean
    offerType?: boolean
    successCriteria?: boolean
    backupOffer?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignOffer"]>

  export type CampaignOfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    description?: boolean
    offerLimit?: boolean
    offerType?: boolean
    successCriteria?: boolean
    backupOffer?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignOffer"]>

  export type CampaignOfferSelectScalar = {
    id?: boolean
    campaignId?: boolean
    description?: boolean
    offerLimit?: boolean
    offerType?: boolean
    successCriteria?: boolean
    backupOffer?: boolean
    createdAt?: boolean
  }

  export type CampaignOfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignOfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignOffer"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      description: string
      offerLimit: number | null
      offerType: string | null
      successCriteria: string | null
      backupOffer: string | null
      createdAt: Date
    }, ExtArgs["result"]["campaignOffer"]>
    composites: {}
  }

  type CampaignOfferGetPayload<S extends boolean | null | undefined | CampaignOfferDefaultArgs> = $Result.GetResult<Prisma.$CampaignOfferPayload, S>

  type CampaignOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignOfferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignOfferCountAggregateInputType | true
    }

  export interface CampaignOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignOffer'], meta: { name: 'CampaignOffer' } }
    /**
     * Find zero or one CampaignOffer that matches the filter.
     * @param {CampaignOfferFindUniqueArgs} args - Arguments to find a CampaignOffer
     * @example
     * // Get one CampaignOffer
     * const campaignOffer = await prisma.campaignOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignOfferFindUniqueArgs>(args: SelectSubset<T, CampaignOfferFindUniqueArgs<ExtArgs>>): Prisma__CampaignOfferClient<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignOffer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignOfferFindUniqueOrThrowArgs} args - Arguments to find a CampaignOffer
     * @example
     * // Get one CampaignOffer
     * const campaignOffer = await prisma.campaignOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignOfferFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignOfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignOfferClient<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOfferFindFirstArgs} args - Arguments to find a CampaignOffer
     * @example
     * // Get one CampaignOffer
     * const campaignOffer = await prisma.campaignOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignOfferFindFirstArgs>(args?: SelectSubset<T, CampaignOfferFindFirstArgs<ExtArgs>>): Prisma__CampaignOfferClient<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOfferFindFirstOrThrowArgs} args - Arguments to find a CampaignOffer
     * @example
     * // Get one CampaignOffer
     * const campaignOffer = await prisma.campaignOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignOfferFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignOfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignOfferClient<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignOffers
     * const campaignOffers = await prisma.campaignOffer.findMany()
     * 
     * // Get first 10 CampaignOffers
     * const campaignOffers = await prisma.campaignOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignOfferWithIdOnly = await prisma.campaignOffer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignOfferFindManyArgs>(args?: SelectSubset<T, CampaignOfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignOffer.
     * @param {CampaignOfferCreateArgs} args - Arguments to create a CampaignOffer.
     * @example
     * // Create one CampaignOffer
     * const CampaignOffer = await prisma.campaignOffer.create({
     *   data: {
     *     // ... data to create a CampaignOffer
     *   }
     * })
     * 
     */
    create<T extends CampaignOfferCreateArgs>(args: SelectSubset<T, CampaignOfferCreateArgs<ExtArgs>>): Prisma__CampaignOfferClient<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignOffers.
     * @param {CampaignOfferCreateManyArgs} args - Arguments to create many CampaignOffers.
     * @example
     * // Create many CampaignOffers
     * const campaignOffer = await prisma.campaignOffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignOfferCreateManyArgs>(args?: SelectSubset<T, CampaignOfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignOffers and returns the data saved in the database.
     * @param {CampaignOfferCreateManyAndReturnArgs} args - Arguments to create many CampaignOffers.
     * @example
     * // Create many CampaignOffers
     * const campaignOffer = await prisma.campaignOffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignOffers and only return the `id`
     * const campaignOfferWithIdOnly = await prisma.campaignOffer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignOfferCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignOfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignOffer.
     * @param {CampaignOfferDeleteArgs} args - Arguments to delete one CampaignOffer.
     * @example
     * // Delete one CampaignOffer
     * const CampaignOffer = await prisma.campaignOffer.delete({
     *   where: {
     *     // ... filter to delete one CampaignOffer
     *   }
     * })
     * 
     */
    delete<T extends CampaignOfferDeleteArgs>(args: SelectSubset<T, CampaignOfferDeleteArgs<ExtArgs>>): Prisma__CampaignOfferClient<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignOffer.
     * @param {CampaignOfferUpdateArgs} args - Arguments to update one CampaignOffer.
     * @example
     * // Update one CampaignOffer
     * const campaignOffer = await prisma.campaignOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignOfferUpdateArgs>(args: SelectSubset<T, CampaignOfferUpdateArgs<ExtArgs>>): Prisma__CampaignOfferClient<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignOffers.
     * @param {CampaignOfferDeleteManyArgs} args - Arguments to filter CampaignOffers to delete.
     * @example
     * // Delete a few CampaignOffers
     * const { count } = await prisma.campaignOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignOfferDeleteManyArgs>(args?: SelectSubset<T, CampaignOfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignOffers
     * const campaignOffer = await prisma.campaignOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignOfferUpdateManyArgs>(args: SelectSubset<T, CampaignOfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignOffer.
     * @param {CampaignOfferUpsertArgs} args - Arguments to update or create a CampaignOffer.
     * @example
     * // Update or create a CampaignOffer
     * const campaignOffer = await prisma.campaignOffer.upsert({
     *   create: {
     *     // ... data to create a CampaignOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignOffer we want to update
     *   }
     * })
     */
    upsert<T extends CampaignOfferUpsertArgs>(args: SelectSubset<T, CampaignOfferUpsertArgs<ExtArgs>>): Prisma__CampaignOfferClient<$Result.GetResult<Prisma.$CampaignOfferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOfferCountArgs} args - Arguments to filter CampaignOffers to count.
     * @example
     * // Count the number of CampaignOffers
     * const count = await prisma.campaignOffer.count({
     *   where: {
     *     // ... the filter for the CampaignOffers we want to count
     *   }
     * })
    **/
    count<T extends CampaignOfferCountArgs>(
      args?: Subset<T, CampaignOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignOfferAggregateArgs>(args: Subset<T, CampaignOfferAggregateArgs>): Prisma.PrismaPromise<GetCampaignOfferAggregateType<T>>

    /**
     * Group by CampaignOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignOfferGroupByArgs['orderBy'] }
        : { orderBy?: CampaignOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignOffer model
   */
  readonly fields: CampaignOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignOffer model
   */ 
  interface CampaignOfferFieldRefs {
    readonly id: FieldRef<"CampaignOffer", 'String'>
    readonly campaignId: FieldRef<"CampaignOffer", 'String'>
    readonly description: FieldRef<"CampaignOffer", 'String'>
    readonly offerLimit: FieldRef<"CampaignOffer", 'Int'>
    readonly offerType: FieldRef<"CampaignOffer", 'String'>
    readonly successCriteria: FieldRef<"CampaignOffer", 'String'>
    readonly backupOffer: FieldRef<"CampaignOffer", 'String'>
    readonly createdAt: FieldRef<"CampaignOffer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignOffer findUnique
   */
  export type CampaignOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOffer to fetch.
     */
    where: CampaignOfferWhereUniqueInput
  }

  /**
   * CampaignOffer findUniqueOrThrow
   */
  export type CampaignOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOffer to fetch.
     */
    where: CampaignOfferWhereUniqueInput
  }

  /**
   * CampaignOffer findFirst
   */
  export type CampaignOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOffer to fetch.
     */
    where?: CampaignOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignOffers to fetch.
     */
    orderBy?: CampaignOfferOrderByWithRelationInput | CampaignOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignOffers.
     */
    cursor?: CampaignOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignOffers.
     */
    distinct?: CampaignOfferScalarFieldEnum | CampaignOfferScalarFieldEnum[]
  }

  /**
   * CampaignOffer findFirstOrThrow
   */
  export type CampaignOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOffer to fetch.
     */
    where?: CampaignOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignOffers to fetch.
     */
    orderBy?: CampaignOfferOrderByWithRelationInput | CampaignOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignOffers.
     */
    cursor?: CampaignOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignOffers.
     */
    distinct?: CampaignOfferScalarFieldEnum | CampaignOfferScalarFieldEnum[]
  }

  /**
   * CampaignOffer findMany
   */
  export type CampaignOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOffers to fetch.
     */
    where?: CampaignOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignOffers to fetch.
     */
    orderBy?: CampaignOfferOrderByWithRelationInput | CampaignOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignOffers.
     */
    cursor?: CampaignOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignOffers.
     */
    skip?: number
    distinct?: CampaignOfferScalarFieldEnum | CampaignOfferScalarFieldEnum[]
  }

  /**
   * CampaignOffer create
   */
  export type CampaignOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignOffer.
     */
    data: XOR<CampaignOfferCreateInput, CampaignOfferUncheckedCreateInput>
  }

  /**
   * CampaignOffer createMany
   */
  export type CampaignOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignOffers.
     */
    data: CampaignOfferCreateManyInput | CampaignOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignOffer createManyAndReturn
   */
  export type CampaignOfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignOffers.
     */
    data: CampaignOfferCreateManyInput | CampaignOfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignOffer update
   */
  export type CampaignOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignOffer.
     */
    data: XOR<CampaignOfferUpdateInput, CampaignOfferUncheckedUpdateInput>
    /**
     * Choose, which CampaignOffer to update.
     */
    where: CampaignOfferWhereUniqueInput
  }

  /**
   * CampaignOffer updateMany
   */
  export type CampaignOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignOffers.
     */
    data: XOR<CampaignOfferUpdateManyMutationInput, CampaignOfferUncheckedUpdateManyInput>
    /**
     * Filter which CampaignOffers to update
     */
    where?: CampaignOfferWhereInput
  }

  /**
   * CampaignOffer upsert
   */
  export type CampaignOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignOffer to update in case it exists.
     */
    where: CampaignOfferWhereUniqueInput
    /**
     * In case the CampaignOffer found by the `where` argument doesn't exist, create a new CampaignOffer with this data.
     */
    create: XOR<CampaignOfferCreateInput, CampaignOfferUncheckedCreateInput>
    /**
     * In case the CampaignOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignOfferUpdateInput, CampaignOfferUncheckedUpdateInput>
  }

  /**
   * CampaignOffer delete
   */
  export type CampaignOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
    /**
     * Filter which CampaignOffer to delete.
     */
    where: CampaignOfferWhereUniqueInput
  }

  /**
   * CampaignOffer deleteMany
   */
  export type CampaignOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignOffers to delete
     */
    where?: CampaignOfferWhereInput
  }

  /**
   * CampaignOffer without action
   */
  export type CampaignOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOffer
     */
    select?: CampaignOfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOfferInclude<ExtArgs> | null
  }


  /**
   * Model CampaignBudget
   */

  export type AggregateCampaignBudget = {
    _count: CampaignBudgetCountAggregateOutputType | null
    _avg: CampaignBudgetAvgAggregateOutputType | null
    _sum: CampaignBudgetSumAggregateOutputType | null
    _min: CampaignBudgetMinAggregateOutputType | null
    _max: CampaignBudgetMaxAggregateOutputType | null
  }

  export type CampaignBudgetAvgAggregateOutputType = {
    mediaSpend: number | null
    creativeSpend: number | null
    incentiveSpend: number | null
    logisticsSpend: number | null
    totalBudget: number | null
    costPerCustomer: number | null
    expectedROI: number | null
  }

  export type CampaignBudgetSumAggregateOutputType = {
    mediaSpend: number | null
    creativeSpend: number | null
    incentiveSpend: number | null
    logisticsSpend: number | null
    totalBudget: number | null
    costPerCustomer: number | null
    expectedROI: number | null
  }

  export type CampaignBudgetMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    mediaSpend: number | null
    creativeSpend: number | null
    incentiveSpend: number | null
    logisticsSpend: number | null
    totalBudget: number | null
    costPerCustomer: number | null
    expectedROI: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type CampaignBudgetMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    mediaSpend: number | null
    creativeSpend: number | null
    incentiveSpend: number | null
    logisticsSpend: number | null
    totalBudget: number | null
    costPerCustomer: number | null
    expectedROI: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type CampaignBudgetCountAggregateOutputType = {
    id: number
    campaignId: number
    mediaSpend: number
    creativeSpend: number
    incentiveSpend: number
    logisticsSpend: number
    totalBudget: number
    costPerCustomer: number
    expectedROI: number
    notes: number
    createdAt: number
    _all: number
  }


  export type CampaignBudgetAvgAggregateInputType = {
    mediaSpend?: true
    creativeSpend?: true
    incentiveSpend?: true
    logisticsSpend?: true
    totalBudget?: true
    costPerCustomer?: true
    expectedROI?: true
  }

  export type CampaignBudgetSumAggregateInputType = {
    mediaSpend?: true
    creativeSpend?: true
    incentiveSpend?: true
    logisticsSpend?: true
    totalBudget?: true
    costPerCustomer?: true
    expectedROI?: true
  }

  export type CampaignBudgetMinAggregateInputType = {
    id?: true
    campaignId?: true
    mediaSpend?: true
    creativeSpend?: true
    incentiveSpend?: true
    logisticsSpend?: true
    totalBudget?: true
    costPerCustomer?: true
    expectedROI?: true
    notes?: true
    createdAt?: true
  }

  export type CampaignBudgetMaxAggregateInputType = {
    id?: true
    campaignId?: true
    mediaSpend?: true
    creativeSpend?: true
    incentiveSpend?: true
    logisticsSpend?: true
    totalBudget?: true
    costPerCustomer?: true
    expectedROI?: true
    notes?: true
    createdAt?: true
  }

  export type CampaignBudgetCountAggregateInputType = {
    id?: true
    campaignId?: true
    mediaSpend?: true
    creativeSpend?: true
    incentiveSpend?: true
    logisticsSpend?: true
    totalBudget?: true
    costPerCustomer?: true
    expectedROI?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignBudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignBudget to aggregate.
     */
    where?: CampaignBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignBudgets to fetch.
     */
    orderBy?: CampaignBudgetOrderByWithRelationInput | CampaignBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignBudgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignBudgets
    **/
    _count?: true | CampaignBudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignBudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignBudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignBudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignBudgetMaxAggregateInputType
  }

  export type GetCampaignBudgetAggregateType<T extends CampaignBudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignBudget[P]>
      : GetScalarType<T[P], AggregateCampaignBudget[P]>
  }




  export type CampaignBudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignBudgetWhereInput
    orderBy?: CampaignBudgetOrderByWithAggregationInput | CampaignBudgetOrderByWithAggregationInput[]
    by: CampaignBudgetScalarFieldEnum[] | CampaignBudgetScalarFieldEnum
    having?: CampaignBudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignBudgetCountAggregateInputType | true
    _avg?: CampaignBudgetAvgAggregateInputType
    _sum?: CampaignBudgetSumAggregateInputType
    _min?: CampaignBudgetMinAggregateInputType
    _max?: CampaignBudgetMaxAggregateInputType
  }

  export type CampaignBudgetGroupByOutputType = {
    id: string
    campaignId: string
    mediaSpend: number
    creativeSpend: number
    incentiveSpend: number
    logisticsSpend: number
    totalBudget: number
    costPerCustomer: number
    expectedROI: number | null
    notes: string | null
    createdAt: Date
    _count: CampaignBudgetCountAggregateOutputType | null
    _avg: CampaignBudgetAvgAggregateOutputType | null
    _sum: CampaignBudgetSumAggregateOutputType | null
    _min: CampaignBudgetMinAggregateOutputType | null
    _max: CampaignBudgetMaxAggregateOutputType | null
  }

  type GetCampaignBudgetGroupByPayload<T extends CampaignBudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignBudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignBudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignBudgetGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignBudgetGroupByOutputType[P]>
        }
      >
    >


  export type CampaignBudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    mediaSpend?: boolean
    creativeSpend?: boolean
    incentiveSpend?: boolean
    logisticsSpend?: boolean
    totalBudget?: boolean
    costPerCustomer?: boolean
    expectedROI?: boolean
    notes?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignBudget"]>

  export type CampaignBudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    mediaSpend?: boolean
    creativeSpend?: boolean
    incentiveSpend?: boolean
    logisticsSpend?: boolean
    totalBudget?: boolean
    costPerCustomer?: boolean
    expectedROI?: boolean
    notes?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignBudget"]>

  export type CampaignBudgetSelectScalar = {
    id?: boolean
    campaignId?: boolean
    mediaSpend?: boolean
    creativeSpend?: boolean
    incentiveSpend?: boolean
    logisticsSpend?: boolean
    totalBudget?: boolean
    costPerCustomer?: boolean
    expectedROI?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type CampaignBudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignBudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignBudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignBudget"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      mediaSpend: number
      creativeSpend: number
      incentiveSpend: number
      logisticsSpend: number
      totalBudget: number
      costPerCustomer: number
      expectedROI: number | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["campaignBudget"]>
    composites: {}
  }

  type CampaignBudgetGetPayload<S extends boolean | null | undefined | CampaignBudgetDefaultArgs> = $Result.GetResult<Prisma.$CampaignBudgetPayload, S>

  type CampaignBudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignBudgetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignBudgetCountAggregateInputType | true
    }

  export interface CampaignBudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignBudget'], meta: { name: 'CampaignBudget' } }
    /**
     * Find zero or one CampaignBudget that matches the filter.
     * @param {CampaignBudgetFindUniqueArgs} args - Arguments to find a CampaignBudget
     * @example
     * // Get one CampaignBudget
     * const campaignBudget = await prisma.campaignBudget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignBudgetFindUniqueArgs>(args: SelectSubset<T, CampaignBudgetFindUniqueArgs<ExtArgs>>): Prisma__CampaignBudgetClient<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignBudget that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignBudgetFindUniqueOrThrowArgs} args - Arguments to find a CampaignBudget
     * @example
     * // Get one CampaignBudget
     * const campaignBudget = await prisma.campaignBudget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignBudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignBudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignBudgetClient<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignBudget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignBudgetFindFirstArgs} args - Arguments to find a CampaignBudget
     * @example
     * // Get one CampaignBudget
     * const campaignBudget = await prisma.campaignBudget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignBudgetFindFirstArgs>(args?: SelectSubset<T, CampaignBudgetFindFirstArgs<ExtArgs>>): Prisma__CampaignBudgetClient<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignBudget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignBudgetFindFirstOrThrowArgs} args - Arguments to find a CampaignBudget
     * @example
     * // Get one CampaignBudget
     * const campaignBudget = await prisma.campaignBudget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignBudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignBudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignBudgetClient<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignBudgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignBudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignBudgets
     * const campaignBudgets = await prisma.campaignBudget.findMany()
     * 
     * // Get first 10 CampaignBudgets
     * const campaignBudgets = await prisma.campaignBudget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignBudgetWithIdOnly = await prisma.campaignBudget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignBudgetFindManyArgs>(args?: SelectSubset<T, CampaignBudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignBudget.
     * @param {CampaignBudgetCreateArgs} args - Arguments to create a CampaignBudget.
     * @example
     * // Create one CampaignBudget
     * const CampaignBudget = await prisma.campaignBudget.create({
     *   data: {
     *     // ... data to create a CampaignBudget
     *   }
     * })
     * 
     */
    create<T extends CampaignBudgetCreateArgs>(args: SelectSubset<T, CampaignBudgetCreateArgs<ExtArgs>>): Prisma__CampaignBudgetClient<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignBudgets.
     * @param {CampaignBudgetCreateManyArgs} args - Arguments to create many CampaignBudgets.
     * @example
     * // Create many CampaignBudgets
     * const campaignBudget = await prisma.campaignBudget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignBudgetCreateManyArgs>(args?: SelectSubset<T, CampaignBudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignBudgets and returns the data saved in the database.
     * @param {CampaignBudgetCreateManyAndReturnArgs} args - Arguments to create many CampaignBudgets.
     * @example
     * // Create many CampaignBudgets
     * const campaignBudget = await prisma.campaignBudget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignBudgets and only return the `id`
     * const campaignBudgetWithIdOnly = await prisma.campaignBudget.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignBudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignBudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignBudget.
     * @param {CampaignBudgetDeleteArgs} args - Arguments to delete one CampaignBudget.
     * @example
     * // Delete one CampaignBudget
     * const CampaignBudget = await prisma.campaignBudget.delete({
     *   where: {
     *     // ... filter to delete one CampaignBudget
     *   }
     * })
     * 
     */
    delete<T extends CampaignBudgetDeleteArgs>(args: SelectSubset<T, CampaignBudgetDeleteArgs<ExtArgs>>): Prisma__CampaignBudgetClient<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignBudget.
     * @param {CampaignBudgetUpdateArgs} args - Arguments to update one CampaignBudget.
     * @example
     * // Update one CampaignBudget
     * const campaignBudget = await prisma.campaignBudget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignBudgetUpdateArgs>(args: SelectSubset<T, CampaignBudgetUpdateArgs<ExtArgs>>): Prisma__CampaignBudgetClient<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignBudgets.
     * @param {CampaignBudgetDeleteManyArgs} args - Arguments to filter CampaignBudgets to delete.
     * @example
     * // Delete a few CampaignBudgets
     * const { count } = await prisma.campaignBudget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignBudgetDeleteManyArgs>(args?: SelectSubset<T, CampaignBudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignBudgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignBudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignBudgets
     * const campaignBudget = await prisma.campaignBudget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignBudgetUpdateManyArgs>(args: SelectSubset<T, CampaignBudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignBudget.
     * @param {CampaignBudgetUpsertArgs} args - Arguments to update or create a CampaignBudget.
     * @example
     * // Update or create a CampaignBudget
     * const campaignBudget = await prisma.campaignBudget.upsert({
     *   create: {
     *     // ... data to create a CampaignBudget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignBudget we want to update
     *   }
     * })
     */
    upsert<T extends CampaignBudgetUpsertArgs>(args: SelectSubset<T, CampaignBudgetUpsertArgs<ExtArgs>>): Prisma__CampaignBudgetClient<$Result.GetResult<Prisma.$CampaignBudgetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignBudgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignBudgetCountArgs} args - Arguments to filter CampaignBudgets to count.
     * @example
     * // Count the number of CampaignBudgets
     * const count = await prisma.campaignBudget.count({
     *   where: {
     *     // ... the filter for the CampaignBudgets we want to count
     *   }
     * })
    **/
    count<T extends CampaignBudgetCountArgs>(
      args?: Subset<T, CampaignBudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignBudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignBudget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignBudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignBudgetAggregateArgs>(args: Subset<T, CampaignBudgetAggregateArgs>): Prisma.PrismaPromise<GetCampaignBudgetAggregateType<T>>

    /**
     * Group by CampaignBudget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignBudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignBudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignBudgetGroupByArgs['orderBy'] }
        : { orderBy?: CampaignBudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignBudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignBudget model
   */
  readonly fields: CampaignBudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignBudget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignBudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignBudget model
   */ 
  interface CampaignBudgetFieldRefs {
    readonly id: FieldRef<"CampaignBudget", 'String'>
    readonly campaignId: FieldRef<"CampaignBudget", 'String'>
    readonly mediaSpend: FieldRef<"CampaignBudget", 'Float'>
    readonly creativeSpend: FieldRef<"CampaignBudget", 'Float'>
    readonly incentiveSpend: FieldRef<"CampaignBudget", 'Float'>
    readonly logisticsSpend: FieldRef<"CampaignBudget", 'Float'>
    readonly totalBudget: FieldRef<"CampaignBudget", 'Float'>
    readonly costPerCustomer: FieldRef<"CampaignBudget", 'Float'>
    readonly expectedROI: FieldRef<"CampaignBudget", 'Float'>
    readonly notes: FieldRef<"CampaignBudget", 'String'>
    readonly createdAt: FieldRef<"CampaignBudget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignBudget findUnique
   */
  export type CampaignBudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    /**
     * Filter, which CampaignBudget to fetch.
     */
    where: CampaignBudgetWhereUniqueInput
  }

  /**
   * CampaignBudget findUniqueOrThrow
   */
  export type CampaignBudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    /**
     * Filter, which CampaignBudget to fetch.
     */
    where: CampaignBudgetWhereUniqueInput
  }

  /**
   * CampaignBudget findFirst
   */
  export type CampaignBudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    /**
     * Filter, which CampaignBudget to fetch.
     */
    where?: CampaignBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignBudgets to fetch.
     */
    orderBy?: CampaignBudgetOrderByWithRelationInput | CampaignBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignBudgets.
     */
    cursor?: CampaignBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignBudgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignBudgets.
     */
    distinct?: CampaignBudgetScalarFieldEnum | CampaignBudgetScalarFieldEnum[]
  }

  /**
   * CampaignBudget findFirstOrThrow
   */
  export type CampaignBudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    /**
     * Filter, which CampaignBudget to fetch.
     */
    where?: CampaignBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignBudgets to fetch.
     */
    orderBy?: CampaignBudgetOrderByWithRelationInput | CampaignBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignBudgets.
     */
    cursor?: CampaignBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignBudgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignBudgets.
     */
    distinct?: CampaignBudgetScalarFieldEnum | CampaignBudgetScalarFieldEnum[]
  }

  /**
   * CampaignBudget findMany
   */
  export type CampaignBudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    /**
     * Filter, which CampaignBudgets to fetch.
     */
    where?: CampaignBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignBudgets to fetch.
     */
    orderBy?: CampaignBudgetOrderByWithRelationInput | CampaignBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignBudgets.
     */
    cursor?: CampaignBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignBudgets.
     */
    skip?: number
    distinct?: CampaignBudgetScalarFieldEnum | CampaignBudgetScalarFieldEnum[]
  }

  /**
   * CampaignBudget create
   */
  export type CampaignBudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignBudget.
     */
    data: XOR<CampaignBudgetCreateInput, CampaignBudgetUncheckedCreateInput>
  }

  /**
   * CampaignBudget createMany
   */
  export type CampaignBudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignBudgets.
     */
    data: CampaignBudgetCreateManyInput | CampaignBudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignBudget createManyAndReturn
   */
  export type CampaignBudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignBudgets.
     */
    data: CampaignBudgetCreateManyInput | CampaignBudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignBudget update
   */
  export type CampaignBudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignBudget.
     */
    data: XOR<CampaignBudgetUpdateInput, CampaignBudgetUncheckedUpdateInput>
    /**
     * Choose, which CampaignBudget to update.
     */
    where: CampaignBudgetWhereUniqueInput
  }

  /**
   * CampaignBudget updateMany
   */
  export type CampaignBudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignBudgets.
     */
    data: XOR<CampaignBudgetUpdateManyMutationInput, CampaignBudgetUncheckedUpdateManyInput>
    /**
     * Filter which CampaignBudgets to update
     */
    where?: CampaignBudgetWhereInput
  }

  /**
   * CampaignBudget upsert
   */
  export type CampaignBudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignBudget to update in case it exists.
     */
    where: CampaignBudgetWhereUniqueInput
    /**
     * In case the CampaignBudget found by the `where` argument doesn't exist, create a new CampaignBudget with this data.
     */
    create: XOR<CampaignBudgetCreateInput, CampaignBudgetUncheckedCreateInput>
    /**
     * In case the CampaignBudget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignBudgetUpdateInput, CampaignBudgetUncheckedUpdateInput>
  }

  /**
   * CampaignBudget delete
   */
  export type CampaignBudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
    /**
     * Filter which CampaignBudget to delete.
     */
    where: CampaignBudgetWhereUniqueInput
  }

  /**
   * CampaignBudget deleteMany
   */
  export type CampaignBudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignBudgets to delete
     */
    where?: CampaignBudgetWhereInput
  }

  /**
   * CampaignBudget without action
   */
  export type CampaignBudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignBudget
     */
    select?: CampaignBudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignBudgetInclude<ExtArgs> | null
  }


  /**
   * Model ChannelPlan
   */

  export type AggregateChannelPlan = {
    _count: ChannelPlanCountAggregateOutputType | null
    _min: ChannelPlanMinAggregateOutputType | null
    _max: ChannelPlanMaxAggregateOutputType | null
  }

  export type ChannelPlanMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    primary: string | null
    primaryReason: string | null
    createdAt: Date | null
  }

  export type ChannelPlanMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    primary: string | null
    primaryReason: string | null
    createdAt: Date | null
  }

  export type ChannelPlanCountAggregateOutputType = {
    id: number
    campaignId: number
    channels: number
    primary: number
    primaryReason: number
    messageStyles: number
    createdAt: number
    _all: number
  }


  export type ChannelPlanMinAggregateInputType = {
    id?: true
    campaignId?: true
    primary?: true
    primaryReason?: true
    createdAt?: true
  }

  export type ChannelPlanMaxAggregateInputType = {
    id?: true
    campaignId?: true
    primary?: true
    primaryReason?: true
    createdAt?: true
  }

  export type ChannelPlanCountAggregateInputType = {
    id?: true
    campaignId?: true
    channels?: true
    primary?: true
    primaryReason?: true
    messageStyles?: true
    createdAt?: true
    _all?: true
  }

  export type ChannelPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelPlan to aggregate.
     */
    where?: ChannelPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelPlans to fetch.
     */
    orderBy?: ChannelPlanOrderByWithRelationInput | ChannelPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelPlans
    **/
    _count?: true | ChannelPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelPlanMaxAggregateInputType
  }

  export type GetChannelPlanAggregateType<T extends ChannelPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelPlan[P]>
      : GetScalarType<T[P], AggregateChannelPlan[P]>
  }




  export type ChannelPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelPlanWhereInput
    orderBy?: ChannelPlanOrderByWithAggregationInput | ChannelPlanOrderByWithAggregationInput[]
    by: ChannelPlanScalarFieldEnum[] | ChannelPlanScalarFieldEnum
    having?: ChannelPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelPlanCountAggregateInputType | true
    _min?: ChannelPlanMinAggregateInputType
    _max?: ChannelPlanMaxAggregateInputType
  }

  export type ChannelPlanGroupByOutputType = {
    id: string
    campaignId: string
    channels: string[]
    primary: string
    primaryReason: string
    messageStyles: string[]
    createdAt: Date
    _count: ChannelPlanCountAggregateOutputType | null
    _min: ChannelPlanMinAggregateOutputType | null
    _max: ChannelPlanMaxAggregateOutputType | null
  }

  type GetChannelPlanGroupByPayload<T extends ChannelPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelPlanGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelPlanGroupByOutputType[P]>
        }
      >
    >


  export type ChannelPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    channels?: boolean
    primary?: boolean
    primaryReason?: boolean
    messageStyles?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelPlan"]>

  export type ChannelPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    channels?: boolean
    primary?: boolean
    primaryReason?: boolean
    messageStyles?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelPlan"]>

  export type ChannelPlanSelectScalar = {
    id?: boolean
    campaignId?: boolean
    channels?: boolean
    primary?: boolean
    primaryReason?: boolean
    messageStyles?: boolean
    createdAt?: boolean
  }

  export type ChannelPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ChannelPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $ChannelPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelPlan"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      channels: string[]
      primary: string
      primaryReason: string
      messageStyles: string[]
      createdAt: Date
    }, ExtArgs["result"]["channelPlan"]>
    composites: {}
  }

  type ChannelPlanGetPayload<S extends boolean | null | undefined | ChannelPlanDefaultArgs> = $Result.GetResult<Prisma.$ChannelPlanPayload, S>

  type ChannelPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelPlanCountAggregateInputType | true
    }

  export interface ChannelPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelPlan'], meta: { name: 'ChannelPlan' } }
    /**
     * Find zero or one ChannelPlan that matches the filter.
     * @param {ChannelPlanFindUniqueArgs} args - Arguments to find a ChannelPlan
     * @example
     * // Get one ChannelPlan
     * const channelPlan = await prisma.channelPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelPlanFindUniqueArgs>(args: SelectSubset<T, ChannelPlanFindUniqueArgs<ExtArgs>>): Prisma__ChannelPlanClient<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelPlanFindUniqueOrThrowArgs} args - Arguments to find a ChannelPlan
     * @example
     * // Get one ChannelPlan
     * const channelPlan = await prisma.channelPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelPlanClient<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelPlanFindFirstArgs} args - Arguments to find a ChannelPlan
     * @example
     * // Get one ChannelPlan
     * const channelPlan = await prisma.channelPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelPlanFindFirstArgs>(args?: SelectSubset<T, ChannelPlanFindFirstArgs<ExtArgs>>): Prisma__ChannelPlanClient<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelPlanFindFirstOrThrowArgs} args - Arguments to find a ChannelPlan
     * @example
     * // Get one ChannelPlan
     * const channelPlan = await prisma.channelPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelPlanClient<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelPlans
     * const channelPlans = await prisma.channelPlan.findMany()
     * 
     * // Get first 10 ChannelPlans
     * const channelPlans = await prisma.channelPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelPlanWithIdOnly = await prisma.channelPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelPlanFindManyArgs>(args?: SelectSubset<T, ChannelPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelPlan.
     * @param {ChannelPlanCreateArgs} args - Arguments to create a ChannelPlan.
     * @example
     * // Create one ChannelPlan
     * const ChannelPlan = await prisma.channelPlan.create({
     *   data: {
     *     // ... data to create a ChannelPlan
     *   }
     * })
     * 
     */
    create<T extends ChannelPlanCreateArgs>(args: SelectSubset<T, ChannelPlanCreateArgs<ExtArgs>>): Prisma__ChannelPlanClient<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelPlans.
     * @param {ChannelPlanCreateManyArgs} args - Arguments to create many ChannelPlans.
     * @example
     * // Create many ChannelPlans
     * const channelPlan = await prisma.channelPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelPlanCreateManyArgs>(args?: SelectSubset<T, ChannelPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChannelPlans and returns the data saved in the database.
     * @param {ChannelPlanCreateManyAndReturnArgs} args - Arguments to create many ChannelPlans.
     * @example
     * // Create many ChannelPlans
     * const channelPlan = await prisma.channelPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChannelPlans and only return the `id`
     * const channelPlanWithIdOnly = await prisma.channelPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChannelPlan.
     * @param {ChannelPlanDeleteArgs} args - Arguments to delete one ChannelPlan.
     * @example
     * // Delete one ChannelPlan
     * const ChannelPlan = await prisma.channelPlan.delete({
     *   where: {
     *     // ... filter to delete one ChannelPlan
     *   }
     * })
     * 
     */
    delete<T extends ChannelPlanDeleteArgs>(args: SelectSubset<T, ChannelPlanDeleteArgs<ExtArgs>>): Prisma__ChannelPlanClient<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelPlan.
     * @param {ChannelPlanUpdateArgs} args - Arguments to update one ChannelPlan.
     * @example
     * // Update one ChannelPlan
     * const channelPlan = await prisma.channelPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelPlanUpdateArgs>(args: SelectSubset<T, ChannelPlanUpdateArgs<ExtArgs>>): Prisma__ChannelPlanClient<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelPlans.
     * @param {ChannelPlanDeleteManyArgs} args - Arguments to filter ChannelPlans to delete.
     * @example
     * // Delete a few ChannelPlans
     * const { count } = await prisma.channelPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelPlanDeleteManyArgs>(args?: SelectSubset<T, ChannelPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelPlans
     * const channelPlan = await prisma.channelPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelPlanUpdateManyArgs>(args: SelectSubset<T, ChannelPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelPlan.
     * @param {ChannelPlanUpsertArgs} args - Arguments to update or create a ChannelPlan.
     * @example
     * // Update or create a ChannelPlan
     * const channelPlan = await prisma.channelPlan.upsert({
     *   create: {
     *     // ... data to create a ChannelPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelPlan we want to update
     *   }
     * })
     */
    upsert<T extends ChannelPlanUpsertArgs>(args: SelectSubset<T, ChannelPlanUpsertArgs<ExtArgs>>): Prisma__ChannelPlanClient<$Result.GetResult<Prisma.$ChannelPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChannelPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelPlanCountArgs} args - Arguments to filter ChannelPlans to count.
     * @example
     * // Count the number of ChannelPlans
     * const count = await prisma.channelPlan.count({
     *   where: {
     *     // ... the filter for the ChannelPlans we want to count
     *   }
     * })
    **/
    count<T extends ChannelPlanCountArgs>(
      args?: Subset<T, ChannelPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelPlanAggregateArgs>(args: Subset<T, ChannelPlanAggregateArgs>): Prisma.PrismaPromise<GetChannelPlanAggregateType<T>>

    /**
     * Group by ChannelPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelPlanGroupByArgs['orderBy'] }
        : { orderBy?: ChannelPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelPlan model
   */
  readonly fields: ChannelPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelPlan model
   */ 
  interface ChannelPlanFieldRefs {
    readonly id: FieldRef<"ChannelPlan", 'String'>
    readonly campaignId: FieldRef<"ChannelPlan", 'String'>
    readonly channels: FieldRef<"ChannelPlan", 'String[]'>
    readonly primary: FieldRef<"ChannelPlan", 'String'>
    readonly primaryReason: FieldRef<"ChannelPlan", 'String'>
    readonly messageStyles: FieldRef<"ChannelPlan", 'String[]'>
    readonly createdAt: FieldRef<"ChannelPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelPlan findUnique
   */
  export type ChannelPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    /**
     * Filter, which ChannelPlan to fetch.
     */
    where: ChannelPlanWhereUniqueInput
  }

  /**
   * ChannelPlan findUniqueOrThrow
   */
  export type ChannelPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    /**
     * Filter, which ChannelPlan to fetch.
     */
    where: ChannelPlanWhereUniqueInput
  }

  /**
   * ChannelPlan findFirst
   */
  export type ChannelPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    /**
     * Filter, which ChannelPlan to fetch.
     */
    where?: ChannelPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelPlans to fetch.
     */
    orderBy?: ChannelPlanOrderByWithRelationInput | ChannelPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelPlans.
     */
    cursor?: ChannelPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelPlans.
     */
    distinct?: ChannelPlanScalarFieldEnum | ChannelPlanScalarFieldEnum[]
  }

  /**
   * ChannelPlan findFirstOrThrow
   */
  export type ChannelPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    /**
     * Filter, which ChannelPlan to fetch.
     */
    where?: ChannelPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelPlans to fetch.
     */
    orderBy?: ChannelPlanOrderByWithRelationInput | ChannelPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelPlans.
     */
    cursor?: ChannelPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelPlans.
     */
    distinct?: ChannelPlanScalarFieldEnum | ChannelPlanScalarFieldEnum[]
  }

  /**
   * ChannelPlan findMany
   */
  export type ChannelPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    /**
     * Filter, which ChannelPlans to fetch.
     */
    where?: ChannelPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelPlans to fetch.
     */
    orderBy?: ChannelPlanOrderByWithRelationInput | ChannelPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelPlans.
     */
    cursor?: ChannelPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelPlans.
     */
    skip?: number
    distinct?: ChannelPlanScalarFieldEnum | ChannelPlanScalarFieldEnum[]
  }

  /**
   * ChannelPlan create
   */
  export type ChannelPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelPlan.
     */
    data: XOR<ChannelPlanCreateInput, ChannelPlanUncheckedCreateInput>
  }

  /**
   * ChannelPlan createMany
   */
  export type ChannelPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelPlans.
     */
    data: ChannelPlanCreateManyInput | ChannelPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelPlan createManyAndReturn
   */
  export type ChannelPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChannelPlans.
     */
    data: ChannelPlanCreateManyInput | ChannelPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChannelPlan update
   */
  export type ChannelPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelPlan.
     */
    data: XOR<ChannelPlanUpdateInput, ChannelPlanUncheckedUpdateInput>
    /**
     * Choose, which ChannelPlan to update.
     */
    where: ChannelPlanWhereUniqueInput
  }

  /**
   * ChannelPlan updateMany
   */
  export type ChannelPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelPlans.
     */
    data: XOR<ChannelPlanUpdateManyMutationInput, ChannelPlanUncheckedUpdateManyInput>
    /**
     * Filter which ChannelPlans to update
     */
    where?: ChannelPlanWhereInput
  }

  /**
   * ChannelPlan upsert
   */
  export type ChannelPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelPlan to update in case it exists.
     */
    where: ChannelPlanWhereUniqueInput
    /**
     * In case the ChannelPlan found by the `where` argument doesn't exist, create a new ChannelPlan with this data.
     */
    create: XOR<ChannelPlanCreateInput, ChannelPlanUncheckedCreateInput>
    /**
     * In case the ChannelPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelPlanUpdateInput, ChannelPlanUncheckedUpdateInput>
  }

  /**
   * ChannelPlan delete
   */
  export type ChannelPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
    /**
     * Filter which ChannelPlan to delete.
     */
    where: ChannelPlanWhereUniqueInput
  }

  /**
   * ChannelPlan deleteMany
   */
  export type ChannelPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelPlans to delete
     */
    where?: ChannelPlanWhereInput
  }

  /**
   * ChannelPlan without action
   */
  export type ChannelPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelPlan
     */
    select?: ChannelPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelPlanInclude<ExtArgs> | null
  }


  /**
   * Model CampaignTimeline
   */

  export type AggregateCampaignTimeline = {
    _count: CampaignTimelineCountAggregateOutputType | null
    _min: CampaignTimelineMinAggregateOutputType | null
    _max: CampaignTimelineMaxAggregateOutputType | null
  }

  export type CampaignTimelineMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    milestoneName: string | null
    milestoneType: string | null
    plannedDate: Date | null
    createdAt: Date | null
  }

  export type CampaignTimelineMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    milestoneName: string | null
    milestoneType: string | null
    plannedDate: Date | null
    createdAt: Date | null
  }

  export type CampaignTimelineCountAggregateOutputType = {
    id: number
    campaignId: number
    milestoneName: number
    milestoneType: number
    plannedDate: number
    createdAt: number
    _all: number
  }


  export type CampaignTimelineMinAggregateInputType = {
    id?: true
    campaignId?: true
    milestoneName?: true
    milestoneType?: true
    plannedDate?: true
    createdAt?: true
  }

  export type CampaignTimelineMaxAggregateInputType = {
    id?: true
    campaignId?: true
    milestoneName?: true
    milestoneType?: true
    plannedDate?: true
    createdAt?: true
  }

  export type CampaignTimelineCountAggregateInputType = {
    id?: true
    campaignId?: true
    milestoneName?: true
    milestoneType?: true
    plannedDate?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignTimelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignTimeline to aggregate.
     */
    where?: CampaignTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTimelines to fetch.
     */
    orderBy?: CampaignTimelineOrderByWithRelationInput | CampaignTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignTimelines
    **/
    _count?: true | CampaignTimelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignTimelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignTimelineMaxAggregateInputType
  }

  export type GetCampaignTimelineAggregateType<T extends CampaignTimelineAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignTimeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignTimeline[P]>
      : GetScalarType<T[P], AggregateCampaignTimeline[P]>
  }




  export type CampaignTimelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTimelineWhereInput
    orderBy?: CampaignTimelineOrderByWithAggregationInput | CampaignTimelineOrderByWithAggregationInput[]
    by: CampaignTimelineScalarFieldEnum[] | CampaignTimelineScalarFieldEnum
    having?: CampaignTimelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignTimelineCountAggregateInputType | true
    _min?: CampaignTimelineMinAggregateInputType
    _max?: CampaignTimelineMaxAggregateInputType
  }

  export type CampaignTimelineGroupByOutputType = {
    id: string
    campaignId: string
    milestoneName: string
    milestoneType: string
    plannedDate: Date
    createdAt: Date
    _count: CampaignTimelineCountAggregateOutputType | null
    _min: CampaignTimelineMinAggregateOutputType | null
    _max: CampaignTimelineMaxAggregateOutputType | null
  }

  type GetCampaignTimelineGroupByPayload<T extends CampaignTimelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignTimelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignTimelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignTimelineGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignTimelineGroupByOutputType[P]>
        }
      >
    >


  export type CampaignTimelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    milestoneName?: boolean
    milestoneType?: boolean
    plannedDate?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignTimeline"]>

  export type CampaignTimelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    milestoneName?: boolean
    milestoneType?: boolean
    plannedDate?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignTimeline"]>

  export type CampaignTimelineSelectScalar = {
    id?: boolean
    campaignId?: boolean
    milestoneName?: boolean
    milestoneType?: boolean
    plannedDate?: boolean
    createdAt?: boolean
  }

  export type CampaignTimelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignTimelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignTimelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignTimeline"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      milestoneName: string
      milestoneType: string
      plannedDate: Date
      createdAt: Date
    }, ExtArgs["result"]["campaignTimeline"]>
    composites: {}
  }

  type CampaignTimelineGetPayload<S extends boolean | null | undefined | CampaignTimelineDefaultArgs> = $Result.GetResult<Prisma.$CampaignTimelinePayload, S>

  type CampaignTimelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignTimelineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignTimelineCountAggregateInputType | true
    }

  export interface CampaignTimelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignTimeline'], meta: { name: 'CampaignTimeline' } }
    /**
     * Find zero or one CampaignTimeline that matches the filter.
     * @param {CampaignTimelineFindUniqueArgs} args - Arguments to find a CampaignTimeline
     * @example
     * // Get one CampaignTimeline
     * const campaignTimeline = await prisma.campaignTimeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignTimelineFindUniqueArgs>(args: SelectSubset<T, CampaignTimelineFindUniqueArgs<ExtArgs>>): Prisma__CampaignTimelineClient<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignTimeline that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignTimelineFindUniqueOrThrowArgs} args - Arguments to find a CampaignTimeline
     * @example
     * // Get one CampaignTimeline
     * const campaignTimeline = await prisma.campaignTimeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignTimelineFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignTimelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignTimelineClient<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignTimeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelineFindFirstArgs} args - Arguments to find a CampaignTimeline
     * @example
     * // Get one CampaignTimeline
     * const campaignTimeline = await prisma.campaignTimeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignTimelineFindFirstArgs>(args?: SelectSubset<T, CampaignTimelineFindFirstArgs<ExtArgs>>): Prisma__CampaignTimelineClient<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignTimeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelineFindFirstOrThrowArgs} args - Arguments to find a CampaignTimeline
     * @example
     * // Get one CampaignTimeline
     * const campaignTimeline = await prisma.campaignTimeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignTimelineFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignTimelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignTimelineClient<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignTimelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignTimelines
     * const campaignTimelines = await prisma.campaignTimeline.findMany()
     * 
     * // Get first 10 CampaignTimelines
     * const campaignTimelines = await prisma.campaignTimeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignTimelineWithIdOnly = await prisma.campaignTimeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignTimelineFindManyArgs>(args?: SelectSubset<T, CampaignTimelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignTimeline.
     * @param {CampaignTimelineCreateArgs} args - Arguments to create a CampaignTimeline.
     * @example
     * // Create one CampaignTimeline
     * const CampaignTimeline = await prisma.campaignTimeline.create({
     *   data: {
     *     // ... data to create a CampaignTimeline
     *   }
     * })
     * 
     */
    create<T extends CampaignTimelineCreateArgs>(args: SelectSubset<T, CampaignTimelineCreateArgs<ExtArgs>>): Prisma__CampaignTimelineClient<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignTimelines.
     * @param {CampaignTimelineCreateManyArgs} args - Arguments to create many CampaignTimelines.
     * @example
     * // Create many CampaignTimelines
     * const campaignTimeline = await prisma.campaignTimeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignTimelineCreateManyArgs>(args?: SelectSubset<T, CampaignTimelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignTimelines and returns the data saved in the database.
     * @param {CampaignTimelineCreateManyAndReturnArgs} args - Arguments to create many CampaignTimelines.
     * @example
     * // Create many CampaignTimelines
     * const campaignTimeline = await prisma.campaignTimeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignTimelines and only return the `id`
     * const campaignTimelineWithIdOnly = await prisma.campaignTimeline.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignTimelineCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignTimelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignTimeline.
     * @param {CampaignTimelineDeleteArgs} args - Arguments to delete one CampaignTimeline.
     * @example
     * // Delete one CampaignTimeline
     * const CampaignTimeline = await prisma.campaignTimeline.delete({
     *   where: {
     *     // ... filter to delete one CampaignTimeline
     *   }
     * })
     * 
     */
    delete<T extends CampaignTimelineDeleteArgs>(args: SelectSubset<T, CampaignTimelineDeleteArgs<ExtArgs>>): Prisma__CampaignTimelineClient<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignTimeline.
     * @param {CampaignTimelineUpdateArgs} args - Arguments to update one CampaignTimeline.
     * @example
     * // Update one CampaignTimeline
     * const campaignTimeline = await prisma.campaignTimeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignTimelineUpdateArgs>(args: SelectSubset<T, CampaignTimelineUpdateArgs<ExtArgs>>): Prisma__CampaignTimelineClient<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignTimelines.
     * @param {CampaignTimelineDeleteManyArgs} args - Arguments to filter CampaignTimelines to delete.
     * @example
     * // Delete a few CampaignTimelines
     * const { count } = await prisma.campaignTimeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignTimelineDeleteManyArgs>(args?: SelectSubset<T, CampaignTimelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignTimelines
     * const campaignTimeline = await prisma.campaignTimeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignTimelineUpdateManyArgs>(args: SelectSubset<T, CampaignTimelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignTimeline.
     * @param {CampaignTimelineUpsertArgs} args - Arguments to update or create a CampaignTimeline.
     * @example
     * // Update or create a CampaignTimeline
     * const campaignTimeline = await prisma.campaignTimeline.upsert({
     *   create: {
     *     // ... data to create a CampaignTimeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignTimeline we want to update
     *   }
     * })
     */
    upsert<T extends CampaignTimelineUpsertArgs>(args: SelectSubset<T, CampaignTimelineUpsertArgs<ExtArgs>>): Prisma__CampaignTimelineClient<$Result.GetResult<Prisma.$CampaignTimelinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelineCountArgs} args - Arguments to filter CampaignTimelines to count.
     * @example
     * // Count the number of CampaignTimelines
     * const count = await prisma.campaignTimeline.count({
     *   where: {
     *     // ... the filter for the CampaignTimelines we want to count
     *   }
     * })
    **/
    count<T extends CampaignTimelineCountArgs>(
      args?: Subset<T, CampaignTimelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignTimelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignTimelineAggregateArgs>(args: Subset<T, CampaignTimelineAggregateArgs>): Prisma.PrismaPromise<GetCampaignTimelineAggregateType<T>>

    /**
     * Group by CampaignTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTimelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignTimelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignTimelineGroupByArgs['orderBy'] }
        : { orderBy?: CampaignTimelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignTimelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignTimelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignTimeline model
   */
  readonly fields: CampaignTimelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignTimeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignTimelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignTimeline model
   */ 
  interface CampaignTimelineFieldRefs {
    readonly id: FieldRef<"CampaignTimeline", 'String'>
    readonly campaignId: FieldRef<"CampaignTimeline", 'String'>
    readonly milestoneName: FieldRef<"CampaignTimeline", 'String'>
    readonly milestoneType: FieldRef<"CampaignTimeline", 'String'>
    readonly plannedDate: FieldRef<"CampaignTimeline", 'DateTime'>
    readonly createdAt: FieldRef<"CampaignTimeline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignTimeline findUnique
   */
  export type CampaignTimelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimeline to fetch.
     */
    where: CampaignTimelineWhereUniqueInput
  }

  /**
   * CampaignTimeline findUniqueOrThrow
   */
  export type CampaignTimelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimeline to fetch.
     */
    where: CampaignTimelineWhereUniqueInput
  }

  /**
   * CampaignTimeline findFirst
   */
  export type CampaignTimelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimeline to fetch.
     */
    where?: CampaignTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTimelines to fetch.
     */
    orderBy?: CampaignTimelineOrderByWithRelationInput | CampaignTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTimelines.
     */
    cursor?: CampaignTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTimelines.
     */
    distinct?: CampaignTimelineScalarFieldEnum | CampaignTimelineScalarFieldEnum[]
  }

  /**
   * CampaignTimeline findFirstOrThrow
   */
  export type CampaignTimelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimeline to fetch.
     */
    where?: CampaignTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTimelines to fetch.
     */
    orderBy?: CampaignTimelineOrderByWithRelationInput | CampaignTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTimelines.
     */
    cursor?: CampaignTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTimelines.
     */
    distinct?: CampaignTimelineScalarFieldEnum | CampaignTimelineScalarFieldEnum[]
  }

  /**
   * CampaignTimeline findMany
   */
  export type CampaignTimelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTimelines to fetch.
     */
    where?: CampaignTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTimelines to fetch.
     */
    orderBy?: CampaignTimelineOrderByWithRelationInput | CampaignTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignTimelines.
     */
    cursor?: CampaignTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTimelines.
     */
    skip?: number
    distinct?: CampaignTimelineScalarFieldEnum | CampaignTimelineScalarFieldEnum[]
  }

  /**
   * CampaignTimeline create
   */
  export type CampaignTimelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignTimeline.
     */
    data: XOR<CampaignTimelineCreateInput, CampaignTimelineUncheckedCreateInput>
  }

  /**
   * CampaignTimeline createMany
   */
  export type CampaignTimelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignTimelines.
     */
    data: CampaignTimelineCreateManyInput | CampaignTimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignTimeline createManyAndReturn
   */
  export type CampaignTimelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignTimelines.
     */
    data: CampaignTimelineCreateManyInput | CampaignTimelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignTimeline update
   */
  export type CampaignTimelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignTimeline.
     */
    data: XOR<CampaignTimelineUpdateInput, CampaignTimelineUncheckedUpdateInput>
    /**
     * Choose, which CampaignTimeline to update.
     */
    where: CampaignTimelineWhereUniqueInput
  }

  /**
   * CampaignTimeline updateMany
   */
  export type CampaignTimelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignTimelines.
     */
    data: XOR<CampaignTimelineUpdateManyMutationInput, CampaignTimelineUncheckedUpdateManyInput>
    /**
     * Filter which CampaignTimelines to update
     */
    where?: CampaignTimelineWhereInput
  }

  /**
   * CampaignTimeline upsert
   */
  export type CampaignTimelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignTimeline to update in case it exists.
     */
    where: CampaignTimelineWhereUniqueInput
    /**
     * In case the CampaignTimeline found by the `where` argument doesn't exist, create a new CampaignTimeline with this data.
     */
    create: XOR<CampaignTimelineCreateInput, CampaignTimelineUncheckedCreateInput>
    /**
     * In case the CampaignTimeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignTimelineUpdateInput, CampaignTimelineUncheckedUpdateInput>
  }

  /**
   * CampaignTimeline delete
   */
  export type CampaignTimelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
    /**
     * Filter which CampaignTimeline to delete.
     */
    where: CampaignTimelineWhereUniqueInput
  }

  /**
   * CampaignTimeline deleteMany
   */
  export type CampaignTimelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignTimelines to delete
     */
    where?: CampaignTimelineWhereInput
  }

  /**
   * CampaignTimeline without action
   */
  export type CampaignTimelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTimeline
     */
    select?: CampaignTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTimelineInclude<ExtArgs> | null
  }


  /**
   * Model ComplianceChecklist
   */

  export type AggregateComplianceChecklist = {
    _count: ComplianceChecklistCountAggregateOutputType | null
    _min: ComplianceChecklistMinAggregateOutputType | null
    _max: ComplianceChecklistMaxAggregateOutputType | null
  }

  export type ComplianceChecklistMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    item: string | null
    severity: string | null
    responsibleDepartment: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ComplianceChecklistMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    item: string | null
    severity: string | null
    responsibleDepartment: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ComplianceChecklistCountAggregateOutputType = {
    id: number
    campaignId: number
    item: number
    severity: number
    responsibleDepartment: number
    status: number
    createdAt: number
    _all: number
  }


  export type ComplianceChecklistMinAggregateInputType = {
    id?: true
    campaignId?: true
    item?: true
    severity?: true
    responsibleDepartment?: true
    status?: true
    createdAt?: true
  }

  export type ComplianceChecklistMaxAggregateInputType = {
    id?: true
    campaignId?: true
    item?: true
    severity?: true
    responsibleDepartment?: true
    status?: true
    createdAt?: true
  }

  export type ComplianceChecklistCountAggregateInputType = {
    id?: true
    campaignId?: true
    item?: true
    severity?: true
    responsibleDepartment?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ComplianceChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceChecklist to aggregate.
     */
    where?: ComplianceChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceChecklists to fetch.
     */
    orderBy?: ComplianceChecklistOrderByWithRelationInput | ComplianceChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceChecklists
    **/
    _count?: true | ComplianceChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceChecklistMaxAggregateInputType
  }

  export type GetComplianceChecklistAggregateType<T extends ComplianceChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceChecklist[P]>
      : GetScalarType<T[P], AggregateComplianceChecklist[P]>
  }




  export type ComplianceChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceChecklistWhereInput
    orderBy?: ComplianceChecklistOrderByWithAggregationInput | ComplianceChecklistOrderByWithAggregationInput[]
    by: ComplianceChecklistScalarFieldEnum[] | ComplianceChecklistScalarFieldEnum
    having?: ComplianceChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceChecklistCountAggregateInputType | true
    _min?: ComplianceChecklistMinAggregateInputType
    _max?: ComplianceChecklistMaxAggregateInputType
  }

  export type ComplianceChecklistGroupByOutputType = {
    id: string
    campaignId: string
    item: string
    severity: string
    responsibleDepartment: string
    status: string
    createdAt: Date
    _count: ComplianceChecklistCountAggregateOutputType | null
    _min: ComplianceChecklistMinAggregateOutputType | null
    _max: ComplianceChecklistMaxAggregateOutputType | null
  }

  type GetComplianceChecklistGroupByPayload<T extends ComplianceChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceChecklistGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    item?: boolean
    severity?: boolean
    responsibleDepartment?: boolean
    status?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceChecklist"]>

  export type ComplianceChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    item?: boolean
    severity?: boolean
    responsibleDepartment?: boolean
    status?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceChecklist"]>

  export type ComplianceChecklistSelectScalar = {
    id?: boolean
    campaignId?: boolean
    item?: boolean
    severity?: boolean
    responsibleDepartment?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ComplianceChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ComplianceChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $ComplianceChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceChecklist"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      item: string
      severity: string
      responsibleDepartment: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["complianceChecklist"]>
    composites: {}
  }

  type ComplianceChecklistGetPayload<S extends boolean | null | undefined | ComplianceChecklistDefaultArgs> = $Result.GetResult<Prisma.$ComplianceChecklistPayload, S>

  type ComplianceChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplianceChecklistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplianceChecklistCountAggregateInputType | true
    }

  export interface ComplianceChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceChecklist'], meta: { name: 'ComplianceChecklist' } }
    /**
     * Find zero or one ComplianceChecklist that matches the filter.
     * @param {ComplianceChecklistFindUniqueArgs} args - Arguments to find a ComplianceChecklist
     * @example
     * // Get one ComplianceChecklist
     * const complianceChecklist = await prisma.complianceChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceChecklistFindUniqueArgs>(args: SelectSubset<T, ComplianceChecklistFindUniqueArgs<ExtArgs>>): Prisma__ComplianceChecklistClient<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComplianceChecklist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplianceChecklistFindUniqueOrThrowArgs} args - Arguments to find a ComplianceChecklist
     * @example
     * // Get one ComplianceChecklist
     * const complianceChecklist = await prisma.complianceChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceChecklistClient<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComplianceChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceChecklistFindFirstArgs} args - Arguments to find a ComplianceChecklist
     * @example
     * // Get one ComplianceChecklist
     * const complianceChecklist = await prisma.complianceChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceChecklistFindFirstArgs>(args?: SelectSubset<T, ComplianceChecklistFindFirstArgs<ExtArgs>>): Prisma__ComplianceChecklistClient<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComplianceChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceChecklistFindFirstOrThrowArgs} args - Arguments to find a ComplianceChecklist
     * @example
     * // Get one ComplianceChecklist
     * const complianceChecklist = await prisma.complianceChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceChecklistClient<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComplianceChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceChecklists
     * const complianceChecklists = await prisma.complianceChecklist.findMany()
     * 
     * // Get first 10 ComplianceChecklists
     * const complianceChecklists = await prisma.complianceChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceChecklistWithIdOnly = await prisma.complianceChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceChecklistFindManyArgs>(args?: SelectSubset<T, ComplianceChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComplianceChecklist.
     * @param {ComplianceChecklistCreateArgs} args - Arguments to create a ComplianceChecklist.
     * @example
     * // Create one ComplianceChecklist
     * const ComplianceChecklist = await prisma.complianceChecklist.create({
     *   data: {
     *     // ... data to create a ComplianceChecklist
     *   }
     * })
     * 
     */
    create<T extends ComplianceChecklistCreateArgs>(args: SelectSubset<T, ComplianceChecklistCreateArgs<ExtArgs>>): Prisma__ComplianceChecklistClient<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComplianceChecklists.
     * @param {ComplianceChecklistCreateManyArgs} args - Arguments to create many ComplianceChecklists.
     * @example
     * // Create many ComplianceChecklists
     * const complianceChecklist = await prisma.complianceChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceChecklistCreateManyArgs>(args?: SelectSubset<T, ComplianceChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceChecklists and returns the data saved in the database.
     * @param {ComplianceChecklistCreateManyAndReturnArgs} args - Arguments to create many ComplianceChecklists.
     * @example
     * // Create many ComplianceChecklists
     * const complianceChecklist = await prisma.complianceChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceChecklists and only return the `id`
     * const complianceChecklistWithIdOnly = await prisma.complianceChecklist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComplianceChecklist.
     * @param {ComplianceChecklistDeleteArgs} args - Arguments to delete one ComplianceChecklist.
     * @example
     * // Delete one ComplianceChecklist
     * const ComplianceChecklist = await prisma.complianceChecklist.delete({
     *   where: {
     *     // ... filter to delete one ComplianceChecklist
     *   }
     * })
     * 
     */
    delete<T extends ComplianceChecklistDeleteArgs>(args: SelectSubset<T, ComplianceChecklistDeleteArgs<ExtArgs>>): Prisma__ComplianceChecklistClient<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComplianceChecklist.
     * @param {ComplianceChecklistUpdateArgs} args - Arguments to update one ComplianceChecklist.
     * @example
     * // Update one ComplianceChecklist
     * const complianceChecklist = await prisma.complianceChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceChecklistUpdateArgs>(args: SelectSubset<T, ComplianceChecklistUpdateArgs<ExtArgs>>): Prisma__ComplianceChecklistClient<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComplianceChecklists.
     * @param {ComplianceChecklistDeleteManyArgs} args - Arguments to filter ComplianceChecklists to delete.
     * @example
     * // Delete a few ComplianceChecklists
     * const { count } = await prisma.complianceChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceChecklistDeleteManyArgs>(args?: SelectSubset<T, ComplianceChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceChecklists
     * const complianceChecklist = await prisma.complianceChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceChecklistUpdateManyArgs>(args: SelectSubset<T, ComplianceChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplianceChecklist.
     * @param {ComplianceChecklistUpsertArgs} args - Arguments to update or create a ComplianceChecklist.
     * @example
     * // Update or create a ComplianceChecklist
     * const complianceChecklist = await prisma.complianceChecklist.upsert({
     *   create: {
     *     // ... data to create a ComplianceChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceChecklist we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceChecklistUpsertArgs>(args: SelectSubset<T, ComplianceChecklistUpsertArgs<ExtArgs>>): Prisma__ComplianceChecklistClient<$Result.GetResult<Prisma.$ComplianceChecklistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComplianceChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceChecklistCountArgs} args - Arguments to filter ComplianceChecklists to count.
     * @example
     * // Count the number of ComplianceChecklists
     * const count = await prisma.complianceChecklist.count({
     *   where: {
     *     // ... the filter for the ComplianceChecklists we want to count
     *   }
     * })
    **/
    count<T extends ComplianceChecklistCountArgs>(
      args?: Subset<T, ComplianceChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceChecklistAggregateArgs>(args: Subset<T, ComplianceChecklistAggregateArgs>): Prisma.PrismaPromise<GetComplianceChecklistAggregateType<T>>

    /**
     * Group by ComplianceChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceChecklistGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceChecklist model
   */
  readonly fields: ComplianceChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceChecklist model
   */ 
  interface ComplianceChecklistFieldRefs {
    readonly id: FieldRef<"ComplianceChecklist", 'String'>
    readonly campaignId: FieldRef<"ComplianceChecklist", 'String'>
    readonly item: FieldRef<"ComplianceChecklist", 'String'>
    readonly severity: FieldRef<"ComplianceChecklist", 'String'>
    readonly responsibleDepartment: FieldRef<"ComplianceChecklist", 'String'>
    readonly status: FieldRef<"ComplianceChecklist", 'String'>
    readonly createdAt: FieldRef<"ComplianceChecklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceChecklist findUnique
   */
  export type ComplianceChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceChecklist to fetch.
     */
    where: ComplianceChecklistWhereUniqueInput
  }

  /**
   * ComplianceChecklist findUniqueOrThrow
   */
  export type ComplianceChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceChecklist to fetch.
     */
    where: ComplianceChecklistWhereUniqueInput
  }

  /**
   * ComplianceChecklist findFirst
   */
  export type ComplianceChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceChecklist to fetch.
     */
    where?: ComplianceChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceChecklists to fetch.
     */
    orderBy?: ComplianceChecklistOrderByWithRelationInput | ComplianceChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceChecklists.
     */
    cursor?: ComplianceChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceChecklists.
     */
    distinct?: ComplianceChecklistScalarFieldEnum | ComplianceChecklistScalarFieldEnum[]
  }

  /**
   * ComplianceChecklist findFirstOrThrow
   */
  export type ComplianceChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceChecklist to fetch.
     */
    where?: ComplianceChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceChecklists to fetch.
     */
    orderBy?: ComplianceChecklistOrderByWithRelationInput | ComplianceChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceChecklists.
     */
    cursor?: ComplianceChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceChecklists.
     */
    distinct?: ComplianceChecklistScalarFieldEnum | ComplianceChecklistScalarFieldEnum[]
  }

  /**
   * ComplianceChecklist findMany
   */
  export type ComplianceChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceChecklists to fetch.
     */
    where?: ComplianceChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceChecklists to fetch.
     */
    orderBy?: ComplianceChecklistOrderByWithRelationInput | ComplianceChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceChecklists.
     */
    cursor?: ComplianceChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceChecklists.
     */
    skip?: number
    distinct?: ComplianceChecklistScalarFieldEnum | ComplianceChecklistScalarFieldEnum[]
  }

  /**
   * ComplianceChecklist create
   */
  export type ComplianceChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplianceChecklist.
     */
    data: XOR<ComplianceChecklistCreateInput, ComplianceChecklistUncheckedCreateInput>
  }

  /**
   * ComplianceChecklist createMany
   */
  export type ComplianceChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceChecklists.
     */
    data: ComplianceChecklistCreateManyInput | ComplianceChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceChecklist createManyAndReturn
   */
  export type ComplianceChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComplianceChecklists.
     */
    data: ComplianceChecklistCreateManyInput | ComplianceChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceChecklist update
   */
  export type ComplianceChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplianceChecklist.
     */
    data: XOR<ComplianceChecklistUpdateInput, ComplianceChecklistUncheckedUpdateInput>
    /**
     * Choose, which ComplianceChecklist to update.
     */
    where: ComplianceChecklistWhereUniqueInput
  }

  /**
   * ComplianceChecklist updateMany
   */
  export type ComplianceChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceChecklists.
     */
    data: XOR<ComplianceChecklistUpdateManyMutationInput, ComplianceChecklistUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceChecklists to update
     */
    where?: ComplianceChecklistWhereInput
  }

  /**
   * ComplianceChecklist upsert
   */
  export type ComplianceChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplianceChecklist to update in case it exists.
     */
    where: ComplianceChecklistWhereUniqueInput
    /**
     * In case the ComplianceChecklist found by the `where` argument doesn't exist, create a new ComplianceChecklist with this data.
     */
    create: XOR<ComplianceChecklistCreateInput, ComplianceChecklistUncheckedCreateInput>
    /**
     * In case the ComplianceChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceChecklistUpdateInput, ComplianceChecklistUncheckedUpdateInput>
  }

  /**
   * ComplianceChecklist delete
   */
  export type ComplianceChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
    /**
     * Filter which ComplianceChecklist to delete.
     */
    where: ComplianceChecklistWhereUniqueInput
  }

  /**
   * ComplianceChecklist deleteMany
   */
  export type ComplianceChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceChecklists to delete
     */
    where?: ComplianceChecklistWhereInput
  }

  /**
   * ComplianceChecklist without action
   */
  export type ComplianceChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceChecklist
     */
    select?: ComplianceChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceChecklistInclude<ExtArgs> | null
  }


  /**
   * Model PromotionalMessage
   */

  export type AggregatePromotionalMessage = {
    _count: PromotionalMessageCountAggregateOutputType | null
    _min: PromotionalMessageMinAggregateOutputType | null
    _max: PromotionalMessageMaxAggregateOutputType | null
  }

  export type PromotionalMessageMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    platform: string | null
    tone: string | null
    message: string | null
    callToAction: string | null
    createdAt: Date | null
  }

  export type PromotionalMessageMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    platform: string | null
    tone: string | null
    message: string | null
    callToAction: string | null
    createdAt: Date | null
  }

  export type PromotionalMessageCountAggregateOutputType = {
    id: number
    campaignId: number
    platform: number
    tone: number
    message: number
    callToAction: number
    createdAt: number
    _all: number
  }


  export type PromotionalMessageMinAggregateInputType = {
    id?: true
    campaignId?: true
    platform?: true
    tone?: true
    message?: true
    callToAction?: true
    createdAt?: true
  }

  export type PromotionalMessageMaxAggregateInputType = {
    id?: true
    campaignId?: true
    platform?: true
    tone?: true
    message?: true
    callToAction?: true
    createdAt?: true
  }

  export type PromotionalMessageCountAggregateInputType = {
    id?: true
    campaignId?: true
    platform?: true
    tone?: true
    message?: true
    callToAction?: true
    createdAt?: true
    _all?: true
  }

  export type PromotionalMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionalMessage to aggregate.
     */
    where?: PromotionalMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionalMessages to fetch.
     */
    orderBy?: PromotionalMessageOrderByWithRelationInput | PromotionalMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionalMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionalMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionalMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionalMessages
    **/
    _count?: true | PromotionalMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionalMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionalMessageMaxAggregateInputType
  }

  export type GetPromotionalMessageAggregateType<T extends PromotionalMessageAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionalMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionalMessage[P]>
      : GetScalarType<T[P], AggregatePromotionalMessage[P]>
  }




  export type PromotionalMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionalMessageWhereInput
    orderBy?: PromotionalMessageOrderByWithAggregationInput | PromotionalMessageOrderByWithAggregationInput[]
    by: PromotionalMessageScalarFieldEnum[] | PromotionalMessageScalarFieldEnum
    having?: PromotionalMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionalMessageCountAggregateInputType | true
    _min?: PromotionalMessageMinAggregateInputType
    _max?: PromotionalMessageMaxAggregateInputType
  }

  export type PromotionalMessageGroupByOutputType = {
    id: string
    campaignId: string
    platform: string
    tone: string
    message: string
    callToAction: string
    createdAt: Date
    _count: PromotionalMessageCountAggregateOutputType | null
    _min: PromotionalMessageMinAggregateOutputType | null
    _max: PromotionalMessageMaxAggregateOutputType | null
  }

  type GetPromotionalMessageGroupByPayload<T extends PromotionalMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionalMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionalMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionalMessageGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionalMessageGroupByOutputType[P]>
        }
      >
    >


  export type PromotionalMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    platform?: boolean
    tone?: boolean
    message?: boolean
    callToAction?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionalMessage"]>

  export type PromotionalMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    platform?: boolean
    tone?: boolean
    message?: boolean
    callToAction?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionalMessage"]>

  export type PromotionalMessageSelectScalar = {
    id?: boolean
    campaignId?: boolean
    platform?: boolean
    tone?: boolean
    message?: boolean
    callToAction?: boolean
    createdAt?: boolean
  }

  export type PromotionalMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type PromotionalMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $PromotionalMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionalMessage"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      platform: string
      tone: string
      message: string
      callToAction: string
      createdAt: Date
    }, ExtArgs["result"]["promotionalMessage"]>
    composites: {}
  }

  type PromotionalMessageGetPayload<S extends boolean | null | undefined | PromotionalMessageDefaultArgs> = $Result.GetResult<Prisma.$PromotionalMessagePayload, S>

  type PromotionalMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromotionalMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromotionalMessageCountAggregateInputType | true
    }

  export interface PromotionalMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionalMessage'], meta: { name: 'PromotionalMessage' } }
    /**
     * Find zero or one PromotionalMessage that matches the filter.
     * @param {PromotionalMessageFindUniqueArgs} args - Arguments to find a PromotionalMessage
     * @example
     * // Get one PromotionalMessage
     * const promotionalMessage = await prisma.promotionalMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionalMessageFindUniqueArgs>(args: SelectSubset<T, PromotionalMessageFindUniqueArgs<ExtArgs>>): Prisma__PromotionalMessageClient<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PromotionalMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromotionalMessageFindUniqueOrThrowArgs} args - Arguments to find a PromotionalMessage
     * @example
     * // Get one PromotionalMessage
     * const promotionalMessage = await prisma.promotionalMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionalMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionalMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionalMessageClient<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PromotionalMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionalMessageFindFirstArgs} args - Arguments to find a PromotionalMessage
     * @example
     * // Get one PromotionalMessage
     * const promotionalMessage = await prisma.promotionalMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionalMessageFindFirstArgs>(args?: SelectSubset<T, PromotionalMessageFindFirstArgs<ExtArgs>>): Prisma__PromotionalMessageClient<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PromotionalMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionalMessageFindFirstOrThrowArgs} args - Arguments to find a PromotionalMessage
     * @example
     * // Get one PromotionalMessage
     * const promotionalMessage = await prisma.promotionalMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionalMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionalMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionalMessageClient<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PromotionalMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionalMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionalMessages
     * const promotionalMessages = await prisma.promotionalMessage.findMany()
     * 
     * // Get first 10 PromotionalMessages
     * const promotionalMessages = await prisma.promotionalMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionalMessageWithIdOnly = await prisma.promotionalMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionalMessageFindManyArgs>(args?: SelectSubset<T, PromotionalMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PromotionalMessage.
     * @param {PromotionalMessageCreateArgs} args - Arguments to create a PromotionalMessage.
     * @example
     * // Create one PromotionalMessage
     * const PromotionalMessage = await prisma.promotionalMessage.create({
     *   data: {
     *     // ... data to create a PromotionalMessage
     *   }
     * })
     * 
     */
    create<T extends PromotionalMessageCreateArgs>(args: SelectSubset<T, PromotionalMessageCreateArgs<ExtArgs>>): Prisma__PromotionalMessageClient<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PromotionalMessages.
     * @param {PromotionalMessageCreateManyArgs} args - Arguments to create many PromotionalMessages.
     * @example
     * // Create many PromotionalMessages
     * const promotionalMessage = await prisma.promotionalMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionalMessageCreateManyArgs>(args?: SelectSubset<T, PromotionalMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromotionalMessages and returns the data saved in the database.
     * @param {PromotionalMessageCreateManyAndReturnArgs} args - Arguments to create many PromotionalMessages.
     * @example
     * // Create many PromotionalMessages
     * const promotionalMessage = await prisma.promotionalMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromotionalMessages and only return the `id`
     * const promotionalMessageWithIdOnly = await prisma.promotionalMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionalMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionalMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PromotionalMessage.
     * @param {PromotionalMessageDeleteArgs} args - Arguments to delete one PromotionalMessage.
     * @example
     * // Delete one PromotionalMessage
     * const PromotionalMessage = await prisma.promotionalMessage.delete({
     *   where: {
     *     // ... filter to delete one PromotionalMessage
     *   }
     * })
     * 
     */
    delete<T extends PromotionalMessageDeleteArgs>(args: SelectSubset<T, PromotionalMessageDeleteArgs<ExtArgs>>): Prisma__PromotionalMessageClient<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PromotionalMessage.
     * @param {PromotionalMessageUpdateArgs} args - Arguments to update one PromotionalMessage.
     * @example
     * // Update one PromotionalMessage
     * const promotionalMessage = await prisma.promotionalMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionalMessageUpdateArgs>(args: SelectSubset<T, PromotionalMessageUpdateArgs<ExtArgs>>): Prisma__PromotionalMessageClient<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PromotionalMessages.
     * @param {PromotionalMessageDeleteManyArgs} args - Arguments to filter PromotionalMessages to delete.
     * @example
     * // Delete a few PromotionalMessages
     * const { count } = await prisma.promotionalMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionalMessageDeleteManyArgs>(args?: SelectSubset<T, PromotionalMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionalMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionalMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionalMessages
     * const promotionalMessage = await prisma.promotionalMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionalMessageUpdateManyArgs>(args: SelectSubset<T, PromotionalMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromotionalMessage.
     * @param {PromotionalMessageUpsertArgs} args - Arguments to update or create a PromotionalMessage.
     * @example
     * // Update or create a PromotionalMessage
     * const promotionalMessage = await prisma.promotionalMessage.upsert({
     *   create: {
     *     // ... data to create a PromotionalMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionalMessage we want to update
     *   }
     * })
     */
    upsert<T extends PromotionalMessageUpsertArgs>(args: SelectSubset<T, PromotionalMessageUpsertArgs<ExtArgs>>): Prisma__PromotionalMessageClient<$Result.GetResult<Prisma.$PromotionalMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PromotionalMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionalMessageCountArgs} args - Arguments to filter PromotionalMessages to count.
     * @example
     * // Count the number of PromotionalMessages
     * const count = await prisma.promotionalMessage.count({
     *   where: {
     *     // ... the filter for the PromotionalMessages we want to count
     *   }
     * })
    **/
    count<T extends PromotionalMessageCountArgs>(
      args?: Subset<T, PromotionalMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionalMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionalMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionalMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionalMessageAggregateArgs>(args: Subset<T, PromotionalMessageAggregateArgs>): Prisma.PrismaPromise<GetPromotionalMessageAggregateType<T>>

    /**
     * Group by PromotionalMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionalMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionalMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionalMessageGroupByArgs['orderBy'] }
        : { orderBy?: PromotionalMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionalMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionalMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionalMessage model
   */
  readonly fields: PromotionalMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionalMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionalMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromotionalMessage model
   */ 
  interface PromotionalMessageFieldRefs {
    readonly id: FieldRef<"PromotionalMessage", 'String'>
    readonly campaignId: FieldRef<"PromotionalMessage", 'String'>
    readonly platform: FieldRef<"PromotionalMessage", 'String'>
    readonly tone: FieldRef<"PromotionalMessage", 'String'>
    readonly message: FieldRef<"PromotionalMessage", 'String'>
    readonly callToAction: FieldRef<"PromotionalMessage", 'String'>
    readonly createdAt: FieldRef<"PromotionalMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromotionalMessage findUnique
   */
  export type PromotionalMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    /**
     * Filter, which PromotionalMessage to fetch.
     */
    where: PromotionalMessageWhereUniqueInput
  }

  /**
   * PromotionalMessage findUniqueOrThrow
   */
  export type PromotionalMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    /**
     * Filter, which PromotionalMessage to fetch.
     */
    where: PromotionalMessageWhereUniqueInput
  }

  /**
   * PromotionalMessage findFirst
   */
  export type PromotionalMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    /**
     * Filter, which PromotionalMessage to fetch.
     */
    where?: PromotionalMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionalMessages to fetch.
     */
    orderBy?: PromotionalMessageOrderByWithRelationInput | PromotionalMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionalMessages.
     */
    cursor?: PromotionalMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionalMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionalMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionalMessages.
     */
    distinct?: PromotionalMessageScalarFieldEnum | PromotionalMessageScalarFieldEnum[]
  }

  /**
   * PromotionalMessage findFirstOrThrow
   */
  export type PromotionalMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    /**
     * Filter, which PromotionalMessage to fetch.
     */
    where?: PromotionalMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionalMessages to fetch.
     */
    orderBy?: PromotionalMessageOrderByWithRelationInput | PromotionalMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionalMessages.
     */
    cursor?: PromotionalMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionalMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionalMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionalMessages.
     */
    distinct?: PromotionalMessageScalarFieldEnum | PromotionalMessageScalarFieldEnum[]
  }

  /**
   * PromotionalMessage findMany
   */
  export type PromotionalMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    /**
     * Filter, which PromotionalMessages to fetch.
     */
    where?: PromotionalMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionalMessages to fetch.
     */
    orderBy?: PromotionalMessageOrderByWithRelationInput | PromotionalMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionalMessages.
     */
    cursor?: PromotionalMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionalMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionalMessages.
     */
    skip?: number
    distinct?: PromotionalMessageScalarFieldEnum | PromotionalMessageScalarFieldEnum[]
  }

  /**
   * PromotionalMessage create
   */
  export type PromotionalMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionalMessage.
     */
    data: XOR<PromotionalMessageCreateInput, PromotionalMessageUncheckedCreateInput>
  }

  /**
   * PromotionalMessage createMany
   */
  export type PromotionalMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionalMessages.
     */
    data: PromotionalMessageCreateManyInput | PromotionalMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromotionalMessage createManyAndReturn
   */
  export type PromotionalMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PromotionalMessages.
     */
    data: PromotionalMessageCreateManyInput | PromotionalMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionalMessage update
   */
  export type PromotionalMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionalMessage.
     */
    data: XOR<PromotionalMessageUpdateInput, PromotionalMessageUncheckedUpdateInput>
    /**
     * Choose, which PromotionalMessage to update.
     */
    where: PromotionalMessageWhereUniqueInput
  }

  /**
   * PromotionalMessage updateMany
   */
  export type PromotionalMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionalMessages.
     */
    data: XOR<PromotionalMessageUpdateManyMutationInput, PromotionalMessageUncheckedUpdateManyInput>
    /**
     * Filter which PromotionalMessages to update
     */
    where?: PromotionalMessageWhereInput
  }

  /**
   * PromotionalMessage upsert
   */
  export type PromotionalMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionalMessage to update in case it exists.
     */
    where: PromotionalMessageWhereUniqueInput
    /**
     * In case the PromotionalMessage found by the `where` argument doesn't exist, create a new PromotionalMessage with this data.
     */
    create: XOR<PromotionalMessageCreateInput, PromotionalMessageUncheckedCreateInput>
    /**
     * In case the PromotionalMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionalMessageUpdateInput, PromotionalMessageUncheckedUpdateInput>
  }

  /**
   * PromotionalMessage delete
   */
  export type PromotionalMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
    /**
     * Filter which PromotionalMessage to delete.
     */
    where: PromotionalMessageWhereUniqueInput
  }

  /**
   * PromotionalMessage deleteMany
   */
  export type PromotionalMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionalMessages to delete
     */
    where?: PromotionalMessageWhereInput
  }

  /**
   * PromotionalMessage without action
   */
  export type PromotionalMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionalMessage
     */
    select?: PromotionalMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionalMessageInclude<ExtArgs> | null
  }


  /**
   * Model CreativeDesignPlan
   */

  export type AggregateCreativeDesignPlan = {
    _count: CreativeDesignPlanCountAggregateOutputType | null
    _min: CreativeDesignPlanMinAggregateOutputType | null
    _max: CreativeDesignPlanMaxAggregateOutputType | null
  }

  export type CreativeDesignPlanMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    platform: string | null
    creativeTitle: string | null
    headline: string | null
    visualTheme: string | null
    cta: string | null
    mobileOptimizationTip: string | null
    createdAt: Date | null
  }

  export type CreativeDesignPlanMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    platform: string | null
    creativeTitle: string | null
    headline: string | null
    visualTheme: string | null
    cta: string | null
    mobileOptimizationTip: string | null
    createdAt: Date | null
  }

  export type CreativeDesignPlanCountAggregateOutputType = {
    id: number
    campaignId: number
    platform: number
    creativeTitle: number
    headline: number
    visualTheme: number
    cta: number
    mobileOptimizationTip: number
    createdAt: number
    _all: number
  }


  export type CreativeDesignPlanMinAggregateInputType = {
    id?: true
    campaignId?: true
    platform?: true
    creativeTitle?: true
    headline?: true
    visualTheme?: true
    cta?: true
    mobileOptimizationTip?: true
    createdAt?: true
  }

  export type CreativeDesignPlanMaxAggregateInputType = {
    id?: true
    campaignId?: true
    platform?: true
    creativeTitle?: true
    headline?: true
    visualTheme?: true
    cta?: true
    mobileOptimizationTip?: true
    createdAt?: true
  }

  export type CreativeDesignPlanCountAggregateInputType = {
    id?: true
    campaignId?: true
    platform?: true
    creativeTitle?: true
    headline?: true
    visualTheme?: true
    cta?: true
    mobileOptimizationTip?: true
    createdAt?: true
    _all?: true
  }

  export type CreativeDesignPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreativeDesignPlan to aggregate.
     */
    where?: CreativeDesignPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeDesignPlans to fetch.
     */
    orderBy?: CreativeDesignPlanOrderByWithRelationInput | CreativeDesignPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreativeDesignPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeDesignPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeDesignPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreativeDesignPlans
    **/
    _count?: true | CreativeDesignPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreativeDesignPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreativeDesignPlanMaxAggregateInputType
  }

  export type GetCreativeDesignPlanAggregateType<T extends CreativeDesignPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateCreativeDesignPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreativeDesignPlan[P]>
      : GetScalarType<T[P], AggregateCreativeDesignPlan[P]>
  }




  export type CreativeDesignPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreativeDesignPlanWhereInput
    orderBy?: CreativeDesignPlanOrderByWithAggregationInput | CreativeDesignPlanOrderByWithAggregationInput[]
    by: CreativeDesignPlanScalarFieldEnum[] | CreativeDesignPlanScalarFieldEnum
    having?: CreativeDesignPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreativeDesignPlanCountAggregateInputType | true
    _min?: CreativeDesignPlanMinAggregateInputType
    _max?: CreativeDesignPlanMaxAggregateInputType
  }

  export type CreativeDesignPlanGroupByOutputType = {
    id: string
    campaignId: string
    platform: string
    creativeTitle: string
    headline: string
    visualTheme: string
    cta: string
    mobileOptimizationTip: string
    createdAt: Date
    _count: CreativeDesignPlanCountAggregateOutputType | null
    _min: CreativeDesignPlanMinAggregateOutputType | null
    _max: CreativeDesignPlanMaxAggregateOutputType | null
  }

  type GetCreativeDesignPlanGroupByPayload<T extends CreativeDesignPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreativeDesignPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreativeDesignPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreativeDesignPlanGroupByOutputType[P]>
            : GetScalarType<T[P], CreativeDesignPlanGroupByOutputType[P]>
        }
      >
    >


  export type CreativeDesignPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    platform?: boolean
    creativeTitle?: boolean
    headline?: boolean
    visualTheme?: boolean
    cta?: boolean
    mobileOptimizationTip?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creativeDesignPlan"]>

  export type CreativeDesignPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    platform?: boolean
    creativeTitle?: boolean
    headline?: boolean
    visualTheme?: boolean
    cta?: boolean
    mobileOptimizationTip?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creativeDesignPlan"]>

  export type CreativeDesignPlanSelectScalar = {
    id?: boolean
    campaignId?: boolean
    platform?: boolean
    creativeTitle?: boolean
    headline?: boolean
    visualTheme?: boolean
    cta?: boolean
    mobileOptimizationTip?: boolean
    createdAt?: boolean
  }

  export type CreativeDesignPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CreativeDesignPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CreativeDesignPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreativeDesignPlan"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      platform: string
      creativeTitle: string
      headline: string
      visualTheme: string
      cta: string
      mobileOptimizationTip: string
      createdAt: Date
    }, ExtArgs["result"]["creativeDesignPlan"]>
    composites: {}
  }

  type CreativeDesignPlanGetPayload<S extends boolean | null | undefined | CreativeDesignPlanDefaultArgs> = $Result.GetResult<Prisma.$CreativeDesignPlanPayload, S>

  type CreativeDesignPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreativeDesignPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreativeDesignPlanCountAggregateInputType | true
    }

  export interface CreativeDesignPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreativeDesignPlan'], meta: { name: 'CreativeDesignPlan' } }
    /**
     * Find zero or one CreativeDesignPlan that matches the filter.
     * @param {CreativeDesignPlanFindUniqueArgs} args - Arguments to find a CreativeDesignPlan
     * @example
     * // Get one CreativeDesignPlan
     * const creativeDesignPlan = await prisma.creativeDesignPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreativeDesignPlanFindUniqueArgs>(args: SelectSubset<T, CreativeDesignPlanFindUniqueArgs<ExtArgs>>): Prisma__CreativeDesignPlanClient<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CreativeDesignPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreativeDesignPlanFindUniqueOrThrowArgs} args - Arguments to find a CreativeDesignPlan
     * @example
     * // Get one CreativeDesignPlan
     * const creativeDesignPlan = await prisma.creativeDesignPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreativeDesignPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, CreativeDesignPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreativeDesignPlanClient<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CreativeDesignPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeDesignPlanFindFirstArgs} args - Arguments to find a CreativeDesignPlan
     * @example
     * // Get one CreativeDesignPlan
     * const creativeDesignPlan = await prisma.creativeDesignPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreativeDesignPlanFindFirstArgs>(args?: SelectSubset<T, CreativeDesignPlanFindFirstArgs<ExtArgs>>): Prisma__CreativeDesignPlanClient<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CreativeDesignPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeDesignPlanFindFirstOrThrowArgs} args - Arguments to find a CreativeDesignPlan
     * @example
     * // Get one CreativeDesignPlan
     * const creativeDesignPlan = await prisma.creativeDesignPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreativeDesignPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, CreativeDesignPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreativeDesignPlanClient<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CreativeDesignPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeDesignPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreativeDesignPlans
     * const creativeDesignPlans = await prisma.creativeDesignPlan.findMany()
     * 
     * // Get first 10 CreativeDesignPlans
     * const creativeDesignPlans = await prisma.creativeDesignPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creativeDesignPlanWithIdOnly = await prisma.creativeDesignPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreativeDesignPlanFindManyArgs>(args?: SelectSubset<T, CreativeDesignPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CreativeDesignPlan.
     * @param {CreativeDesignPlanCreateArgs} args - Arguments to create a CreativeDesignPlan.
     * @example
     * // Create one CreativeDesignPlan
     * const CreativeDesignPlan = await prisma.creativeDesignPlan.create({
     *   data: {
     *     // ... data to create a CreativeDesignPlan
     *   }
     * })
     * 
     */
    create<T extends CreativeDesignPlanCreateArgs>(args: SelectSubset<T, CreativeDesignPlanCreateArgs<ExtArgs>>): Prisma__CreativeDesignPlanClient<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CreativeDesignPlans.
     * @param {CreativeDesignPlanCreateManyArgs} args - Arguments to create many CreativeDesignPlans.
     * @example
     * // Create many CreativeDesignPlans
     * const creativeDesignPlan = await prisma.creativeDesignPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreativeDesignPlanCreateManyArgs>(args?: SelectSubset<T, CreativeDesignPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreativeDesignPlans and returns the data saved in the database.
     * @param {CreativeDesignPlanCreateManyAndReturnArgs} args - Arguments to create many CreativeDesignPlans.
     * @example
     * // Create many CreativeDesignPlans
     * const creativeDesignPlan = await prisma.creativeDesignPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreativeDesignPlans and only return the `id`
     * const creativeDesignPlanWithIdOnly = await prisma.creativeDesignPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreativeDesignPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, CreativeDesignPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CreativeDesignPlan.
     * @param {CreativeDesignPlanDeleteArgs} args - Arguments to delete one CreativeDesignPlan.
     * @example
     * // Delete one CreativeDesignPlan
     * const CreativeDesignPlan = await prisma.creativeDesignPlan.delete({
     *   where: {
     *     // ... filter to delete one CreativeDesignPlan
     *   }
     * })
     * 
     */
    delete<T extends CreativeDesignPlanDeleteArgs>(args: SelectSubset<T, CreativeDesignPlanDeleteArgs<ExtArgs>>): Prisma__CreativeDesignPlanClient<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CreativeDesignPlan.
     * @param {CreativeDesignPlanUpdateArgs} args - Arguments to update one CreativeDesignPlan.
     * @example
     * // Update one CreativeDesignPlan
     * const creativeDesignPlan = await prisma.creativeDesignPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreativeDesignPlanUpdateArgs>(args: SelectSubset<T, CreativeDesignPlanUpdateArgs<ExtArgs>>): Prisma__CreativeDesignPlanClient<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CreativeDesignPlans.
     * @param {CreativeDesignPlanDeleteManyArgs} args - Arguments to filter CreativeDesignPlans to delete.
     * @example
     * // Delete a few CreativeDesignPlans
     * const { count } = await prisma.creativeDesignPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreativeDesignPlanDeleteManyArgs>(args?: SelectSubset<T, CreativeDesignPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreativeDesignPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeDesignPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreativeDesignPlans
     * const creativeDesignPlan = await prisma.creativeDesignPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreativeDesignPlanUpdateManyArgs>(args: SelectSubset<T, CreativeDesignPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreativeDesignPlan.
     * @param {CreativeDesignPlanUpsertArgs} args - Arguments to update or create a CreativeDesignPlan.
     * @example
     * // Update or create a CreativeDesignPlan
     * const creativeDesignPlan = await prisma.creativeDesignPlan.upsert({
     *   create: {
     *     // ... data to create a CreativeDesignPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreativeDesignPlan we want to update
     *   }
     * })
     */
    upsert<T extends CreativeDesignPlanUpsertArgs>(args: SelectSubset<T, CreativeDesignPlanUpsertArgs<ExtArgs>>): Prisma__CreativeDesignPlanClient<$Result.GetResult<Prisma.$CreativeDesignPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CreativeDesignPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeDesignPlanCountArgs} args - Arguments to filter CreativeDesignPlans to count.
     * @example
     * // Count the number of CreativeDesignPlans
     * const count = await prisma.creativeDesignPlan.count({
     *   where: {
     *     // ... the filter for the CreativeDesignPlans we want to count
     *   }
     * })
    **/
    count<T extends CreativeDesignPlanCountArgs>(
      args?: Subset<T, CreativeDesignPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreativeDesignPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreativeDesignPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeDesignPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreativeDesignPlanAggregateArgs>(args: Subset<T, CreativeDesignPlanAggregateArgs>): Prisma.PrismaPromise<GetCreativeDesignPlanAggregateType<T>>

    /**
     * Group by CreativeDesignPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeDesignPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreativeDesignPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreativeDesignPlanGroupByArgs['orderBy'] }
        : { orderBy?: CreativeDesignPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreativeDesignPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreativeDesignPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreativeDesignPlan model
   */
  readonly fields: CreativeDesignPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreativeDesignPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreativeDesignPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreativeDesignPlan model
   */ 
  interface CreativeDesignPlanFieldRefs {
    readonly id: FieldRef<"CreativeDesignPlan", 'String'>
    readonly campaignId: FieldRef<"CreativeDesignPlan", 'String'>
    readonly platform: FieldRef<"CreativeDesignPlan", 'String'>
    readonly creativeTitle: FieldRef<"CreativeDesignPlan", 'String'>
    readonly headline: FieldRef<"CreativeDesignPlan", 'String'>
    readonly visualTheme: FieldRef<"CreativeDesignPlan", 'String'>
    readonly cta: FieldRef<"CreativeDesignPlan", 'String'>
    readonly mobileOptimizationTip: FieldRef<"CreativeDesignPlan", 'String'>
    readonly createdAt: FieldRef<"CreativeDesignPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreativeDesignPlan findUnique
   */
  export type CreativeDesignPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreativeDesignPlan to fetch.
     */
    where: CreativeDesignPlanWhereUniqueInput
  }

  /**
   * CreativeDesignPlan findUniqueOrThrow
   */
  export type CreativeDesignPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreativeDesignPlan to fetch.
     */
    where: CreativeDesignPlanWhereUniqueInput
  }

  /**
   * CreativeDesignPlan findFirst
   */
  export type CreativeDesignPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreativeDesignPlan to fetch.
     */
    where?: CreativeDesignPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeDesignPlans to fetch.
     */
    orderBy?: CreativeDesignPlanOrderByWithRelationInput | CreativeDesignPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreativeDesignPlans.
     */
    cursor?: CreativeDesignPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeDesignPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeDesignPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreativeDesignPlans.
     */
    distinct?: CreativeDesignPlanScalarFieldEnum | CreativeDesignPlanScalarFieldEnum[]
  }

  /**
   * CreativeDesignPlan findFirstOrThrow
   */
  export type CreativeDesignPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreativeDesignPlan to fetch.
     */
    where?: CreativeDesignPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeDesignPlans to fetch.
     */
    orderBy?: CreativeDesignPlanOrderByWithRelationInput | CreativeDesignPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreativeDesignPlans.
     */
    cursor?: CreativeDesignPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeDesignPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeDesignPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreativeDesignPlans.
     */
    distinct?: CreativeDesignPlanScalarFieldEnum | CreativeDesignPlanScalarFieldEnum[]
  }

  /**
   * CreativeDesignPlan findMany
   */
  export type CreativeDesignPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreativeDesignPlans to fetch.
     */
    where?: CreativeDesignPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeDesignPlans to fetch.
     */
    orderBy?: CreativeDesignPlanOrderByWithRelationInput | CreativeDesignPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreativeDesignPlans.
     */
    cursor?: CreativeDesignPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeDesignPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeDesignPlans.
     */
    skip?: number
    distinct?: CreativeDesignPlanScalarFieldEnum | CreativeDesignPlanScalarFieldEnum[]
  }

  /**
   * CreativeDesignPlan create
   */
  export type CreativeDesignPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a CreativeDesignPlan.
     */
    data: XOR<CreativeDesignPlanCreateInput, CreativeDesignPlanUncheckedCreateInput>
  }

  /**
   * CreativeDesignPlan createMany
   */
  export type CreativeDesignPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreativeDesignPlans.
     */
    data: CreativeDesignPlanCreateManyInput | CreativeDesignPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreativeDesignPlan createManyAndReturn
   */
  export type CreativeDesignPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CreativeDesignPlans.
     */
    data: CreativeDesignPlanCreateManyInput | CreativeDesignPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreativeDesignPlan update
   */
  export type CreativeDesignPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a CreativeDesignPlan.
     */
    data: XOR<CreativeDesignPlanUpdateInput, CreativeDesignPlanUncheckedUpdateInput>
    /**
     * Choose, which CreativeDesignPlan to update.
     */
    where: CreativeDesignPlanWhereUniqueInput
  }

  /**
   * CreativeDesignPlan updateMany
   */
  export type CreativeDesignPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreativeDesignPlans.
     */
    data: XOR<CreativeDesignPlanUpdateManyMutationInput, CreativeDesignPlanUncheckedUpdateManyInput>
    /**
     * Filter which CreativeDesignPlans to update
     */
    where?: CreativeDesignPlanWhereInput
  }

  /**
   * CreativeDesignPlan upsert
   */
  export type CreativeDesignPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the CreativeDesignPlan to update in case it exists.
     */
    where: CreativeDesignPlanWhereUniqueInput
    /**
     * In case the CreativeDesignPlan found by the `where` argument doesn't exist, create a new CreativeDesignPlan with this data.
     */
    create: XOR<CreativeDesignPlanCreateInput, CreativeDesignPlanUncheckedCreateInput>
    /**
     * In case the CreativeDesignPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreativeDesignPlanUpdateInput, CreativeDesignPlanUncheckedUpdateInput>
  }

  /**
   * CreativeDesignPlan delete
   */
  export type CreativeDesignPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
    /**
     * Filter which CreativeDesignPlan to delete.
     */
    where: CreativeDesignPlanWhereUniqueInput
  }

  /**
   * CreativeDesignPlan deleteMany
   */
  export type CreativeDesignPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreativeDesignPlans to delete
     */
    where?: CreativeDesignPlanWhereInput
  }

  /**
   * CreativeDesignPlan without action
   */
  export type CreativeDesignPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeDesignPlan
     */
    select?: CreativeDesignPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeDesignPlanInclude<ExtArgs> | null
  }


  /**
   * Model CreativeAsset
   */

  export type AggregateCreativeAsset = {
    _count: CreativeAssetCountAggregateOutputType | null
    _min: CreativeAssetMinAggregateOutputType | null
    _max: CreativeAssetMaxAggregateOutputType | null
  }

  export type CreativeAssetMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
    assetUrl: string | null
    createdAt: Date | null
  }

  export type CreativeAssetMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
    assetUrl: string | null
    createdAt: Date | null
  }

  export type CreativeAssetCountAggregateOutputType = {
    id: number
    campaignId: number
    type: number
    assetUrl: number
    createdAt: number
    _all: number
  }


  export type CreativeAssetMinAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    assetUrl?: true
    createdAt?: true
  }

  export type CreativeAssetMaxAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    assetUrl?: true
    createdAt?: true
  }

  export type CreativeAssetCountAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    assetUrl?: true
    createdAt?: true
    _all?: true
  }

  export type CreativeAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreativeAsset to aggregate.
     */
    where?: CreativeAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeAssets to fetch.
     */
    orderBy?: CreativeAssetOrderByWithRelationInput | CreativeAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreativeAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreativeAssets
    **/
    _count?: true | CreativeAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreativeAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreativeAssetMaxAggregateInputType
  }

  export type GetCreativeAssetAggregateType<T extends CreativeAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateCreativeAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreativeAsset[P]>
      : GetScalarType<T[P], AggregateCreativeAsset[P]>
  }




  export type CreativeAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreativeAssetWhereInput
    orderBy?: CreativeAssetOrderByWithAggregationInput | CreativeAssetOrderByWithAggregationInput[]
    by: CreativeAssetScalarFieldEnum[] | CreativeAssetScalarFieldEnum
    having?: CreativeAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreativeAssetCountAggregateInputType | true
    _min?: CreativeAssetMinAggregateInputType
    _max?: CreativeAssetMaxAggregateInputType
  }

  export type CreativeAssetGroupByOutputType = {
    id: string
    campaignId: string
    type: string
    assetUrl: string
    createdAt: Date
    _count: CreativeAssetCountAggregateOutputType | null
    _min: CreativeAssetMinAggregateOutputType | null
    _max: CreativeAssetMaxAggregateOutputType | null
  }

  type GetCreativeAssetGroupByPayload<T extends CreativeAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreativeAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreativeAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreativeAssetGroupByOutputType[P]>
            : GetScalarType<T[P], CreativeAssetGroupByOutputType[P]>
        }
      >
    >


  export type CreativeAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    assetUrl?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creativeAsset"]>

  export type CreativeAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    assetUrl?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creativeAsset"]>

  export type CreativeAssetSelectScalar = {
    id?: boolean
    campaignId?: boolean
    type?: boolean
    assetUrl?: boolean
    createdAt?: boolean
  }

  export type CreativeAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CreativeAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CreativeAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreativeAsset"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      type: string
      assetUrl: string
      createdAt: Date
    }, ExtArgs["result"]["creativeAsset"]>
    composites: {}
  }

  type CreativeAssetGetPayload<S extends boolean | null | undefined | CreativeAssetDefaultArgs> = $Result.GetResult<Prisma.$CreativeAssetPayload, S>

  type CreativeAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreativeAssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreativeAssetCountAggregateInputType | true
    }

  export interface CreativeAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreativeAsset'], meta: { name: 'CreativeAsset' } }
    /**
     * Find zero or one CreativeAsset that matches the filter.
     * @param {CreativeAssetFindUniqueArgs} args - Arguments to find a CreativeAsset
     * @example
     * // Get one CreativeAsset
     * const creativeAsset = await prisma.creativeAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreativeAssetFindUniqueArgs>(args: SelectSubset<T, CreativeAssetFindUniqueArgs<ExtArgs>>): Prisma__CreativeAssetClient<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CreativeAsset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreativeAssetFindUniqueOrThrowArgs} args - Arguments to find a CreativeAsset
     * @example
     * // Get one CreativeAsset
     * const creativeAsset = await prisma.creativeAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreativeAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, CreativeAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreativeAssetClient<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CreativeAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeAssetFindFirstArgs} args - Arguments to find a CreativeAsset
     * @example
     * // Get one CreativeAsset
     * const creativeAsset = await prisma.creativeAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreativeAssetFindFirstArgs>(args?: SelectSubset<T, CreativeAssetFindFirstArgs<ExtArgs>>): Prisma__CreativeAssetClient<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CreativeAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeAssetFindFirstOrThrowArgs} args - Arguments to find a CreativeAsset
     * @example
     * // Get one CreativeAsset
     * const creativeAsset = await prisma.creativeAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreativeAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, CreativeAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreativeAssetClient<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CreativeAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreativeAssets
     * const creativeAssets = await prisma.creativeAsset.findMany()
     * 
     * // Get first 10 CreativeAssets
     * const creativeAssets = await prisma.creativeAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creativeAssetWithIdOnly = await prisma.creativeAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreativeAssetFindManyArgs>(args?: SelectSubset<T, CreativeAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CreativeAsset.
     * @param {CreativeAssetCreateArgs} args - Arguments to create a CreativeAsset.
     * @example
     * // Create one CreativeAsset
     * const CreativeAsset = await prisma.creativeAsset.create({
     *   data: {
     *     // ... data to create a CreativeAsset
     *   }
     * })
     * 
     */
    create<T extends CreativeAssetCreateArgs>(args: SelectSubset<T, CreativeAssetCreateArgs<ExtArgs>>): Prisma__CreativeAssetClient<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CreativeAssets.
     * @param {CreativeAssetCreateManyArgs} args - Arguments to create many CreativeAssets.
     * @example
     * // Create many CreativeAssets
     * const creativeAsset = await prisma.creativeAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreativeAssetCreateManyArgs>(args?: SelectSubset<T, CreativeAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreativeAssets and returns the data saved in the database.
     * @param {CreativeAssetCreateManyAndReturnArgs} args - Arguments to create many CreativeAssets.
     * @example
     * // Create many CreativeAssets
     * const creativeAsset = await prisma.creativeAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreativeAssets and only return the `id`
     * const creativeAssetWithIdOnly = await prisma.creativeAsset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreativeAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, CreativeAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CreativeAsset.
     * @param {CreativeAssetDeleteArgs} args - Arguments to delete one CreativeAsset.
     * @example
     * // Delete one CreativeAsset
     * const CreativeAsset = await prisma.creativeAsset.delete({
     *   where: {
     *     // ... filter to delete one CreativeAsset
     *   }
     * })
     * 
     */
    delete<T extends CreativeAssetDeleteArgs>(args: SelectSubset<T, CreativeAssetDeleteArgs<ExtArgs>>): Prisma__CreativeAssetClient<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CreativeAsset.
     * @param {CreativeAssetUpdateArgs} args - Arguments to update one CreativeAsset.
     * @example
     * // Update one CreativeAsset
     * const creativeAsset = await prisma.creativeAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreativeAssetUpdateArgs>(args: SelectSubset<T, CreativeAssetUpdateArgs<ExtArgs>>): Prisma__CreativeAssetClient<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CreativeAssets.
     * @param {CreativeAssetDeleteManyArgs} args - Arguments to filter CreativeAssets to delete.
     * @example
     * // Delete a few CreativeAssets
     * const { count } = await prisma.creativeAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreativeAssetDeleteManyArgs>(args?: SelectSubset<T, CreativeAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreativeAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreativeAssets
     * const creativeAsset = await prisma.creativeAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreativeAssetUpdateManyArgs>(args: SelectSubset<T, CreativeAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreativeAsset.
     * @param {CreativeAssetUpsertArgs} args - Arguments to update or create a CreativeAsset.
     * @example
     * // Update or create a CreativeAsset
     * const creativeAsset = await prisma.creativeAsset.upsert({
     *   create: {
     *     // ... data to create a CreativeAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreativeAsset we want to update
     *   }
     * })
     */
    upsert<T extends CreativeAssetUpsertArgs>(args: SelectSubset<T, CreativeAssetUpsertArgs<ExtArgs>>): Prisma__CreativeAssetClient<$Result.GetResult<Prisma.$CreativeAssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CreativeAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeAssetCountArgs} args - Arguments to filter CreativeAssets to count.
     * @example
     * // Count the number of CreativeAssets
     * const count = await prisma.creativeAsset.count({
     *   where: {
     *     // ... the filter for the CreativeAssets we want to count
     *   }
     * })
    **/
    count<T extends CreativeAssetCountArgs>(
      args?: Subset<T, CreativeAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreativeAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreativeAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreativeAssetAggregateArgs>(args: Subset<T, CreativeAssetAggregateArgs>): Prisma.PrismaPromise<GetCreativeAssetAggregateType<T>>

    /**
     * Group by CreativeAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreativeAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreativeAssetGroupByArgs['orderBy'] }
        : { orderBy?: CreativeAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreativeAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreativeAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreativeAsset model
   */
  readonly fields: CreativeAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreativeAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreativeAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreativeAsset model
   */ 
  interface CreativeAssetFieldRefs {
    readonly id: FieldRef<"CreativeAsset", 'String'>
    readonly campaignId: FieldRef<"CreativeAsset", 'String'>
    readonly type: FieldRef<"CreativeAsset", 'String'>
    readonly assetUrl: FieldRef<"CreativeAsset", 'String'>
    readonly createdAt: FieldRef<"CreativeAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreativeAsset findUnique
   */
  export type CreativeAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which CreativeAsset to fetch.
     */
    where: CreativeAssetWhereUniqueInput
  }

  /**
   * CreativeAsset findUniqueOrThrow
   */
  export type CreativeAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which CreativeAsset to fetch.
     */
    where: CreativeAssetWhereUniqueInput
  }

  /**
   * CreativeAsset findFirst
   */
  export type CreativeAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which CreativeAsset to fetch.
     */
    where?: CreativeAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeAssets to fetch.
     */
    orderBy?: CreativeAssetOrderByWithRelationInput | CreativeAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreativeAssets.
     */
    cursor?: CreativeAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreativeAssets.
     */
    distinct?: CreativeAssetScalarFieldEnum | CreativeAssetScalarFieldEnum[]
  }

  /**
   * CreativeAsset findFirstOrThrow
   */
  export type CreativeAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which CreativeAsset to fetch.
     */
    where?: CreativeAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeAssets to fetch.
     */
    orderBy?: CreativeAssetOrderByWithRelationInput | CreativeAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreativeAssets.
     */
    cursor?: CreativeAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreativeAssets.
     */
    distinct?: CreativeAssetScalarFieldEnum | CreativeAssetScalarFieldEnum[]
  }

  /**
   * CreativeAsset findMany
   */
  export type CreativeAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which CreativeAssets to fetch.
     */
    where?: CreativeAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreativeAssets to fetch.
     */
    orderBy?: CreativeAssetOrderByWithRelationInput | CreativeAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreativeAssets.
     */
    cursor?: CreativeAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreativeAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreativeAssets.
     */
    skip?: number
    distinct?: CreativeAssetScalarFieldEnum | CreativeAssetScalarFieldEnum[]
  }

  /**
   * CreativeAsset create
   */
  export type CreativeAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a CreativeAsset.
     */
    data: XOR<CreativeAssetCreateInput, CreativeAssetUncheckedCreateInput>
  }

  /**
   * CreativeAsset createMany
   */
  export type CreativeAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreativeAssets.
     */
    data: CreativeAssetCreateManyInput | CreativeAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreativeAsset createManyAndReturn
   */
  export type CreativeAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CreativeAssets.
     */
    data: CreativeAssetCreateManyInput | CreativeAssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreativeAsset update
   */
  export type CreativeAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a CreativeAsset.
     */
    data: XOR<CreativeAssetUpdateInput, CreativeAssetUncheckedUpdateInput>
    /**
     * Choose, which CreativeAsset to update.
     */
    where: CreativeAssetWhereUniqueInput
  }

  /**
   * CreativeAsset updateMany
   */
  export type CreativeAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreativeAssets.
     */
    data: XOR<CreativeAssetUpdateManyMutationInput, CreativeAssetUncheckedUpdateManyInput>
    /**
     * Filter which CreativeAssets to update
     */
    where?: CreativeAssetWhereInput
  }

  /**
   * CreativeAsset upsert
   */
  export type CreativeAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the CreativeAsset to update in case it exists.
     */
    where: CreativeAssetWhereUniqueInput
    /**
     * In case the CreativeAsset found by the `where` argument doesn't exist, create a new CreativeAsset with this data.
     */
    create: XOR<CreativeAssetCreateInput, CreativeAssetUncheckedCreateInput>
    /**
     * In case the CreativeAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreativeAssetUpdateInput, CreativeAssetUncheckedUpdateInput>
  }

  /**
   * CreativeAsset delete
   */
  export type CreativeAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
    /**
     * Filter which CreativeAsset to delete.
     */
    where: CreativeAssetWhereUniqueInput
  }

  /**
   * CreativeAsset deleteMany
   */
  export type CreativeAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreativeAssets to delete
     */
    where?: CreativeAssetWhereInput
  }

  /**
   * CreativeAsset without action
   */
  export type CreativeAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreativeAsset
     */
    select?: CreativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeAssetInclude<ExtArgs> | null
  }


  /**
   * Model MediaAsset
   */

  export type AggregateMediaAsset = {
    _count: MediaAssetCountAggregateOutputType | null
    _min: MediaAssetMinAggregateOutputType | null
    _max: MediaAssetMaxAggregateOutputType | null
  }

  export type MediaAssetMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
    title: string | null
    concept: string | null
    engagementTip: string | null
    mobileOptimizationTip: string | null
    url: string | null
    createdAt: Date | null
  }

  export type MediaAssetMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
    title: string | null
    concept: string | null
    engagementTip: string | null
    mobileOptimizationTip: string | null
    url: string | null
    createdAt: Date | null
  }

  export type MediaAssetCountAggregateOutputType = {
    id: number
    campaignId: number
    type: number
    title: number
    concept: number
    engagementTip: number
    mobileOptimizationTip: number
    url: number
    createdAt: number
    _all: number
  }


  export type MediaAssetMinAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    title?: true
    concept?: true
    engagementTip?: true
    mobileOptimizationTip?: true
    url?: true
    createdAt?: true
  }

  export type MediaAssetMaxAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    title?: true
    concept?: true
    engagementTip?: true
    mobileOptimizationTip?: true
    url?: true
    createdAt?: true
  }

  export type MediaAssetCountAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    title?: true
    concept?: true
    engagementTip?: true
    mobileOptimizationTip?: true
    url?: true
    createdAt?: true
    _all?: true
  }

  export type MediaAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAsset to aggregate.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaAssets
    **/
    _count?: true | MediaAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaAssetMaxAggregateInputType
  }

  export type GetMediaAssetAggregateType<T extends MediaAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaAsset[P]>
      : GetScalarType<T[P], AggregateMediaAsset[P]>
  }




  export type MediaAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAssetWhereInput
    orderBy?: MediaAssetOrderByWithAggregationInput | MediaAssetOrderByWithAggregationInput[]
    by: MediaAssetScalarFieldEnum[] | MediaAssetScalarFieldEnum
    having?: MediaAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaAssetCountAggregateInputType | true
    _min?: MediaAssetMinAggregateInputType
    _max?: MediaAssetMaxAggregateInputType
  }

  export type MediaAssetGroupByOutputType = {
    id: string
    campaignId: string
    type: string
    title: string
    concept: string
    engagementTip: string
    mobileOptimizationTip: string
    url: string | null
    createdAt: Date
    _count: MediaAssetCountAggregateOutputType | null
    _min: MediaAssetMinAggregateOutputType | null
    _max: MediaAssetMaxAggregateOutputType | null
  }

  type GetMediaAssetGroupByPayload<T extends MediaAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaAssetGroupByOutputType[P]>
            : GetScalarType<T[P], MediaAssetGroupByOutputType[P]>
        }
      >
    >


  export type MediaAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    title?: boolean
    concept?: boolean
    engagementTip?: boolean
    mobileOptimizationTip?: boolean
    url?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    title?: boolean
    concept?: boolean
    engagementTip?: boolean
    mobileOptimizationTip?: boolean
    url?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectScalar = {
    id?: boolean
    campaignId?: boolean
    type?: boolean
    title?: boolean
    concept?: boolean
    engagementTip?: boolean
    mobileOptimizationTip?: boolean
    url?: boolean
    createdAt?: boolean
  }

  export type MediaAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type MediaAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $MediaAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaAsset"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      type: string
      title: string
      concept: string
      engagementTip: string
      mobileOptimizationTip: string
      url: string | null
      createdAt: Date
    }, ExtArgs["result"]["mediaAsset"]>
    composites: {}
  }

  type MediaAssetGetPayload<S extends boolean | null | undefined | MediaAssetDefaultArgs> = $Result.GetResult<Prisma.$MediaAssetPayload, S>

  type MediaAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaAssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaAssetCountAggregateInputType | true
    }

  export interface MediaAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaAsset'], meta: { name: 'MediaAsset' } }
    /**
     * Find zero or one MediaAsset that matches the filter.
     * @param {MediaAssetFindUniqueArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaAssetFindUniqueArgs>(args: SelectSubset<T, MediaAssetFindUniqueArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaAsset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaAssetFindUniqueOrThrowArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindFirstArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaAssetFindFirstArgs>(args?: SelectSubset<T, MediaAssetFindFirstArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindFirstOrThrowArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaAssets
     * const mediaAssets = await prisma.mediaAsset.findMany()
     * 
     * // Get first 10 MediaAssets
     * const mediaAssets = await prisma.mediaAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaAssetFindManyArgs>(args?: SelectSubset<T, MediaAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaAsset.
     * @param {MediaAssetCreateArgs} args - Arguments to create a MediaAsset.
     * @example
     * // Create one MediaAsset
     * const MediaAsset = await prisma.mediaAsset.create({
     *   data: {
     *     // ... data to create a MediaAsset
     *   }
     * })
     * 
     */
    create<T extends MediaAssetCreateArgs>(args: SelectSubset<T, MediaAssetCreateArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaAssets.
     * @param {MediaAssetCreateManyArgs} args - Arguments to create many MediaAssets.
     * @example
     * // Create many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaAssetCreateManyArgs>(args?: SelectSubset<T, MediaAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaAssets and returns the data saved in the database.
     * @param {MediaAssetCreateManyAndReturnArgs} args - Arguments to create many MediaAssets.
     * @example
     * // Create many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaAssets and only return the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaAsset.
     * @param {MediaAssetDeleteArgs} args - Arguments to delete one MediaAsset.
     * @example
     * // Delete one MediaAsset
     * const MediaAsset = await prisma.mediaAsset.delete({
     *   where: {
     *     // ... filter to delete one MediaAsset
     *   }
     * })
     * 
     */
    delete<T extends MediaAssetDeleteArgs>(args: SelectSubset<T, MediaAssetDeleteArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaAsset.
     * @param {MediaAssetUpdateArgs} args - Arguments to update one MediaAsset.
     * @example
     * // Update one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaAssetUpdateArgs>(args: SelectSubset<T, MediaAssetUpdateArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaAssets.
     * @param {MediaAssetDeleteManyArgs} args - Arguments to filter MediaAssets to delete.
     * @example
     * // Delete a few MediaAssets
     * const { count } = await prisma.mediaAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaAssetDeleteManyArgs>(args?: SelectSubset<T, MediaAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaAssetUpdateManyArgs>(args: SelectSubset<T, MediaAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaAsset.
     * @param {MediaAssetUpsertArgs} args - Arguments to update or create a MediaAsset.
     * @example
     * // Update or create a MediaAsset
     * const mediaAsset = await prisma.mediaAsset.upsert({
     *   create: {
     *     // ... data to create a MediaAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaAsset we want to update
     *   }
     * })
     */
    upsert<T extends MediaAssetUpsertArgs>(args: SelectSubset<T, MediaAssetUpsertArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetCountArgs} args - Arguments to filter MediaAssets to count.
     * @example
     * // Count the number of MediaAssets
     * const count = await prisma.mediaAsset.count({
     *   where: {
     *     // ... the filter for the MediaAssets we want to count
     *   }
     * })
    **/
    count<T extends MediaAssetCountArgs>(
      args?: Subset<T, MediaAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAssetAggregateArgs>(args: Subset<T, MediaAssetAggregateArgs>): Prisma.PrismaPromise<GetMediaAssetAggregateType<T>>

    /**
     * Group by MediaAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaAssetGroupByArgs['orderBy'] }
        : { orderBy?: MediaAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaAsset model
   */
  readonly fields: MediaAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaAsset model
   */ 
  interface MediaAssetFieldRefs {
    readonly id: FieldRef<"MediaAsset", 'String'>
    readonly campaignId: FieldRef<"MediaAsset", 'String'>
    readonly type: FieldRef<"MediaAsset", 'String'>
    readonly title: FieldRef<"MediaAsset", 'String'>
    readonly concept: FieldRef<"MediaAsset", 'String'>
    readonly engagementTip: FieldRef<"MediaAsset", 'String'>
    readonly mobileOptimizationTip: FieldRef<"MediaAsset", 'String'>
    readonly url: FieldRef<"MediaAsset", 'String'>
    readonly createdAt: FieldRef<"MediaAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaAsset findUnique
   */
  export type MediaAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset findUniqueOrThrow
   */
  export type MediaAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset findFirst
   */
  export type MediaAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAssets.
     */
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset findFirstOrThrow
   */
  export type MediaAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAssets.
     */
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset findMany
   */
  export type MediaAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAssets to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset create
   */
  export type MediaAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaAsset.
     */
    data: XOR<MediaAssetCreateInput, MediaAssetUncheckedCreateInput>
  }

  /**
   * MediaAsset createMany
   */
  export type MediaAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaAssets.
     */
    data: MediaAssetCreateManyInput | MediaAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaAsset createManyAndReturn
   */
  export type MediaAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaAssets.
     */
    data: MediaAssetCreateManyInput | MediaAssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaAsset update
   */
  export type MediaAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaAsset.
     */
    data: XOR<MediaAssetUpdateInput, MediaAssetUncheckedUpdateInput>
    /**
     * Choose, which MediaAsset to update.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset updateMany
   */
  export type MediaAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaAssets.
     */
    data: XOR<MediaAssetUpdateManyMutationInput, MediaAssetUncheckedUpdateManyInput>
    /**
     * Filter which MediaAssets to update
     */
    where?: MediaAssetWhereInput
  }

  /**
   * MediaAsset upsert
   */
  export type MediaAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaAsset to update in case it exists.
     */
    where: MediaAssetWhereUniqueInput
    /**
     * In case the MediaAsset found by the `where` argument doesn't exist, create a new MediaAsset with this data.
     */
    create: XOR<MediaAssetCreateInput, MediaAssetUncheckedCreateInput>
    /**
     * In case the MediaAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaAssetUpdateInput, MediaAssetUncheckedUpdateInput>
  }

  /**
   * MediaAsset delete
   */
  export type MediaAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter which MediaAsset to delete.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset deleteMany
   */
  export type MediaAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAssets to delete
     */
    where?: MediaAssetWhereInput
  }

  /**
   * MediaAsset without action
   */
  export type MediaAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
  }


  /**
   * Model ContentCalendar
   */

  export type AggregateContentCalendar = {
    _count: ContentCalendarCountAggregateOutputType | null
    _min: ContentCalendarMinAggregateOutputType | null
    _max: ContentCalendarMaxAggregateOutputType | null
  }

  export type ContentCalendarMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contentType: string | null
    platform: string | null
    contentRef: string | null
    scheduledFor: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type ContentCalendarMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    contentType: string | null
    platform: string | null
    contentRef: string | null
    scheduledFor: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type ContentCalendarCountAggregateOutputType = {
    id: number
    campaignId: number
    contentType: number
    platform: number
    contentRef: number
    scheduledFor: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ContentCalendarMinAggregateInputType = {
    id?: true
    campaignId?: true
    contentType?: true
    platform?: true
    contentRef?: true
    scheduledFor?: true
    notes?: true
    createdAt?: true
  }

  export type ContentCalendarMaxAggregateInputType = {
    id?: true
    campaignId?: true
    contentType?: true
    platform?: true
    contentRef?: true
    scheduledFor?: true
    notes?: true
    createdAt?: true
  }

  export type ContentCalendarCountAggregateInputType = {
    id?: true
    campaignId?: true
    contentType?: true
    platform?: true
    contentRef?: true
    scheduledFor?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ContentCalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentCalendar to aggregate.
     */
    where?: ContentCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCalendars to fetch.
     */
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentCalendars
    **/
    _count?: true | ContentCalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentCalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentCalendarMaxAggregateInputType
  }

  export type GetContentCalendarAggregateType<T extends ContentCalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateContentCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentCalendar[P]>
      : GetScalarType<T[P], AggregateContentCalendar[P]>
  }




  export type ContentCalendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCalendarWhereInput
    orderBy?: ContentCalendarOrderByWithAggregationInput | ContentCalendarOrderByWithAggregationInput[]
    by: ContentCalendarScalarFieldEnum[] | ContentCalendarScalarFieldEnum
    having?: ContentCalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCalendarCountAggregateInputType | true
    _min?: ContentCalendarMinAggregateInputType
    _max?: ContentCalendarMaxAggregateInputType
  }

  export type ContentCalendarGroupByOutputType = {
    id: string
    campaignId: string
    contentType: string
    platform: string
    contentRef: string
    scheduledFor: Date
    notes: string | null
    createdAt: Date
    _count: ContentCalendarCountAggregateOutputType | null
    _min: ContentCalendarMinAggregateOutputType | null
    _max: ContentCalendarMaxAggregateOutputType | null
  }

  type GetContentCalendarGroupByPayload<T extends ContentCalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentCalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentCalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentCalendarGroupByOutputType[P]>
            : GetScalarType<T[P], ContentCalendarGroupByOutputType[P]>
        }
      >
    >


  export type ContentCalendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contentType?: boolean
    platform?: boolean
    contentRef?: boolean
    scheduledFor?: boolean
    notes?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentCalendar"]>

  export type ContentCalendarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    contentType?: boolean
    platform?: boolean
    contentRef?: boolean
    scheduledFor?: boolean
    notes?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentCalendar"]>

  export type ContentCalendarSelectScalar = {
    id?: boolean
    campaignId?: boolean
    contentType?: boolean
    platform?: boolean
    contentRef?: boolean
    scheduledFor?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ContentCalendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ContentCalendarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $ContentCalendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentCalendar"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      contentType: string
      platform: string
      contentRef: string
      scheduledFor: Date
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["contentCalendar"]>
    composites: {}
  }

  type ContentCalendarGetPayload<S extends boolean | null | undefined | ContentCalendarDefaultArgs> = $Result.GetResult<Prisma.$ContentCalendarPayload, S>

  type ContentCalendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentCalendarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentCalendarCountAggregateInputType | true
    }

  export interface ContentCalendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentCalendar'], meta: { name: 'ContentCalendar' } }
    /**
     * Find zero or one ContentCalendar that matches the filter.
     * @param {ContentCalendarFindUniqueArgs} args - Arguments to find a ContentCalendar
     * @example
     * // Get one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentCalendarFindUniqueArgs>(args: SelectSubset<T, ContentCalendarFindUniqueArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentCalendar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentCalendarFindUniqueOrThrowArgs} args - Arguments to find a ContentCalendar
     * @example
     * // Get one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentCalendarFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentCalendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentCalendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarFindFirstArgs} args - Arguments to find a ContentCalendar
     * @example
     * // Get one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentCalendarFindFirstArgs>(args?: SelectSubset<T, ContentCalendarFindFirstArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentCalendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarFindFirstOrThrowArgs} args - Arguments to find a ContentCalendar
     * @example
     * // Get one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentCalendarFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentCalendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentCalendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentCalendars
     * const contentCalendars = await prisma.contentCalendar.findMany()
     * 
     * // Get first 10 ContentCalendars
     * const contentCalendars = await prisma.contentCalendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentCalendarWithIdOnly = await prisma.contentCalendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentCalendarFindManyArgs>(args?: SelectSubset<T, ContentCalendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentCalendar.
     * @param {ContentCalendarCreateArgs} args - Arguments to create a ContentCalendar.
     * @example
     * // Create one ContentCalendar
     * const ContentCalendar = await prisma.contentCalendar.create({
     *   data: {
     *     // ... data to create a ContentCalendar
     *   }
     * })
     * 
     */
    create<T extends ContentCalendarCreateArgs>(args: SelectSubset<T, ContentCalendarCreateArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentCalendars.
     * @param {ContentCalendarCreateManyArgs} args - Arguments to create many ContentCalendars.
     * @example
     * // Create many ContentCalendars
     * const contentCalendar = await prisma.contentCalendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCalendarCreateManyArgs>(args?: SelectSubset<T, ContentCalendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentCalendars and returns the data saved in the database.
     * @param {ContentCalendarCreateManyAndReturnArgs} args - Arguments to create many ContentCalendars.
     * @example
     * // Create many ContentCalendars
     * const contentCalendar = await prisma.contentCalendar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentCalendars and only return the `id`
     * const contentCalendarWithIdOnly = await prisma.contentCalendar.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCalendarCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCalendarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentCalendar.
     * @param {ContentCalendarDeleteArgs} args - Arguments to delete one ContentCalendar.
     * @example
     * // Delete one ContentCalendar
     * const ContentCalendar = await prisma.contentCalendar.delete({
     *   where: {
     *     // ... filter to delete one ContentCalendar
     *   }
     * })
     * 
     */
    delete<T extends ContentCalendarDeleteArgs>(args: SelectSubset<T, ContentCalendarDeleteArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentCalendar.
     * @param {ContentCalendarUpdateArgs} args - Arguments to update one ContentCalendar.
     * @example
     * // Update one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentCalendarUpdateArgs>(args: SelectSubset<T, ContentCalendarUpdateArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentCalendars.
     * @param {ContentCalendarDeleteManyArgs} args - Arguments to filter ContentCalendars to delete.
     * @example
     * // Delete a few ContentCalendars
     * const { count } = await prisma.contentCalendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentCalendarDeleteManyArgs>(args?: SelectSubset<T, ContentCalendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentCalendars
     * const contentCalendar = await prisma.contentCalendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentCalendarUpdateManyArgs>(args: SelectSubset<T, ContentCalendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentCalendar.
     * @param {ContentCalendarUpsertArgs} args - Arguments to update or create a ContentCalendar.
     * @example
     * // Update or create a ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.upsert({
     *   create: {
     *     // ... data to create a ContentCalendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentCalendar we want to update
     *   }
     * })
     */
    upsert<T extends ContentCalendarUpsertArgs>(args: SelectSubset<T, ContentCalendarUpsertArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarCountArgs} args - Arguments to filter ContentCalendars to count.
     * @example
     * // Count the number of ContentCalendars
     * const count = await prisma.contentCalendar.count({
     *   where: {
     *     // ... the filter for the ContentCalendars we want to count
     *   }
     * })
    **/
    count<T extends ContentCalendarCountArgs>(
      args?: Subset<T, ContentCalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentCalendarAggregateArgs>(args: Subset<T, ContentCalendarAggregateArgs>): Prisma.PrismaPromise<GetContentCalendarAggregateType<T>>

    /**
     * Group by ContentCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentCalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentCalendarGroupByArgs['orderBy'] }
        : { orderBy?: ContentCalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentCalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentCalendar model
   */
  readonly fields: ContentCalendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentCalendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentCalendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentCalendar model
   */ 
  interface ContentCalendarFieldRefs {
    readonly id: FieldRef<"ContentCalendar", 'String'>
    readonly campaignId: FieldRef<"ContentCalendar", 'String'>
    readonly contentType: FieldRef<"ContentCalendar", 'String'>
    readonly platform: FieldRef<"ContentCalendar", 'String'>
    readonly contentRef: FieldRef<"ContentCalendar", 'String'>
    readonly scheduledFor: FieldRef<"ContentCalendar", 'DateTime'>
    readonly notes: FieldRef<"ContentCalendar", 'String'>
    readonly createdAt: FieldRef<"ContentCalendar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentCalendar findUnique
   */
  export type ContentCalendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendar to fetch.
     */
    where: ContentCalendarWhereUniqueInput
  }

  /**
   * ContentCalendar findUniqueOrThrow
   */
  export type ContentCalendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendar to fetch.
     */
    where: ContentCalendarWhereUniqueInput
  }

  /**
   * ContentCalendar findFirst
   */
  export type ContentCalendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendar to fetch.
     */
    where?: ContentCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCalendars to fetch.
     */
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentCalendars.
     */
    cursor?: ContentCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentCalendars.
     */
    distinct?: ContentCalendarScalarFieldEnum | ContentCalendarScalarFieldEnum[]
  }

  /**
   * ContentCalendar findFirstOrThrow
   */
  export type ContentCalendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendar to fetch.
     */
    where?: ContentCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCalendars to fetch.
     */
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentCalendars.
     */
    cursor?: ContentCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentCalendars.
     */
    distinct?: ContentCalendarScalarFieldEnum | ContentCalendarScalarFieldEnum[]
  }

  /**
   * ContentCalendar findMany
   */
  export type ContentCalendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendars to fetch.
     */
    where?: ContentCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCalendars to fetch.
     */
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentCalendars.
     */
    cursor?: ContentCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCalendars.
     */
    skip?: number
    distinct?: ContentCalendarScalarFieldEnum | ContentCalendarScalarFieldEnum[]
  }

  /**
   * ContentCalendar create
   */
  export type ContentCalendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentCalendar.
     */
    data: XOR<ContentCalendarCreateInput, ContentCalendarUncheckedCreateInput>
  }

  /**
   * ContentCalendar createMany
   */
  export type ContentCalendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentCalendars.
     */
    data: ContentCalendarCreateManyInput | ContentCalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentCalendar createManyAndReturn
   */
  export type ContentCalendarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentCalendars.
     */
    data: ContentCalendarCreateManyInput | ContentCalendarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentCalendar update
   */
  export type ContentCalendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentCalendar.
     */
    data: XOR<ContentCalendarUpdateInput, ContentCalendarUncheckedUpdateInput>
    /**
     * Choose, which ContentCalendar to update.
     */
    where: ContentCalendarWhereUniqueInput
  }

  /**
   * ContentCalendar updateMany
   */
  export type ContentCalendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentCalendars.
     */
    data: XOR<ContentCalendarUpdateManyMutationInput, ContentCalendarUncheckedUpdateManyInput>
    /**
     * Filter which ContentCalendars to update
     */
    where?: ContentCalendarWhereInput
  }

  /**
   * ContentCalendar upsert
   */
  export type ContentCalendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentCalendar to update in case it exists.
     */
    where: ContentCalendarWhereUniqueInput
    /**
     * In case the ContentCalendar found by the `where` argument doesn't exist, create a new ContentCalendar with this data.
     */
    create: XOR<ContentCalendarCreateInput, ContentCalendarUncheckedCreateInput>
    /**
     * In case the ContentCalendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentCalendarUpdateInput, ContentCalendarUncheckedUpdateInput>
  }

  /**
   * ContentCalendar delete
   */
  export type ContentCalendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter which ContentCalendar to delete.
     */
    where: ContentCalendarWhereUniqueInput
  }

  /**
   * ContentCalendar deleteMany
   */
  export type ContentCalendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentCalendars to delete
     */
    where?: ContentCalendarWhereInput
  }

  /**
   * ContentCalendar without action
   */
  export type ContentCalendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
  }


  /**
   * Model TeaserContent
   */

  export type AggregateTeaserContent = {
    _count: TeaserContentCountAggregateOutputType | null
    _min: TeaserContentMinAggregateOutputType | null
    _max: TeaserContentMaxAggregateOutputType | null
  }

  export type TeaserContentMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    message: string | null
    platform: string | null
    teaserTheme: string | null
    tone: string | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type TeaserContentMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    message: string | null
    platform: string | null
    teaserTheme: string | null
    tone: string | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type TeaserContentCountAggregateOutputType = {
    id: number
    campaignId: number
    message: number
    platform: number
    teaserTheme: number
    tone: number
    scheduledAt: number
    createdAt: number
    _all: number
  }


  export type TeaserContentMinAggregateInputType = {
    id?: true
    campaignId?: true
    message?: true
    platform?: true
    teaserTheme?: true
    tone?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type TeaserContentMaxAggregateInputType = {
    id?: true
    campaignId?: true
    message?: true
    platform?: true
    teaserTheme?: true
    tone?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type TeaserContentCountAggregateInputType = {
    id?: true
    campaignId?: true
    message?: true
    platform?: true
    teaserTheme?: true
    tone?: true
    scheduledAt?: true
    createdAt?: true
    _all?: true
  }

  export type TeaserContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeaserContent to aggregate.
     */
    where?: TeaserContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeaserContents to fetch.
     */
    orderBy?: TeaserContentOrderByWithRelationInput | TeaserContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeaserContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeaserContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeaserContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeaserContents
    **/
    _count?: true | TeaserContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeaserContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeaserContentMaxAggregateInputType
  }

  export type GetTeaserContentAggregateType<T extends TeaserContentAggregateArgs> = {
        [P in keyof T & keyof AggregateTeaserContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeaserContent[P]>
      : GetScalarType<T[P], AggregateTeaserContent[P]>
  }




  export type TeaserContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeaserContentWhereInput
    orderBy?: TeaserContentOrderByWithAggregationInput | TeaserContentOrderByWithAggregationInput[]
    by: TeaserContentScalarFieldEnum[] | TeaserContentScalarFieldEnum
    having?: TeaserContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeaserContentCountAggregateInputType | true
    _min?: TeaserContentMinAggregateInputType
    _max?: TeaserContentMaxAggregateInputType
  }

  export type TeaserContentGroupByOutputType = {
    id: string
    campaignId: string
    message: string
    platform: string
    teaserTheme: string | null
    tone: string
    scheduledAt: Date
    createdAt: Date
    _count: TeaserContentCountAggregateOutputType | null
    _min: TeaserContentMinAggregateOutputType | null
    _max: TeaserContentMaxAggregateOutputType | null
  }

  type GetTeaserContentGroupByPayload<T extends TeaserContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeaserContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeaserContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeaserContentGroupByOutputType[P]>
            : GetScalarType<T[P], TeaserContentGroupByOutputType[P]>
        }
      >
    >


  export type TeaserContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    message?: boolean
    platform?: boolean
    teaserTheme?: boolean
    tone?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teaserContent"]>

  export type TeaserContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    message?: boolean
    platform?: boolean
    teaserTheme?: boolean
    tone?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teaserContent"]>

  export type TeaserContentSelectScalar = {
    id?: boolean
    campaignId?: boolean
    message?: boolean
    platform?: boolean
    teaserTheme?: boolean
    tone?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
  }

  export type TeaserContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type TeaserContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $TeaserContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeaserContent"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      message: string
      platform: string
      teaserTheme: string | null
      tone: string
      scheduledAt: Date
      createdAt: Date
    }, ExtArgs["result"]["teaserContent"]>
    composites: {}
  }

  type TeaserContentGetPayload<S extends boolean | null | undefined | TeaserContentDefaultArgs> = $Result.GetResult<Prisma.$TeaserContentPayload, S>

  type TeaserContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeaserContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeaserContentCountAggregateInputType | true
    }

  export interface TeaserContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeaserContent'], meta: { name: 'TeaserContent' } }
    /**
     * Find zero or one TeaserContent that matches the filter.
     * @param {TeaserContentFindUniqueArgs} args - Arguments to find a TeaserContent
     * @example
     * // Get one TeaserContent
     * const teaserContent = await prisma.teaserContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeaserContentFindUniqueArgs>(args: SelectSubset<T, TeaserContentFindUniqueArgs<ExtArgs>>): Prisma__TeaserContentClient<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeaserContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeaserContentFindUniqueOrThrowArgs} args - Arguments to find a TeaserContent
     * @example
     * // Get one TeaserContent
     * const teaserContent = await prisma.teaserContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeaserContentFindUniqueOrThrowArgs>(args: SelectSubset<T, TeaserContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeaserContentClient<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeaserContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeaserContentFindFirstArgs} args - Arguments to find a TeaserContent
     * @example
     * // Get one TeaserContent
     * const teaserContent = await prisma.teaserContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeaserContentFindFirstArgs>(args?: SelectSubset<T, TeaserContentFindFirstArgs<ExtArgs>>): Prisma__TeaserContentClient<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeaserContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeaserContentFindFirstOrThrowArgs} args - Arguments to find a TeaserContent
     * @example
     * // Get one TeaserContent
     * const teaserContent = await prisma.teaserContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeaserContentFindFirstOrThrowArgs>(args?: SelectSubset<T, TeaserContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeaserContentClient<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeaserContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeaserContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeaserContents
     * const teaserContents = await prisma.teaserContent.findMany()
     * 
     * // Get first 10 TeaserContents
     * const teaserContents = await prisma.teaserContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teaserContentWithIdOnly = await prisma.teaserContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeaserContentFindManyArgs>(args?: SelectSubset<T, TeaserContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeaserContent.
     * @param {TeaserContentCreateArgs} args - Arguments to create a TeaserContent.
     * @example
     * // Create one TeaserContent
     * const TeaserContent = await prisma.teaserContent.create({
     *   data: {
     *     // ... data to create a TeaserContent
     *   }
     * })
     * 
     */
    create<T extends TeaserContentCreateArgs>(args: SelectSubset<T, TeaserContentCreateArgs<ExtArgs>>): Prisma__TeaserContentClient<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeaserContents.
     * @param {TeaserContentCreateManyArgs} args - Arguments to create many TeaserContents.
     * @example
     * // Create many TeaserContents
     * const teaserContent = await prisma.teaserContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeaserContentCreateManyArgs>(args?: SelectSubset<T, TeaserContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeaserContents and returns the data saved in the database.
     * @param {TeaserContentCreateManyAndReturnArgs} args - Arguments to create many TeaserContents.
     * @example
     * // Create many TeaserContents
     * const teaserContent = await prisma.teaserContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeaserContents and only return the `id`
     * const teaserContentWithIdOnly = await prisma.teaserContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeaserContentCreateManyAndReturnArgs>(args?: SelectSubset<T, TeaserContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeaserContent.
     * @param {TeaserContentDeleteArgs} args - Arguments to delete one TeaserContent.
     * @example
     * // Delete one TeaserContent
     * const TeaserContent = await prisma.teaserContent.delete({
     *   where: {
     *     // ... filter to delete one TeaserContent
     *   }
     * })
     * 
     */
    delete<T extends TeaserContentDeleteArgs>(args: SelectSubset<T, TeaserContentDeleteArgs<ExtArgs>>): Prisma__TeaserContentClient<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeaserContent.
     * @param {TeaserContentUpdateArgs} args - Arguments to update one TeaserContent.
     * @example
     * // Update one TeaserContent
     * const teaserContent = await prisma.teaserContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeaserContentUpdateArgs>(args: SelectSubset<T, TeaserContentUpdateArgs<ExtArgs>>): Prisma__TeaserContentClient<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeaserContents.
     * @param {TeaserContentDeleteManyArgs} args - Arguments to filter TeaserContents to delete.
     * @example
     * // Delete a few TeaserContents
     * const { count } = await prisma.teaserContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeaserContentDeleteManyArgs>(args?: SelectSubset<T, TeaserContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeaserContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeaserContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeaserContents
     * const teaserContent = await prisma.teaserContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeaserContentUpdateManyArgs>(args: SelectSubset<T, TeaserContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeaserContent.
     * @param {TeaserContentUpsertArgs} args - Arguments to update or create a TeaserContent.
     * @example
     * // Update or create a TeaserContent
     * const teaserContent = await prisma.teaserContent.upsert({
     *   create: {
     *     // ... data to create a TeaserContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeaserContent we want to update
     *   }
     * })
     */
    upsert<T extends TeaserContentUpsertArgs>(args: SelectSubset<T, TeaserContentUpsertArgs<ExtArgs>>): Prisma__TeaserContentClient<$Result.GetResult<Prisma.$TeaserContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeaserContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeaserContentCountArgs} args - Arguments to filter TeaserContents to count.
     * @example
     * // Count the number of TeaserContents
     * const count = await prisma.teaserContent.count({
     *   where: {
     *     // ... the filter for the TeaserContents we want to count
     *   }
     * })
    **/
    count<T extends TeaserContentCountArgs>(
      args?: Subset<T, TeaserContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeaserContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeaserContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeaserContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeaserContentAggregateArgs>(args: Subset<T, TeaserContentAggregateArgs>): Prisma.PrismaPromise<GetTeaserContentAggregateType<T>>

    /**
     * Group by TeaserContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeaserContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeaserContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeaserContentGroupByArgs['orderBy'] }
        : { orderBy?: TeaserContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeaserContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeaserContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeaserContent model
   */
  readonly fields: TeaserContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeaserContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeaserContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeaserContent model
   */ 
  interface TeaserContentFieldRefs {
    readonly id: FieldRef<"TeaserContent", 'String'>
    readonly campaignId: FieldRef<"TeaserContent", 'String'>
    readonly message: FieldRef<"TeaserContent", 'String'>
    readonly platform: FieldRef<"TeaserContent", 'String'>
    readonly teaserTheme: FieldRef<"TeaserContent", 'String'>
    readonly tone: FieldRef<"TeaserContent", 'String'>
    readonly scheduledAt: FieldRef<"TeaserContent", 'DateTime'>
    readonly createdAt: FieldRef<"TeaserContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeaserContent findUnique
   */
  export type TeaserContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    /**
     * Filter, which TeaserContent to fetch.
     */
    where: TeaserContentWhereUniqueInput
  }

  /**
   * TeaserContent findUniqueOrThrow
   */
  export type TeaserContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    /**
     * Filter, which TeaserContent to fetch.
     */
    where: TeaserContentWhereUniqueInput
  }

  /**
   * TeaserContent findFirst
   */
  export type TeaserContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    /**
     * Filter, which TeaserContent to fetch.
     */
    where?: TeaserContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeaserContents to fetch.
     */
    orderBy?: TeaserContentOrderByWithRelationInput | TeaserContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeaserContents.
     */
    cursor?: TeaserContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeaserContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeaserContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeaserContents.
     */
    distinct?: TeaserContentScalarFieldEnum | TeaserContentScalarFieldEnum[]
  }

  /**
   * TeaserContent findFirstOrThrow
   */
  export type TeaserContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    /**
     * Filter, which TeaserContent to fetch.
     */
    where?: TeaserContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeaserContents to fetch.
     */
    orderBy?: TeaserContentOrderByWithRelationInput | TeaserContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeaserContents.
     */
    cursor?: TeaserContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeaserContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeaserContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeaserContents.
     */
    distinct?: TeaserContentScalarFieldEnum | TeaserContentScalarFieldEnum[]
  }

  /**
   * TeaserContent findMany
   */
  export type TeaserContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    /**
     * Filter, which TeaserContents to fetch.
     */
    where?: TeaserContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeaserContents to fetch.
     */
    orderBy?: TeaserContentOrderByWithRelationInput | TeaserContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeaserContents.
     */
    cursor?: TeaserContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeaserContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeaserContents.
     */
    skip?: number
    distinct?: TeaserContentScalarFieldEnum | TeaserContentScalarFieldEnum[]
  }

  /**
   * TeaserContent create
   */
  export type TeaserContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    /**
     * The data needed to create a TeaserContent.
     */
    data: XOR<TeaserContentCreateInput, TeaserContentUncheckedCreateInput>
  }

  /**
   * TeaserContent createMany
   */
  export type TeaserContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeaserContents.
     */
    data: TeaserContentCreateManyInput | TeaserContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeaserContent createManyAndReturn
   */
  export type TeaserContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeaserContents.
     */
    data: TeaserContentCreateManyInput | TeaserContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeaserContent update
   */
  export type TeaserContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    /**
     * The data needed to update a TeaserContent.
     */
    data: XOR<TeaserContentUpdateInput, TeaserContentUncheckedUpdateInput>
    /**
     * Choose, which TeaserContent to update.
     */
    where: TeaserContentWhereUniqueInput
  }

  /**
   * TeaserContent updateMany
   */
  export type TeaserContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeaserContents.
     */
    data: XOR<TeaserContentUpdateManyMutationInput, TeaserContentUncheckedUpdateManyInput>
    /**
     * Filter which TeaserContents to update
     */
    where?: TeaserContentWhereInput
  }

  /**
   * TeaserContent upsert
   */
  export type TeaserContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    /**
     * The filter to search for the TeaserContent to update in case it exists.
     */
    where: TeaserContentWhereUniqueInput
    /**
     * In case the TeaserContent found by the `where` argument doesn't exist, create a new TeaserContent with this data.
     */
    create: XOR<TeaserContentCreateInput, TeaserContentUncheckedCreateInput>
    /**
     * In case the TeaserContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeaserContentUpdateInput, TeaserContentUncheckedUpdateInput>
  }

  /**
   * TeaserContent delete
   */
  export type TeaserContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
    /**
     * Filter which TeaserContent to delete.
     */
    where: TeaserContentWhereUniqueInput
  }

  /**
   * TeaserContent deleteMany
   */
  export type TeaserContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeaserContents to delete
     */
    where?: TeaserContentWhereInput
  }

  /**
   * TeaserContent without action
   */
  export type TeaserContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeaserContent
     */
    select?: TeaserContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeaserContentInclude<ExtArgs> | null
  }


  /**
   * Model CustomerSegmentList
   */

  export type AggregateCustomerSegmentList = {
    _count: CustomerSegmentListCountAggregateOutputType | null
    _avg: CustomerSegmentListAvgAggregateOutputType | null
    _sum: CustomerSegmentListSumAggregateOutputType | null
    _min: CustomerSegmentListMinAggregateOutputType | null
    _max: CustomerSegmentListMaxAggregateOutputType | null
  }

  export type CustomerSegmentListAvgAggregateOutputType = {
    count: number | null
  }

  export type CustomerSegmentListSumAggregateOutputType = {
    count: number | null
  }

  export type CustomerSegmentListMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    segment: string | null
    criteria: string | null
    count: number | null
    createdAt: Date | null
  }

  export type CustomerSegmentListMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    segment: string | null
    criteria: string | null
    count: number | null
    createdAt: Date | null
  }

  export type CustomerSegmentListCountAggregateOutputType = {
    id: number
    campaignId: number
    segment: number
    criteria: number
    count: number
    createdAt: number
    _all: number
  }


  export type CustomerSegmentListAvgAggregateInputType = {
    count?: true
  }

  export type CustomerSegmentListSumAggregateInputType = {
    count?: true
  }

  export type CustomerSegmentListMinAggregateInputType = {
    id?: true
    campaignId?: true
    segment?: true
    criteria?: true
    count?: true
    createdAt?: true
  }

  export type CustomerSegmentListMaxAggregateInputType = {
    id?: true
    campaignId?: true
    segment?: true
    criteria?: true
    count?: true
    createdAt?: true
  }

  export type CustomerSegmentListCountAggregateInputType = {
    id?: true
    campaignId?: true
    segment?: true
    criteria?: true
    count?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerSegmentListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerSegmentList to aggregate.
     */
    where?: CustomerSegmentListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSegmentLists to fetch.
     */
    orderBy?: CustomerSegmentListOrderByWithRelationInput | CustomerSegmentListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerSegmentListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSegmentLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSegmentLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerSegmentLists
    **/
    _count?: true | CustomerSegmentListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerSegmentListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSegmentListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerSegmentListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerSegmentListMaxAggregateInputType
  }

  export type GetCustomerSegmentListAggregateType<T extends CustomerSegmentListAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerSegmentList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerSegmentList[P]>
      : GetScalarType<T[P], AggregateCustomerSegmentList[P]>
  }




  export type CustomerSegmentListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSegmentListWhereInput
    orderBy?: CustomerSegmentListOrderByWithAggregationInput | CustomerSegmentListOrderByWithAggregationInput[]
    by: CustomerSegmentListScalarFieldEnum[] | CustomerSegmentListScalarFieldEnum
    having?: CustomerSegmentListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerSegmentListCountAggregateInputType | true
    _avg?: CustomerSegmentListAvgAggregateInputType
    _sum?: CustomerSegmentListSumAggregateInputType
    _min?: CustomerSegmentListMinAggregateInputType
    _max?: CustomerSegmentListMaxAggregateInputType
  }

  export type CustomerSegmentListGroupByOutputType = {
    id: string
    campaignId: string
    segment: string
    criteria: string
    count: number
    createdAt: Date
    _count: CustomerSegmentListCountAggregateOutputType | null
    _avg: CustomerSegmentListAvgAggregateOutputType | null
    _sum: CustomerSegmentListSumAggregateOutputType | null
    _min: CustomerSegmentListMinAggregateOutputType | null
    _max: CustomerSegmentListMaxAggregateOutputType | null
  }

  type GetCustomerSegmentListGroupByPayload<T extends CustomerSegmentListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerSegmentListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerSegmentListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerSegmentListGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerSegmentListGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSegmentListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    segment?: boolean
    criteria?: boolean
    count?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerSegmentList"]>

  export type CustomerSegmentListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    segment?: boolean
    criteria?: boolean
    count?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerSegmentList"]>

  export type CustomerSegmentListSelectScalar = {
    id?: boolean
    campaignId?: boolean
    segment?: boolean
    criteria?: boolean
    count?: boolean
    createdAt?: boolean
  }

  export type CustomerSegmentListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CustomerSegmentListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CustomerSegmentListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerSegmentList"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      segment: string
      criteria: string
      count: number
      createdAt: Date
    }, ExtArgs["result"]["customerSegmentList"]>
    composites: {}
  }

  type CustomerSegmentListGetPayload<S extends boolean | null | undefined | CustomerSegmentListDefaultArgs> = $Result.GetResult<Prisma.$CustomerSegmentListPayload, S>

  type CustomerSegmentListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerSegmentListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerSegmentListCountAggregateInputType | true
    }

  export interface CustomerSegmentListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerSegmentList'], meta: { name: 'CustomerSegmentList' } }
    /**
     * Find zero or one CustomerSegmentList that matches the filter.
     * @param {CustomerSegmentListFindUniqueArgs} args - Arguments to find a CustomerSegmentList
     * @example
     * // Get one CustomerSegmentList
     * const customerSegmentList = await prisma.customerSegmentList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerSegmentListFindUniqueArgs>(args: SelectSubset<T, CustomerSegmentListFindUniqueArgs<ExtArgs>>): Prisma__CustomerSegmentListClient<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerSegmentList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerSegmentListFindUniqueOrThrowArgs} args - Arguments to find a CustomerSegmentList
     * @example
     * // Get one CustomerSegmentList
     * const customerSegmentList = await prisma.customerSegmentList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerSegmentListFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerSegmentListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerSegmentListClient<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerSegmentList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentListFindFirstArgs} args - Arguments to find a CustomerSegmentList
     * @example
     * // Get one CustomerSegmentList
     * const customerSegmentList = await prisma.customerSegmentList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerSegmentListFindFirstArgs>(args?: SelectSubset<T, CustomerSegmentListFindFirstArgs<ExtArgs>>): Prisma__CustomerSegmentListClient<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerSegmentList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentListFindFirstOrThrowArgs} args - Arguments to find a CustomerSegmentList
     * @example
     * // Get one CustomerSegmentList
     * const customerSegmentList = await prisma.customerSegmentList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerSegmentListFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerSegmentListFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerSegmentListClient<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerSegmentLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerSegmentLists
     * const customerSegmentLists = await prisma.customerSegmentList.findMany()
     * 
     * // Get first 10 CustomerSegmentLists
     * const customerSegmentLists = await prisma.customerSegmentList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerSegmentListWithIdOnly = await prisma.customerSegmentList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerSegmentListFindManyArgs>(args?: SelectSubset<T, CustomerSegmentListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerSegmentList.
     * @param {CustomerSegmentListCreateArgs} args - Arguments to create a CustomerSegmentList.
     * @example
     * // Create one CustomerSegmentList
     * const CustomerSegmentList = await prisma.customerSegmentList.create({
     *   data: {
     *     // ... data to create a CustomerSegmentList
     *   }
     * })
     * 
     */
    create<T extends CustomerSegmentListCreateArgs>(args: SelectSubset<T, CustomerSegmentListCreateArgs<ExtArgs>>): Prisma__CustomerSegmentListClient<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerSegmentLists.
     * @param {CustomerSegmentListCreateManyArgs} args - Arguments to create many CustomerSegmentLists.
     * @example
     * // Create many CustomerSegmentLists
     * const customerSegmentList = await prisma.customerSegmentList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerSegmentListCreateManyArgs>(args?: SelectSubset<T, CustomerSegmentListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerSegmentLists and returns the data saved in the database.
     * @param {CustomerSegmentListCreateManyAndReturnArgs} args - Arguments to create many CustomerSegmentLists.
     * @example
     * // Create many CustomerSegmentLists
     * const customerSegmentList = await prisma.customerSegmentList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerSegmentLists and only return the `id`
     * const customerSegmentListWithIdOnly = await prisma.customerSegmentList.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerSegmentListCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerSegmentListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerSegmentList.
     * @param {CustomerSegmentListDeleteArgs} args - Arguments to delete one CustomerSegmentList.
     * @example
     * // Delete one CustomerSegmentList
     * const CustomerSegmentList = await prisma.customerSegmentList.delete({
     *   where: {
     *     // ... filter to delete one CustomerSegmentList
     *   }
     * })
     * 
     */
    delete<T extends CustomerSegmentListDeleteArgs>(args: SelectSubset<T, CustomerSegmentListDeleteArgs<ExtArgs>>): Prisma__CustomerSegmentListClient<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerSegmentList.
     * @param {CustomerSegmentListUpdateArgs} args - Arguments to update one CustomerSegmentList.
     * @example
     * // Update one CustomerSegmentList
     * const customerSegmentList = await prisma.customerSegmentList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerSegmentListUpdateArgs>(args: SelectSubset<T, CustomerSegmentListUpdateArgs<ExtArgs>>): Prisma__CustomerSegmentListClient<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerSegmentLists.
     * @param {CustomerSegmentListDeleteManyArgs} args - Arguments to filter CustomerSegmentLists to delete.
     * @example
     * // Delete a few CustomerSegmentLists
     * const { count } = await prisma.customerSegmentList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerSegmentListDeleteManyArgs>(args?: SelectSubset<T, CustomerSegmentListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerSegmentLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerSegmentLists
     * const customerSegmentList = await prisma.customerSegmentList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerSegmentListUpdateManyArgs>(args: SelectSubset<T, CustomerSegmentListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerSegmentList.
     * @param {CustomerSegmentListUpsertArgs} args - Arguments to update or create a CustomerSegmentList.
     * @example
     * // Update or create a CustomerSegmentList
     * const customerSegmentList = await prisma.customerSegmentList.upsert({
     *   create: {
     *     // ... data to create a CustomerSegmentList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerSegmentList we want to update
     *   }
     * })
     */
    upsert<T extends CustomerSegmentListUpsertArgs>(args: SelectSubset<T, CustomerSegmentListUpsertArgs<ExtArgs>>): Prisma__CustomerSegmentListClient<$Result.GetResult<Prisma.$CustomerSegmentListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerSegmentLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentListCountArgs} args - Arguments to filter CustomerSegmentLists to count.
     * @example
     * // Count the number of CustomerSegmentLists
     * const count = await prisma.customerSegmentList.count({
     *   where: {
     *     // ... the filter for the CustomerSegmentLists we want to count
     *   }
     * })
    **/
    count<T extends CustomerSegmentListCountArgs>(
      args?: Subset<T, CustomerSegmentListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerSegmentListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerSegmentList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerSegmentListAggregateArgs>(args: Subset<T, CustomerSegmentListAggregateArgs>): Prisma.PrismaPromise<GetCustomerSegmentListAggregateType<T>>

    /**
     * Group by CustomerSegmentList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerSegmentListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerSegmentListGroupByArgs['orderBy'] }
        : { orderBy?: CustomerSegmentListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerSegmentListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerSegmentListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerSegmentList model
   */
  readonly fields: CustomerSegmentListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerSegmentList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerSegmentListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerSegmentList model
   */ 
  interface CustomerSegmentListFieldRefs {
    readonly id: FieldRef<"CustomerSegmentList", 'String'>
    readonly campaignId: FieldRef<"CustomerSegmentList", 'String'>
    readonly segment: FieldRef<"CustomerSegmentList", 'String'>
    readonly criteria: FieldRef<"CustomerSegmentList", 'String'>
    readonly count: FieldRef<"CustomerSegmentList", 'Int'>
    readonly createdAt: FieldRef<"CustomerSegmentList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerSegmentList findUnique
   */
  export type CustomerSegmentListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegmentList to fetch.
     */
    where: CustomerSegmentListWhereUniqueInput
  }

  /**
   * CustomerSegmentList findUniqueOrThrow
   */
  export type CustomerSegmentListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegmentList to fetch.
     */
    where: CustomerSegmentListWhereUniqueInput
  }

  /**
   * CustomerSegmentList findFirst
   */
  export type CustomerSegmentListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegmentList to fetch.
     */
    where?: CustomerSegmentListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSegmentLists to fetch.
     */
    orderBy?: CustomerSegmentListOrderByWithRelationInput | CustomerSegmentListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerSegmentLists.
     */
    cursor?: CustomerSegmentListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSegmentLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSegmentLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerSegmentLists.
     */
    distinct?: CustomerSegmentListScalarFieldEnum | CustomerSegmentListScalarFieldEnum[]
  }

  /**
   * CustomerSegmentList findFirstOrThrow
   */
  export type CustomerSegmentListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegmentList to fetch.
     */
    where?: CustomerSegmentListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSegmentLists to fetch.
     */
    orderBy?: CustomerSegmentListOrderByWithRelationInput | CustomerSegmentListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerSegmentLists.
     */
    cursor?: CustomerSegmentListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSegmentLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSegmentLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerSegmentLists.
     */
    distinct?: CustomerSegmentListScalarFieldEnum | CustomerSegmentListScalarFieldEnum[]
  }

  /**
   * CustomerSegmentList findMany
   */
  export type CustomerSegmentListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegmentLists to fetch.
     */
    where?: CustomerSegmentListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSegmentLists to fetch.
     */
    orderBy?: CustomerSegmentListOrderByWithRelationInput | CustomerSegmentListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerSegmentLists.
     */
    cursor?: CustomerSegmentListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSegmentLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSegmentLists.
     */
    skip?: number
    distinct?: CustomerSegmentListScalarFieldEnum | CustomerSegmentListScalarFieldEnum[]
  }

  /**
   * CustomerSegmentList create
   */
  export type CustomerSegmentListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerSegmentList.
     */
    data: XOR<CustomerSegmentListCreateInput, CustomerSegmentListUncheckedCreateInput>
  }

  /**
   * CustomerSegmentList createMany
   */
  export type CustomerSegmentListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerSegmentLists.
     */
    data: CustomerSegmentListCreateManyInput | CustomerSegmentListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerSegmentList createManyAndReturn
   */
  export type CustomerSegmentListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerSegmentLists.
     */
    data: CustomerSegmentListCreateManyInput | CustomerSegmentListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerSegmentList update
   */
  export type CustomerSegmentListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerSegmentList.
     */
    data: XOR<CustomerSegmentListUpdateInput, CustomerSegmentListUncheckedUpdateInput>
    /**
     * Choose, which CustomerSegmentList to update.
     */
    where: CustomerSegmentListWhereUniqueInput
  }

  /**
   * CustomerSegmentList updateMany
   */
  export type CustomerSegmentListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerSegmentLists.
     */
    data: XOR<CustomerSegmentListUpdateManyMutationInput, CustomerSegmentListUncheckedUpdateManyInput>
    /**
     * Filter which CustomerSegmentLists to update
     */
    where?: CustomerSegmentListWhereInput
  }

  /**
   * CustomerSegmentList upsert
   */
  export type CustomerSegmentListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerSegmentList to update in case it exists.
     */
    where: CustomerSegmentListWhereUniqueInput
    /**
     * In case the CustomerSegmentList found by the `where` argument doesn't exist, create a new CustomerSegmentList with this data.
     */
    create: XOR<CustomerSegmentListCreateInput, CustomerSegmentListUncheckedCreateInput>
    /**
     * In case the CustomerSegmentList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerSegmentListUpdateInput, CustomerSegmentListUncheckedUpdateInput>
  }

  /**
   * CustomerSegmentList delete
   */
  export type CustomerSegmentListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
    /**
     * Filter which CustomerSegmentList to delete.
     */
    where: CustomerSegmentListWhereUniqueInput
  }

  /**
   * CustomerSegmentList deleteMany
   */
  export type CustomerSegmentListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerSegmentLists to delete
     */
    where?: CustomerSegmentListWhereInput
  }

  /**
   * CustomerSegmentList without action
   */
  export type CustomerSegmentListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentList
     */
    select?: CustomerSegmentListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentListInclude<ExtArgs> | null
  }


  /**
   * Model InfluencerPlan
   */

  export type AggregateInfluencerPlan = {
    _count: InfluencerPlanCountAggregateOutputType | null
    _min: InfluencerPlanMinAggregateOutputType | null
    _max: InfluencerPlanMaxAggregateOutputType | null
  }

  export type InfluencerPlanMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    influencerName: string | null
    platform: string | null
    postType: string | null
    expectedImpact: string | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type InfluencerPlanMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    influencerName: string | null
    platform: string | null
    postType: string | null
    expectedImpact: string | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type InfluencerPlanCountAggregateOutputType = {
    id: number
    campaignId: number
    influencerName: number
    platform: number
    postType: number
    expectedImpact: number
    scheduledAt: number
    createdAt: number
    _all: number
  }


  export type InfluencerPlanMinAggregateInputType = {
    id?: true
    campaignId?: true
    influencerName?: true
    platform?: true
    postType?: true
    expectedImpact?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type InfluencerPlanMaxAggregateInputType = {
    id?: true
    campaignId?: true
    influencerName?: true
    platform?: true
    postType?: true
    expectedImpact?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type InfluencerPlanCountAggregateInputType = {
    id?: true
    campaignId?: true
    influencerName?: true
    platform?: true
    postType?: true
    expectedImpact?: true
    scheduledAt?: true
    createdAt?: true
    _all?: true
  }

  export type InfluencerPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfluencerPlan to aggregate.
     */
    where?: InfluencerPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluencerPlans to fetch.
     */
    orderBy?: InfluencerPlanOrderByWithRelationInput | InfluencerPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InfluencerPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluencerPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluencerPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InfluencerPlans
    **/
    _count?: true | InfluencerPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfluencerPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfluencerPlanMaxAggregateInputType
  }

  export type GetInfluencerPlanAggregateType<T extends InfluencerPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateInfluencerPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfluencerPlan[P]>
      : GetScalarType<T[P], AggregateInfluencerPlan[P]>
  }




  export type InfluencerPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfluencerPlanWhereInput
    orderBy?: InfluencerPlanOrderByWithAggregationInput | InfluencerPlanOrderByWithAggregationInput[]
    by: InfluencerPlanScalarFieldEnum[] | InfluencerPlanScalarFieldEnum
    having?: InfluencerPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfluencerPlanCountAggregateInputType | true
    _min?: InfluencerPlanMinAggregateInputType
    _max?: InfluencerPlanMaxAggregateInputType
  }

  export type InfluencerPlanGroupByOutputType = {
    id: string
    campaignId: string
    influencerName: string
    platform: string
    postType: string
    expectedImpact: string | null
    scheduledAt: Date
    createdAt: Date
    _count: InfluencerPlanCountAggregateOutputType | null
    _min: InfluencerPlanMinAggregateOutputType | null
    _max: InfluencerPlanMaxAggregateOutputType | null
  }

  type GetInfluencerPlanGroupByPayload<T extends InfluencerPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfluencerPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfluencerPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfluencerPlanGroupByOutputType[P]>
            : GetScalarType<T[P], InfluencerPlanGroupByOutputType[P]>
        }
      >
    >


  export type InfluencerPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    influencerName?: boolean
    platform?: boolean
    postType?: boolean
    expectedImpact?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["influencerPlan"]>

  export type InfluencerPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    influencerName?: boolean
    platform?: boolean
    postType?: boolean
    expectedImpact?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["influencerPlan"]>

  export type InfluencerPlanSelectScalar = {
    id?: boolean
    campaignId?: boolean
    influencerName?: boolean
    platform?: boolean
    postType?: boolean
    expectedImpact?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
  }

  export type InfluencerPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type InfluencerPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $InfluencerPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InfluencerPlan"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      influencerName: string
      platform: string
      postType: string
      expectedImpact: string | null
      scheduledAt: Date
      createdAt: Date
    }, ExtArgs["result"]["influencerPlan"]>
    composites: {}
  }

  type InfluencerPlanGetPayload<S extends boolean | null | undefined | InfluencerPlanDefaultArgs> = $Result.GetResult<Prisma.$InfluencerPlanPayload, S>

  type InfluencerPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InfluencerPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InfluencerPlanCountAggregateInputType | true
    }

  export interface InfluencerPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InfluencerPlan'], meta: { name: 'InfluencerPlan' } }
    /**
     * Find zero or one InfluencerPlan that matches the filter.
     * @param {InfluencerPlanFindUniqueArgs} args - Arguments to find a InfluencerPlan
     * @example
     * // Get one InfluencerPlan
     * const influencerPlan = await prisma.influencerPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InfluencerPlanFindUniqueArgs>(args: SelectSubset<T, InfluencerPlanFindUniqueArgs<ExtArgs>>): Prisma__InfluencerPlanClient<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InfluencerPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InfluencerPlanFindUniqueOrThrowArgs} args - Arguments to find a InfluencerPlan
     * @example
     * // Get one InfluencerPlan
     * const influencerPlan = await prisma.influencerPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InfluencerPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, InfluencerPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InfluencerPlanClient<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InfluencerPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerPlanFindFirstArgs} args - Arguments to find a InfluencerPlan
     * @example
     * // Get one InfluencerPlan
     * const influencerPlan = await prisma.influencerPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InfluencerPlanFindFirstArgs>(args?: SelectSubset<T, InfluencerPlanFindFirstArgs<ExtArgs>>): Prisma__InfluencerPlanClient<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InfluencerPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerPlanFindFirstOrThrowArgs} args - Arguments to find a InfluencerPlan
     * @example
     * // Get one InfluencerPlan
     * const influencerPlan = await prisma.influencerPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InfluencerPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, InfluencerPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__InfluencerPlanClient<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InfluencerPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InfluencerPlans
     * const influencerPlans = await prisma.influencerPlan.findMany()
     * 
     * // Get first 10 InfluencerPlans
     * const influencerPlans = await prisma.influencerPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const influencerPlanWithIdOnly = await prisma.influencerPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InfluencerPlanFindManyArgs>(args?: SelectSubset<T, InfluencerPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InfluencerPlan.
     * @param {InfluencerPlanCreateArgs} args - Arguments to create a InfluencerPlan.
     * @example
     * // Create one InfluencerPlan
     * const InfluencerPlan = await prisma.influencerPlan.create({
     *   data: {
     *     // ... data to create a InfluencerPlan
     *   }
     * })
     * 
     */
    create<T extends InfluencerPlanCreateArgs>(args: SelectSubset<T, InfluencerPlanCreateArgs<ExtArgs>>): Prisma__InfluencerPlanClient<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InfluencerPlans.
     * @param {InfluencerPlanCreateManyArgs} args - Arguments to create many InfluencerPlans.
     * @example
     * // Create many InfluencerPlans
     * const influencerPlan = await prisma.influencerPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InfluencerPlanCreateManyArgs>(args?: SelectSubset<T, InfluencerPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InfluencerPlans and returns the data saved in the database.
     * @param {InfluencerPlanCreateManyAndReturnArgs} args - Arguments to create many InfluencerPlans.
     * @example
     * // Create many InfluencerPlans
     * const influencerPlan = await prisma.influencerPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InfluencerPlans and only return the `id`
     * const influencerPlanWithIdOnly = await prisma.influencerPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InfluencerPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, InfluencerPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InfluencerPlan.
     * @param {InfluencerPlanDeleteArgs} args - Arguments to delete one InfluencerPlan.
     * @example
     * // Delete one InfluencerPlan
     * const InfluencerPlan = await prisma.influencerPlan.delete({
     *   where: {
     *     // ... filter to delete one InfluencerPlan
     *   }
     * })
     * 
     */
    delete<T extends InfluencerPlanDeleteArgs>(args: SelectSubset<T, InfluencerPlanDeleteArgs<ExtArgs>>): Prisma__InfluencerPlanClient<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InfluencerPlan.
     * @param {InfluencerPlanUpdateArgs} args - Arguments to update one InfluencerPlan.
     * @example
     * // Update one InfluencerPlan
     * const influencerPlan = await prisma.influencerPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InfluencerPlanUpdateArgs>(args: SelectSubset<T, InfluencerPlanUpdateArgs<ExtArgs>>): Prisma__InfluencerPlanClient<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InfluencerPlans.
     * @param {InfluencerPlanDeleteManyArgs} args - Arguments to filter InfluencerPlans to delete.
     * @example
     * // Delete a few InfluencerPlans
     * const { count } = await prisma.influencerPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InfluencerPlanDeleteManyArgs>(args?: SelectSubset<T, InfluencerPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfluencerPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InfluencerPlans
     * const influencerPlan = await prisma.influencerPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InfluencerPlanUpdateManyArgs>(args: SelectSubset<T, InfluencerPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InfluencerPlan.
     * @param {InfluencerPlanUpsertArgs} args - Arguments to update or create a InfluencerPlan.
     * @example
     * // Update or create a InfluencerPlan
     * const influencerPlan = await prisma.influencerPlan.upsert({
     *   create: {
     *     // ... data to create a InfluencerPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InfluencerPlan we want to update
     *   }
     * })
     */
    upsert<T extends InfluencerPlanUpsertArgs>(args: SelectSubset<T, InfluencerPlanUpsertArgs<ExtArgs>>): Prisma__InfluencerPlanClient<$Result.GetResult<Prisma.$InfluencerPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InfluencerPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerPlanCountArgs} args - Arguments to filter InfluencerPlans to count.
     * @example
     * // Count the number of InfluencerPlans
     * const count = await prisma.influencerPlan.count({
     *   where: {
     *     // ... the filter for the InfluencerPlans we want to count
     *   }
     * })
    **/
    count<T extends InfluencerPlanCountArgs>(
      args?: Subset<T, InfluencerPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfluencerPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InfluencerPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfluencerPlanAggregateArgs>(args: Subset<T, InfluencerPlanAggregateArgs>): Prisma.PrismaPromise<GetInfluencerPlanAggregateType<T>>

    /**
     * Group by InfluencerPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfluencerPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfluencerPlanGroupByArgs['orderBy'] }
        : { orderBy?: InfluencerPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfluencerPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfluencerPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InfluencerPlan model
   */
  readonly fields: InfluencerPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InfluencerPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InfluencerPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InfluencerPlan model
   */ 
  interface InfluencerPlanFieldRefs {
    readonly id: FieldRef<"InfluencerPlan", 'String'>
    readonly campaignId: FieldRef<"InfluencerPlan", 'String'>
    readonly influencerName: FieldRef<"InfluencerPlan", 'String'>
    readonly platform: FieldRef<"InfluencerPlan", 'String'>
    readonly postType: FieldRef<"InfluencerPlan", 'String'>
    readonly expectedImpact: FieldRef<"InfluencerPlan", 'String'>
    readonly scheduledAt: FieldRef<"InfluencerPlan", 'DateTime'>
    readonly createdAt: FieldRef<"InfluencerPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InfluencerPlan findUnique
   */
  export type InfluencerPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerPlan to fetch.
     */
    where: InfluencerPlanWhereUniqueInput
  }

  /**
   * InfluencerPlan findUniqueOrThrow
   */
  export type InfluencerPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerPlan to fetch.
     */
    where: InfluencerPlanWhereUniqueInput
  }

  /**
   * InfluencerPlan findFirst
   */
  export type InfluencerPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerPlan to fetch.
     */
    where?: InfluencerPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluencerPlans to fetch.
     */
    orderBy?: InfluencerPlanOrderByWithRelationInput | InfluencerPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfluencerPlans.
     */
    cursor?: InfluencerPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluencerPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluencerPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfluencerPlans.
     */
    distinct?: InfluencerPlanScalarFieldEnum | InfluencerPlanScalarFieldEnum[]
  }

  /**
   * InfluencerPlan findFirstOrThrow
   */
  export type InfluencerPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerPlan to fetch.
     */
    where?: InfluencerPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluencerPlans to fetch.
     */
    orderBy?: InfluencerPlanOrderByWithRelationInput | InfluencerPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfluencerPlans.
     */
    cursor?: InfluencerPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluencerPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluencerPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfluencerPlans.
     */
    distinct?: InfluencerPlanScalarFieldEnum | InfluencerPlanScalarFieldEnum[]
  }

  /**
   * InfluencerPlan findMany
   */
  export type InfluencerPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerPlans to fetch.
     */
    where?: InfluencerPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluencerPlans to fetch.
     */
    orderBy?: InfluencerPlanOrderByWithRelationInput | InfluencerPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InfluencerPlans.
     */
    cursor?: InfluencerPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluencerPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluencerPlans.
     */
    skip?: number
    distinct?: InfluencerPlanScalarFieldEnum | InfluencerPlanScalarFieldEnum[]
  }

  /**
   * InfluencerPlan create
   */
  export type InfluencerPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a InfluencerPlan.
     */
    data: XOR<InfluencerPlanCreateInput, InfluencerPlanUncheckedCreateInput>
  }

  /**
   * InfluencerPlan createMany
   */
  export type InfluencerPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InfluencerPlans.
     */
    data: InfluencerPlanCreateManyInput | InfluencerPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InfluencerPlan createManyAndReturn
   */
  export type InfluencerPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InfluencerPlans.
     */
    data: InfluencerPlanCreateManyInput | InfluencerPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InfluencerPlan update
   */
  export type InfluencerPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a InfluencerPlan.
     */
    data: XOR<InfluencerPlanUpdateInput, InfluencerPlanUncheckedUpdateInput>
    /**
     * Choose, which InfluencerPlan to update.
     */
    where: InfluencerPlanWhereUniqueInput
  }

  /**
   * InfluencerPlan updateMany
   */
  export type InfluencerPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InfluencerPlans.
     */
    data: XOR<InfluencerPlanUpdateManyMutationInput, InfluencerPlanUncheckedUpdateManyInput>
    /**
     * Filter which InfluencerPlans to update
     */
    where?: InfluencerPlanWhereInput
  }

  /**
   * InfluencerPlan upsert
   */
  export type InfluencerPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the InfluencerPlan to update in case it exists.
     */
    where: InfluencerPlanWhereUniqueInput
    /**
     * In case the InfluencerPlan found by the `where` argument doesn't exist, create a new InfluencerPlan with this data.
     */
    create: XOR<InfluencerPlanCreateInput, InfluencerPlanUncheckedCreateInput>
    /**
     * In case the InfluencerPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InfluencerPlanUpdateInput, InfluencerPlanUncheckedUpdateInput>
  }

  /**
   * InfluencerPlan delete
   */
  export type InfluencerPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
    /**
     * Filter which InfluencerPlan to delete.
     */
    where: InfluencerPlanWhereUniqueInput
  }

  /**
   * InfluencerPlan deleteMany
   */
  export type InfluencerPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfluencerPlans to delete
     */
    where?: InfluencerPlanWhereInput
  }

  /**
   * InfluencerPlan without action
   */
  export type InfluencerPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerPlan
     */
    select?: InfluencerPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerPlanInclude<ExtArgs> | null
  }


  /**
   * Model OperationalChecklist
   */

  export type AggregateOperationalChecklist = {
    _count: OperationalChecklistCountAggregateOutputType | null
    _min: OperationalChecklistMinAggregateOutputType | null
    _max: OperationalChecklistMaxAggregateOutputType | null
  }

  export type OperationalChecklistMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    system: string | null
    checklistItem: string | null
    expectedOutcome: string | null
    responsibility: string | null
    status: string | null
    createdAt: Date | null
  }

  export type OperationalChecklistMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    system: string | null
    checklistItem: string | null
    expectedOutcome: string | null
    responsibility: string | null
    status: string | null
    createdAt: Date | null
  }

  export type OperationalChecklistCountAggregateOutputType = {
    id: number
    campaignId: number
    system: number
    checklistItem: number
    expectedOutcome: number
    responsibility: number
    status: number
    createdAt: number
    _all: number
  }


  export type OperationalChecklistMinAggregateInputType = {
    id?: true
    campaignId?: true
    system?: true
    checklistItem?: true
    expectedOutcome?: true
    responsibility?: true
    status?: true
    createdAt?: true
  }

  export type OperationalChecklistMaxAggregateInputType = {
    id?: true
    campaignId?: true
    system?: true
    checklistItem?: true
    expectedOutcome?: true
    responsibility?: true
    status?: true
    createdAt?: true
  }

  export type OperationalChecklistCountAggregateInputType = {
    id?: true
    campaignId?: true
    system?: true
    checklistItem?: true
    expectedOutcome?: true
    responsibility?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type OperationalChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationalChecklist to aggregate.
     */
    where?: OperationalChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationalChecklists to fetch.
     */
    orderBy?: OperationalChecklistOrderByWithRelationInput | OperationalChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationalChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationalChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationalChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationalChecklists
    **/
    _count?: true | OperationalChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationalChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationalChecklistMaxAggregateInputType
  }

  export type GetOperationalChecklistAggregateType<T extends OperationalChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationalChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationalChecklist[P]>
      : GetScalarType<T[P], AggregateOperationalChecklist[P]>
  }




  export type OperationalChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationalChecklistWhereInput
    orderBy?: OperationalChecklistOrderByWithAggregationInput | OperationalChecklistOrderByWithAggregationInput[]
    by: OperationalChecklistScalarFieldEnum[] | OperationalChecklistScalarFieldEnum
    having?: OperationalChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationalChecklistCountAggregateInputType | true
    _min?: OperationalChecklistMinAggregateInputType
    _max?: OperationalChecklistMaxAggregateInputType
  }

  export type OperationalChecklistGroupByOutputType = {
    id: string
    campaignId: string
    system: string
    checklistItem: string
    expectedOutcome: string
    responsibility: string
    status: string
    createdAt: Date
    _count: OperationalChecklistCountAggregateOutputType | null
    _min: OperationalChecklistMinAggregateOutputType | null
    _max: OperationalChecklistMaxAggregateOutputType | null
  }

  type GetOperationalChecklistGroupByPayload<T extends OperationalChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationalChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationalChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationalChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], OperationalChecklistGroupByOutputType[P]>
        }
      >
    >


  export type OperationalChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    system?: boolean
    checklistItem?: boolean
    expectedOutcome?: boolean
    responsibility?: boolean
    status?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationalChecklist"]>

  export type OperationalChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    system?: boolean
    checklistItem?: boolean
    expectedOutcome?: boolean
    responsibility?: boolean
    status?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationalChecklist"]>

  export type OperationalChecklistSelectScalar = {
    id?: boolean
    campaignId?: boolean
    system?: boolean
    checklistItem?: boolean
    expectedOutcome?: boolean
    responsibility?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type OperationalChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type OperationalChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $OperationalChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationalChecklist"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      system: string
      checklistItem: string
      expectedOutcome: string
      responsibility: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["operationalChecklist"]>
    composites: {}
  }

  type OperationalChecklistGetPayload<S extends boolean | null | undefined | OperationalChecklistDefaultArgs> = $Result.GetResult<Prisma.$OperationalChecklistPayload, S>

  type OperationalChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationalChecklistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationalChecklistCountAggregateInputType | true
    }

  export interface OperationalChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationalChecklist'], meta: { name: 'OperationalChecklist' } }
    /**
     * Find zero or one OperationalChecklist that matches the filter.
     * @param {OperationalChecklistFindUniqueArgs} args - Arguments to find a OperationalChecklist
     * @example
     * // Get one OperationalChecklist
     * const operationalChecklist = await prisma.operationalChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationalChecklistFindUniqueArgs>(args: SelectSubset<T, OperationalChecklistFindUniqueArgs<ExtArgs>>): Prisma__OperationalChecklistClient<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperationalChecklist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationalChecklistFindUniqueOrThrowArgs} args - Arguments to find a OperationalChecklist
     * @example
     * // Get one OperationalChecklist
     * const operationalChecklist = await prisma.operationalChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationalChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationalChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationalChecklistClient<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperationalChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationalChecklistFindFirstArgs} args - Arguments to find a OperationalChecklist
     * @example
     * // Get one OperationalChecklist
     * const operationalChecklist = await prisma.operationalChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationalChecklistFindFirstArgs>(args?: SelectSubset<T, OperationalChecklistFindFirstArgs<ExtArgs>>): Prisma__OperationalChecklistClient<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperationalChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationalChecklistFindFirstOrThrowArgs} args - Arguments to find a OperationalChecklist
     * @example
     * // Get one OperationalChecklist
     * const operationalChecklist = await prisma.operationalChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationalChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationalChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationalChecklistClient<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperationalChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationalChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationalChecklists
     * const operationalChecklists = await prisma.operationalChecklist.findMany()
     * 
     * // Get first 10 OperationalChecklists
     * const operationalChecklists = await prisma.operationalChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationalChecklistWithIdOnly = await prisma.operationalChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationalChecklistFindManyArgs>(args?: SelectSubset<T, OperationalChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperationalChecklist.
     * @param {OperationalChecklistCreateArgs} args - Arguments to create a OperationalChecklist.
     * @example
     * // Create one OperationalChecklist
     * const OperationalChecklist = await prisma.operationalChecklist.create({
     *   data: {
     *     // ... data to create a OperationalChecklist
     *   }
     * })
     * 
     */
    create<T extends OperationalChecklistCreateArgs>(args: SelectSubset<T, OperationalChecklistCreateArgs<ExtArgs>>): Prisma__OperationalChecklistClient<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperationalChecklists.
     * @param {OperationalChecklistCreateManyArgs} args - Arguments to create many OperationalChecklists.
     * @example
     * // Create many OperationalChecklists
     * const operationalChecklist = await prisma.operationalChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationalChecklistCreateManyArgs>(args?: SelectSubset<T, OperationalChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperationalChecklists and returns the data saved in the database.
     * @param {OperationalChecklistCreateManyAndReturnArgs} args - Arguments to create many OperationalChecklists.
     * @example
     * // Create many OperationalChecklists
     * const operationalChecklist = await prisma.operationalChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperationalChecklists and only return the `id`
     * const operationalChecklistWithIdOnly = await prisma.operationalChecklist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperationalChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, OperationalChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OperationalChecklist.
     * @param {OperationalChecklistDeleteArgs} args - Arguments to delete one OperationalChecklist.
     * @example
     * // Delete one OperationalChecklist
     * const OperationalChecklist = await prisma.operationalChecklist.delete({
     *   where: {
     *     // ... filter to delete one OperationalChecklist
     *   }
     * })
     * 
     */
    delete<T extends OperationalChecklistDeleteArgs>(args: SelectSubset<T, OperationalChecklistDeleteArgs<ExtArgs>>): Prisma__OperationalChecklistClient<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperationalChecklist.
     * @param {OperationalChecklistUpdateArgs} args - Arguments to update one OperationalChecklist.
     * @example
     * // Update one OperationalChecklist
     * const operationalChecklist = await prisma.operationalChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationalChecklistUpdateArgs>(args: SelectSubset<T, OperationalChecklistUpdateArgs<ExtArgs>>): Prisma__OperationalChecklistClient<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperationalChecklists.
     * @param {OperationalChecklistDeleteManyArgs} args - Arguments to filter OperationalChecklists to delete.
     * @example
     * // Delete a few OperationalChecklists
     * const { count } = await prisma.operationalChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationalChecklistDeleteManyArgs>(args?: SelectSubset<T, OperationalChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationalChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationalChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationalChecklists
     * const operationalChecklist = await prisma.operationalChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationalChecklistUpdateManyArgs>(args: SelectSubset<T, OperationalChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationalChecklist.
     * @param {OperationalChecklistUpsertArgs} args - Arguments to update or create a OperationalChecklist.
     * @example
     * // Update or create a OperationalChecklist
     * const operationalChecklist = await prisma.operationalChecklist.upsert({
     *   create: {
     *     // ... data to create a OperationalChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationalChecklist we want to update
     *   }
     * })
     */
    upsert<T extends OperationalChecklistUpsertArgs>(args: SelectSubset<T, OperationalChecklistUpsertArgs<ExtArgs>>): Prisma__OperationalChecklistClient<$Result.GetResult<Prisma.$OperationalChecklistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OperationalChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationalChecklistCountArgs} args - Arguments to filter OperationalChecklists to count.
     * @example
     * // Count the number of OperationalChecklists
     * const count = await prisma.operationalChecklist.count({
     *   where: {
     *     // ... the filter for the OperationalChecklists we want to count
     *   }
     * })
    **/
    count<T extends OperationalChecklistCountArgs>(
      args?: Subset<T, OperationalChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationalChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationalChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationalChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationalChecklistAggregateArgs>(args: Subset<T, OperationalChecklistAggregateArgs>): Prisma.PrismaPromise<GetOperationalChecklistAggregateType<T>>

    /**
     * Group by OperationalChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationalChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationalChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationalChecklistGroupByArgs['orderBy'] }
        : { orderBy?: OperationalChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationalChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationalChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationalChecklist model
   */
  readonly fields: OperationalChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationalChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationalChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationalChecklist model
   */ 
  interface OperationalChecklistFieldRefs {
    readonly id: FieldRef<"OperationalChecklist", 'String'>
    readonly campaignId: FieldRef<"OperationalChecklist", 'String'>
    readonly system: FieldRef<"OperationalChecklist", 'String'>
    readonly checklistItem: FieldRef<"OperationalChecklist", 'String'>
    readonly expectedOutcome: FieldRef<"OperationalChecklist", 'String'>
    readonly responsibility: FieldRef<"OperationalChecklist", 'String'>
    readonly status: FieldRef<"OperationalChecklist", 'String'>
    readonly createdAt: FieldRef<"OperationalChecklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperationalChecklist findUnique
   */
  export type OperationalChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which OperationalChecklist to fetch.
     */
    where: OperationalChecklistWhereUniqueInput
  }

  /**
   * OperationalChecklist findUniqueOrThrow
   */
  export type OperationalChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which OperationalChecklist to fetch.
     */
    where: OperationalChecklistWhereUniqueInput
  }

  /**
   * OperationalChecklist findFirst
   */
  export type OperationalChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which OperationalChecklist to fetch.
     */
    where?: OperationalChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationalChecklists to fetch.
     */
    orderBy?: OperationalChecklistOrderByWithRelationInput | OperationalChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationalChecklists.
     */
    cursor?: OperationalChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationalChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationalChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationalChecklists.
     */
    distinct?: OperationalChecklistScalarFieldEnum | OperationalChecklistScalarFieldEnum[]
  }

  /**
   * OperationalChecklist findFirstOrThrow
   */
  export type OperationalChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which OperationalChecklist to fetch.
     */
    where?: OperationalChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationalChecklists to fetch.
     */
    orderBy?: OperationalChecklistOrderByWithRelationInput | OperationalChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationalChecklists.
     */
    cursor?: OperationalChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationalChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationalChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationalChecklists.
     */
    distinct?: OperationalChecklistScalarFieldEnum | OperationalChecklistScalarFieldEnum[]
  }

  /**
   * OperationalChecklist findMany
   */
  export type OperationalChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which OperationalChecklists to fetch.
     */
    where?: OperationalChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationalChecklists to fetch.
     */
    orderBy?: OperationalChecklistOrderByWithRelationInput | OperationalChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationalChecklists.
     */
    cursor?: OperationalChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationalChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationalChecklists.
     */
    skip?: number
    distinct?: OperationalChecklistScalarFieldEnum | OperationalChecklistScalarFieldEnum[]
  }

  /**
   * OperationalChecklist create
   */
  export type OperationalChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationalChecklist.
     */
    data: XOR<OperationalChecklistCreateInput, OperationalChecklistUncheckedCreateInput>
  }

  /**
   * OperationalChecklist createMany
   */
  export type OperationalChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationalChecklists.
     */
    data: OperationalChecklistCreateManyInput | OperationalChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationalChecklist createManyAndReturn
   */
  export type OperationalChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OperationalChecklists.
     */
    data: OperationalChecklistCreateManyInput | OperationalChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperationalChecklist update
   */
  export type OperationalChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationalChecklist.
     */
    data: XOR<OperationalChecklistUpdateInput, OperationalChecklistUncheckedUpdateInput>
    /**
     * Choose, which OperationalChecklist to update.
     */
    where: OperationalChecklistWhereUniqueInput
  }

  /**
   * OperationalChecklist updateMany
   */
  export type OperationalChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationalChecklists.
     */
    data: XOR<OperationalChecklistUpdateManyMutationInput, OperationalChecklistUncheckedUpdateManyInput>
    /**
     * Filter which OperationalChecklists to update
     */
    where?: OperationalChecklistWhereInput
  }

  /**
   * OperationalChecklist upsert
   */
  export type OperationalChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationalChecklist to update in case it exists.
     */
    where: OperationalChecklistWhereUniqueInput
    /**
     * In case the OperationalChecklist found by the `where` argument doesn't exist, create a new OperationalChecklist with this data.
     */
    create: XOR<OperationalChecklistCreateInput, OperationalChecklistUncheckedCreateInput>
    /**
     * In case the OperationalChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationalChecklistUpdateInput, OperationalChecklistUncheckedUpdateInput>
  }

  /**
   * OperationalChecklist delete
   */
  export type OperationalChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
    /**
     * Filter which OperationalChecklist to delete.
     */
    where: OperationalChecklistWhereUniqueInput
  }

  /**
   * OperationalChecklist deleteMany
   */
  export type OperationalChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationalChecklists to delete
     */
    where?: OperationalChecklistWhereInput
  }

  /**
   * OperationalChecklist without action
   */
  export type OperationalChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationalChecklist
     */
    select?: OperationalChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationalChecklistInclude<ExtArgs> | null
  }


  /**
   * Model CampaignActivation
   */

  export type AggregateCampaignActivation = {
    _count: CampaignActivationCountAggregateOutputType | null
    _min: CampaignActivationMinAggregateOutputType | null
    _max: CampaignActivationMaxAggregateOutputType | null
  }

  export type CampaignActivationMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    platform: string | null
    assetType: string | null
    assetReference: string | null
    activationTime: Date | null
    status: string | null
    activationResult: string | null
    createdAt: Date | null
  }

  export type CampaignActivationMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    platform: string | null
    assetType: string | null
    assetReference: string | null
    activationTime: Date | null
    status: string | null
    activationResult: string | null
    createdAt: Date | null
  }

  export type CampaignActivationCountAggregateOutputType = {
    id: number
    campaignId: number
    platform: number
    assetType: number
    assetReference: number
    activationTime: number
    status: number
    activationResult: number
    createdAt: number
    _all: number
  }


  export type CampaignActivationMinAggregateInputType = {
    id?: true
    campaignId?: true
    platform?: true
    assetType?: true
    assetReference?: true
    activationTime?: true
    status?: true
    activationResult?: true
    createdAt?: true
  }

  export type CampaignActivationMaxAggregateInputType = {
    id?: true
    campaignId?: true
    platform?: true
    assetType?: true
    assetReference?: true
    activationTime?: true
    status?: true
    activationResult?: true
    createdAt?: true
  }

  export type CampaignActivationCountAggregateInputType = {
    id?: true
    campaignId?: true
    platform?: true
    assetType?: true
    assetReference?: true
    activationTime?: true
    status?: true
    activationResult?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignActivationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignActivation to aggregate.
     */
    where?: CampaignActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignActivations to fetch.
     */
    orderBy?: CampaignActivationOrderByWithRelationInput | CampaignActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignActivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignActivations
    **/
    _count?: true | CampaignActivationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignActivationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignActivationMaxAggregateInputType
  }

  export type GetCampaignActivationAggregateType<T extends CampaignActivationAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignActivation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignActivation[P]>
      : GetScalarType<T[P], AggregateCampaignActivation[P]>
  }




  export type CampaignActivationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignActivationWhereInput
    orderBy?: CampaignActivationOrderByWithAggregationInput | CampaignActivationOrderByWithAggregationInput[]
    by: CampaignActivationScalarFieldEnum[] | CampaignActivationScalarFieldEnum
    having?: CampaignActivationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignActivationCountAggregateInputType | true
    _min?: CampaignActivationMinAggregateInputType
    _max?: CampaignActivationMaxAggregateInputType
  }

  export type CampaignActivationGroupByOutputType = {
    id: string
    campaignId: string
    platform: string
    assetType: string
    assetReference: string
    activationTime: Date
    status: string
    activationResult: string
    createdAt: Date
    _count: CampaignActivationCountAggregateOutputType | null
    _min: CampaignActivationMinAggregateOutputType | null
    _max: CampaignActivationMaxAggregateOutputType | null
  }

  type GetCampaignActivationGroupByPayload<T extends CampaignActivationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignActivationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignActivationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignActivationGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignActivationGroupByOutputType[P]>
        }
      >
    >


  export type CampaignActivationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    platform?: boolean
    assetType?: boolean
    assetReference?: boolean
    activationTime?: boolean
    status?: boolean
    activationResult?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignActivation"]>

  export type CampaignActivationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    platform?: boolean
    assetType?: boolean
    assetReference?: boolean
    activationTime?: boolean
    status?: boolean
    activationResult?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignActivation"]>

  export type CampaignActivationSelectScalar = {
    id?: boolean
    campaignId?: boolean
    platform?: boolean
    assetType?: boolean
    assetReference?: boolean
    activationTime?: boolean
    status?: boolean
    activationResult?: boolean
    createdAt?: boolean
  }

  export type CampaignActivationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignActivationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignActivationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignActivation"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      platform: string
      assetType: string
      assetReference: string
      activationTime: Date
      status: string
      activationResult: string
      createdAt: Date
    }, ExtArgs["result"]["campaignActivation"]>
    composites: {}
  }

  type CampaignActivationGetPayload<S extends boolean | null | undefined | CampaignActivationDefaultArgs> = $Result.GetResult<Prisma.$CampaignActivationPayload, S>

  type CampaignActivationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignActivationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignActivationCountAggregateInputType | true
    }

  export interface CampaignActivationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignActivation'], meta: { name: 'CampaignActivation' } }
    /**
     * Find zero or one CampaignActivation that matches the filter.
     * @param {CampaignActivationFindUniqueArgs} args - Arguments to find a CampaignActivation
     * @example
     * // Get one CampaignActivation
     * const campaignActivation = await prisma.campaignActivation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignActivationFindUniqueArgs>(args: SelectSubset<T, CampaignActivationFindUniqueArgs<ExtArgs>>): Prisma__CampaignActivationClient<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignActivation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignActivationFindUniqueOrThrowArgs} args - Arguments to find a CampaignActivation
     * @example
     * // Get one CampaignActivation
     * const campaignActivation = await prisma.campaignActivation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignActivationFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignActivationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignActivationClient<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignActivation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivationFindFirstArgs} args - Arguments to find a CampaignActivation
     * @example
     * // Get one CampaignActivation
     * const campaignActivation = await prisma.campaignActivation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignActivationFindFirstArgs>(args?: SelectSubset<T, CampaignActivationFindFirstArgs<ExtArgs>>): Prisma__CampaignActivationClient<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignActivation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivationFindFirstOrThrowArgs} args - Arguments to find a CampaignActivation
     * @example
     * // Get one CampaignActivation
     * const campaignActivation = await prisma.campaignActivation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignActivationFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignActivationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignActivationClient<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignActivations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignActivations
     * const campaignActivations = await prisma.campaignActivation.findMany()
     * 
     * // Get first 10 CampaignActivations
     * const campaignActivations = await prisma.campaignActivation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignActivationWithIdOnly = await prisma.campaignActivation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignActivationFindManyArgs>(args?: SelectSubset<T, CampaignActivationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignActivation.
     * @param {CampaignActivationCreateArgs} args - Arguments to create a CampaignActivation.
     * @example
     * // Create one CampaignActivation
     * const CampaignActivation = await prisma.campaignActivation.create({
     *   data: {
     *     // ... data to create a CampaignActivation
     *   }
     * })
     * 
     */
    create<T extends CampaignActivationCreateArgs>(args: SelectSubset<T, CampaignActivationCreateArgs<ExtArgs>>): Prisma__CampaignActivationClient<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignActivations.
     * @param {CampaignActivationCreateManyArgs} args - Arguments to create many CampaignActivations.
     * @example
     * // Create many CampaignActivations
     * const campaignActivation = await prisma.campaignActivation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignActivationCreateManyArgs>(args?: SelectSubset<T, CampaignActivationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignActivations and returns the data saved in the database.
     * @param {CampaignActivationCreateManyAndReturnArgs} args - Arguments to create many CampaignActivations.
     * @example
     * // Create many CampaignActivations
     * const campaignActivation = await prisma.campaignActivation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignActivations and only return the `id`
     * const campaignActivationWithIdOnly = await prisma.campaignActivation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignActivationCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignActivationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignActivation.
     * @param {CampaignActivationDeleteArgs} args - Arguments to delete one CampaignActivation.
     * @example
     * // Delete one CampaignActivation
     * const CampaignActivation = await prisma.campaignActivation.delete({
     *   where: {
     *     // ... filter to delete one CampaignActivation
     *   }
     * })
     * 
     */
    delete<T extends CampaignActivationDeleteArgs>(args: SelectSubset<T, CampaignActivationDeleteArgs<ExtArgs>>): Prisma__CampaignActivationClient<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignActivation.
     * @param {CampaignActivationUpdateArgs} args - Arguments to update one CampaignActivation.
     * @example
     * // Update one CampaignActivation
     * const campaignActivation = await prisma.campaignActivation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignActivationUpdateArgs>(args: SelectSubset<T, CampaignActivationUpdateArgs<ExtArgs>>): Prisma__CampaignActivationClient<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignActivations.
     * @param {CampaignActivationDeleteManyArgs} args - Arguments to filter CampaignActivations to delete.
     * @example
     * // Delete a few CampaignActivations
     * const { count } = await prisma.campaignActivation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignActivationDeleteManyArgs>(args?: SelectSubset<T, CampaignActivationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignActivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignActivations
     * const campaignActivation = await prisma.campaignActivation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignActivationUpdateManyArgs>(args: SelectSubset<T, CampaignActivationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignActivation.
     * @param {CampaignActivationUpsertArgs} args - Arguments to update or create a CampaignActivation.
     * @example
     * // Update or create a CampaignActivation
     * const campaignActivation = await prisma.campaignActivation.upsert({
     *   create: {
     *     // ... data to create a CampaignActivation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignActivation we want to update
     *   }
     * })
     */
    upsert<T extends CampaignActivationUpsertArgs>(args: SelectSubset<T, CampaignActivationUpsertArgs<ExtArgs>>): Prisma__CampaignActivationClient<$Result.GetResult<Prisma.$CampaignActivationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignActivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivationCountArgs} args - Arguments to filter CampaignActivations to count.
     * @example
     * // Count the number of CampaignActivations
     * const count = await prisma.campaignActivation.count({
     *   where: {
     *     // ... the filter for the CampaignActivations we want to count
     *   }
     * })
    **/
    count<T extends CampaignActivationCountArgs>(
      args?: Subset<T, CampaignActivationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignActivationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignActivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignActivationAggregateArgs>(args: Subset<T, CampaignActivationAggregateArgs>): Prisma.PrismaPromise<GetCampaignActivationAggregateType<T>>

    /**
     * Group by CampaignActivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignActivationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignActivationGroupByArgs['orderBy'] }
        : { orderBy?: CampaignActivationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignActivationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignActivationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignActivation model
   */
  readonly fields: CampaignActivationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignActivation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignActivationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignActivation model
   */ 
  interface CampaignActivationFieldRefs {
    readonly id: FieldRef<"CampaignActivation", 'String'>
    readonly campaignId: FieldRef<"CampaignActivation", 'String'>
    readonly platform: FieldRef<"CampaignActivation", 'String'>
    readonly assetType: FieldRef<"CampaignActivation", 'String'>
    readonly assetReference: FieldRef<"CampaignActivation", 'String'>
    readonly activationTime: FieldRef<"CampaignActivation", 'DateTime'>
    readonly status: FieldRef<"CampaignActivation", 'String'>
    readonly activationResult: FieldRef<"CampaignActivation", 'String'>
    readonly createdAt: FieldRef<"CampaignActivation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignActivation findUnique
   */
  export type CampaignActivationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivation to fetch.
     */
    where: CampaignActivationWhereUniqueInput
  }

  /**
   * CampaignActivation findUniqueOrThrow
   */
  export type CampaignActivationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivation to fetch.
     */
    where: CampaignActivationWhereUniqueInput
  }

  /**
   * CampaignActivation findFirst
   */
  export type CampaignActivationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivation to fetch.
     */
    where?: CampaignActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignActivations to fetch.
     */
    orderBy?: CampaignActivationOrderByWithRelationInput | CampaignActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignActivations.
     */
    cursor?: CampaignActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignActivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignActivations.
     */
    distinct?: CampaignActivationScalarFieldEnum | CampaignActivationScalarFieldEnum[]
  }

  /**
   * CampaignActivation findFirstOrThrow
   */
  export type CampaignActivationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivation to fetch.
     */
    where?: CampaignActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignActivations to fetch.
     */
    orderBy?: CampaignActivationOrderByWithRelationInput | CampaignActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignActivations.
     */
    cursor?: CampaignActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignActivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignActivations.
     */
    distinct?: CampaignActivationScalarFieldEnum | CampaignActivationScalarFieldEnum[]
  }

  /**
   * CampaignActivation findMany
   */
  export type CampaignActivationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivations to fetch.
     */
    where?: CampaignActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignActivations to fetch.
     */
    orderBy?: CampaignActivationOrderByWithRelationInput | CampaignActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignActivations.
     */
    cursor?: CampaignActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignActivations.
     */
    skip?: number
    distinct?: CampaignActivationScalarFieldEnum | CampaignActivationScalarFieldEnum[]
  }

  /**
   * CampaignActivation create
   */
  export type CampaignActivationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignActivation.
     */
    data: XOR<CampaignActivationCreateInput, CampaignActivationUncheckedCreateInput>
  }

  /**
   * CampaignActivation createMany
   */
  export type CampaignActivationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignActivations.
     */
    data: CampaignActivationCreateManyInput | CampaignActivationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignActivation createManyAndReturn
   */
  export type CampaignActivationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignActivations.
     */
    data: CampaignActivationCreateManyInput | CampaignActivationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignActivation update
   */
  export type CampaignActivationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignActivation.
     */
    data: XOR<CampaignActivationUpdateInput, CampaignActivationUncheckedUpdateInput>
    /**
     * Choose, which CampaignActivation to update.
     */
    where: CampaignActivationWhereUniqueInput
  }

  /**
   * CampaignActivation updateMany
   */
  export type CampaignActivationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignActivations.
     */
    data: XOR<CampaignActivationUpdateManyMutationInput, CampaignActivationUncheckedUpdateManyInput>
    /**
     * Filter which CampaignActivations to update
     */
    where?: CampaignActivationWhereInput
  }

  /**
   * CampaignActivation upsert
   */
  export type CampaignActivationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignActivation to update in case it exists.
     */
    where: CampaignActivationWhereUniqueInput
    /**
     * In case the CampaignActivation found by the `where` argument doesn't exist, create a new CampaignActivation with this data.
     */
    create: XOR<CampaignActivationCreateInput, CampaignActivationUncheckedCreateInput>
    /**
     * In case the CampaignActivation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignActivationUpdateInput, CampaignActivationUncheckedUpdateInput>
  }

  /**
   * CampaignActivation delete
   */
  export type CampaignActivationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
    /**
     * Filter which CampaignActivation to delete.
     */
    where: CampaignActivationWhereUniqueInput
  }

  /**
   * CampaignActivation deleteMany
   */
  export type CampaignActivationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignActivations to delete
     */
    where?: CampaignActivationWhereInput
  }

  /**
   * CampaignActivation without action
   */
  export type CampaignActivationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivation
     */
    select?: CampaignActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivationInclude<ExtArgs> | null
  }


  /**
   * Model CustomerEngagementLog
   */

  export type AggregateCustomerEngagementLog = {
    _count: CustomerEngagementLogCountAggregateOutputType | null
    _avg: CustomerEngagementLogAvgAggregateOutputType | null
    _sum: CustomerEngagementLogSumAggregateOutputType | null
    _min: CustomerEngagementLogMinAggregateOutputType | null
    _max: CustomerEngagementLogMaxAggregateOutputType | null
  }

  export type CustomerEngagementLogAvgAggregateOutputType = {
    responseTime: number | null
    csatScore: number | null
  }

  export type CustomerEngagementLogSumAggregateOutputType = {
    responseTime: number | null
    csatScore: number | null
  }

  export type CustomerEngagementLogMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    sessionId: string | null
    interactionType: string | null
    message: string | null
    resolutionStatus: string | null
    responseTime: number | null
    csatScore: number | null
    createdAt: Date | null
  }

  export type CustomerEngagementLogMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    sessionId: string | null
    interactionType: string | null
    message: string | null
    resolutionStatus: string | null
    responseTime: number | null
    csatScore: number | null
    createdAt: Date | null
  }

  export type CustomerEngagementLogCountAggregateOutputType = {
    id: number
    campaignId: number
    userId: number
    sessionId: number
    interactionType: number
    message: number
    resolutionStatus: number
    responseTime: number
    csatScore: number
    createdAt: number
    _all: number
  }


  export type CustomerEngagementLogAvgAggregateInputType = {
    responseTime?: true
    csatScore?: true
  }

  export type CustomerEngagementLogSumAggregateInputType = {
    responseTime?: true
    csatScore?: true
  }

  export type CustomerEngagementLogMinAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    sessionId?: true
    interactionType?: true
    message?: true
    resolutionStatus?: true
    responseTime?: true
    csatScore?: true
    createdAt?: true
  }

  export type CustomerEngagementLogMaxAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    sessionId?: true
    interactionType?: true
    message?: true
    resolutionStatus?: true
    responseTime?: true
    csatScore?: true
    createdAt?: true
  }

  export type CustomerEngagementLogCountAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    sessionId?: true
    interactionType?: true
    message?: true
    resolutionStatus?: true
    responseTime?: true
    csatScore?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerEngagementLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerEngagementLog to aggregate.
     */
    where?: CustomerEngagementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerEngagementLogs to fetch.
     */
    orderBy?: CustomerEngagementLogOrderByWithRelationInput | CustomerEngagementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerEngagementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerEngagementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerEngagementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerEngagementLogs
    **/
    _count?: true | CustomerEngagementLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerEngagementLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerEngagementLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerEngagementLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerEngagementLogMaxAggregateInputType
  }

  export type GetCustomerEngagementLogAggregateType<T extends CustomerEngagementLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerEngagementLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerEngagementLog[P]>
      : GetScalarType<T[P], AggregateCustomerEngagementLog[P]>
  }




  export type CustomerEngagementLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerEngagementLogWhereInput
    orderBy?: CustomerEngagementLogOrderByWithAggregationInput | CustomerEngagementLogOrderByWithAggregationInput[]
    by: CustomerEngagementLogScalarFieldEnum[] | CustomerEngagementLogScalarFieldEnum
    having?: CustomerEngagementLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerEngagementLogCountAggregateInputType | true
    _avg?: CustomerEngagementLogAvgAggregateInputType
    _sum?: CustomerEngagementLogSumAggregateInputType
    _min?: CustomerEngagementLogMinAggregateInputType
    _max?: CustomerEngagementLogMaxAggregateInputType
  }

  export type CustomerEngagementLogGroupByOutputType = {
    id: string
    campaignId: string
    userId: string
    sessionId: string
    interactionType: string
    message: string
    resolutionStatus: string
    responseTime: number
    csatScore: number | null
    createdAt: Date
    _count: CustomerEngagementLogCountAggregateOutputType | null
    _avg: CustomerEngagementLogAvgAggregateOutputType | null
    _sum: CustomerEngagementLogSumAggregateOutputType | null
    _min: CustomerEngagementLogMinAggregateOutputType | null
    _max: CustomerEngagementLogMaxAggregateOutputType | null
  }

  type GetCustomerEngagementLogGroupByPayload<T extends CustomerEngagementLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerEngagementLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerEngagementLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerEngagementLogGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerEngagementLogGroupByOutputType[P]>
        }
      >
    >


  export type CustomerEngagementLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    sessionId?: boolean
    interactionType?: boolean
    message?: boolean
    resolutionStatus?: boolean
    responseTime?: boolean
    csatScore?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerEngagementLog"]>

  export type CustomerEngagementLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    sessionId?: boolean
    interactionType?: boolean
    message?: boolean
    resolutionStatus?: boolean
    responseTime?: boolean
    csatScore?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerEngagementLog"]>

  export type CustomerEngagementLogSelectScalar = {
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    sessionId?: boolean
    interactionType?: boolean
    message?: boolean
    resolutionStatus?: boolean
    responseTime?: boolean
    csatScore?: boolean
    createdAt?: boolean
  }

  export type CustomerEngagementLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CustomerEngagementLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CustomerEngagementLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerEngagementLog"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      userId: string
      sessionId: string
      interactionType: string
      message: string
      resolutionStatus: string
      responseTime: number
      csatScore: number | null
      createdAt: Date
    }, ExtArgs["result"]["customerEngagementLog"]>
    composites: {}
  }

  type CustomerEngagementLogGetPayload<S extends boolean | null | undefined | CustomerEngagementLogDefaultArgs> = $Result.GetResult<Prisma.$CustomerEngagementLogPayload, S>

  type CustomerEngagementLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerEngagementLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerEngagementLogCountAggregateInputType | true
    }

  export interface CustomerEngagementLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerEngagementLog'], meta: { name: 'CustomerEngagementLog' } }
    /**
     * Find zero or one CustomerEngagementLog that matches the filter.
     * @param {CustomerEngagementLogFindUniqueArgs} args - Arguments to find a CustomerEngagementLog
     * @example
     * // Get one CustomerEngagementLog
     * const customerEngagementLog = await prisma.customerEngagementLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerEngagementLogFindUniqueArgs>(args: SelectSubset<T, CustomerEngagementLogFindUniqueArgs<ExtArgs>>): Prisma__CustomerEngagementLogClient<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerEngagementLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerEngagementLogFindUniqueOrThrowArgs} args - Arguments to find a CustomerEngagementLog
     * @example
     * // Get one CustomerEngagementLog
     * const customerEngagementLog = await prisma.customerEngagementLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerEngagementLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerEngagementLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerEngagementLogClient<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerEngagementLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEngagementLogFindFirstArgs} args - Arguments to find a CustomerEngagementLog
     * @example
     * // Get one CustomerEngagementLog
     * const customerEngagementLog = await prisma.customerEngagementLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerEngagementLogFindFirstArgs>(args?: SelectSubset<T, CustomerEngagementLogFindFirstArgs<ExtArgs>>): Prisma__CustomerEngagementLogClient<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerEngagementLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEngagementLogFindFirstOrThrowArgs} args - Arguments to find a CustomerEngagementLog
     * @example
     * // Get one CustomerEngagementLog
     * const customerEngagementLog = await prisma.customerEngagementLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerEngagementLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerEngagementLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerEngagementLogClient<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerEngagementLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEngagementLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerEngagementLogs
     * const customerEngagementLogs = await prisma.customerEngagementLog.findMany()
     * 
     * // Get first 10 CustomerEngagementLogs
     * const customerEngagementLogs = await prisma.customerEngagementLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerEngagementLogWithIdOnly = await prisma.customerEngagementLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerEngagementLogFindManyArgs>(args?: SelectSubset<T, CustomerEngagementLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerEngagementLog.
     * @param {CustomerEngagementLogCreateArgs} args - Arguments to create a CustomerEngagementLog.
     * @example
     * // Create one CustomerEngagementLog
     * const CustomerEngagementLog = await prisma.customerEngagementLog.create({
     *   data: {
     *     // ... data to create a CustomerEngagementLog
     *   }
     * })
     * 
     */
    create<T extends CustomerEngagementLogCreateArgs>(args: SelectSubset<T, CustomerEngagementLogCreateArgs<ExtArgs>>): Prisma__CustomerEngagementLogClient<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerEngagementLogs.
     * @param {CustomerEngagementLogCreateManyArgs} args - Arguments to create many CustomerEngagementLogs.
     * @example
     * // Create many CustomerEngagementLogs
     * const customerEngagementLog = await prisma.customerEngagementLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerEngagementLogCreateManyArgs>(args?: SelectSubset<T, CustomerEngagementLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerEngagementLogs and returns the data saved in the database.
     * @param {CustomerEngagementLogCreateManyAndReturnArgs} args - Arguments to create many CustomerEngagementLogs.
     * @example
     * // Create many CustomerEngagementLogs
     * const customerEngagementLog = await prisma.customerEngagementLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerEngagementLogs and only return the `id`
     * const customerEngagementLogWithIdOnly = await prisma.customerEngagementLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerEngagementLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerEngagementLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerEngagementLog.
     * @param {CustomerEngagementLogDeleteArgs} args - Arguments to delete one CustomerEngagementLog.
     * @example
     * // Delete one CustomerEngagementLog
     * const CustomerEngagementLog = await prisma.customerEngagementLog.delete({
     *   where: {
     *     // ... filter to delete one CustomerEngagementLog
     *   }
     * })
     * 
     */
    delete<T extends CustomerEngagementLogDeleteArgs>(args: SelectSubset<T, CustomerEngagementLogDeleteArgs<ExtArgs>>): Prisma__CustomerEngagementLogClient<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerEngagementLog.
     * @param {CustomerEngagementLogUpdateArgs} args - Arguments to update one CustomerEngagementLog.
     * @example
     * // Update one CustomerEngagementLog
     * const customerEngagementLog = await prisma.customerEngagementLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerEngagementLogUpdateArgs>(args: SelectSubset<T, CustomerEngagementLogUpdateArgs<ExtArgs>>): Prisma__CustomerEngagementLogClient<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerEngagementLogs.
     * @param {CustomerEngagementLogDeleteManyArgs} args - Arguments to filter CustomerEngagementLogs to delete.
     * @example
     * // Delete a few CustomerEngagementLogs
     * const { count } = await prisma.customerEngagementLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerEngagementLogDeleteManyArgs>(args?: SelectSubset<T, CustomerEngagementLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerEngagementLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEngagementLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerEngagementLogs
     * const customerEngagementLog = await prisma.customerEngagementLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerEngagementLogUpdateManyArgs>(args: SelectSubset<T, CustomerEngagementLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerEngagementLog.
     * @param {CustomerEngagementLogUpsertArgs} args - Arguments to update or create a CustomerEngagementLog.
     * @example
     * // Update or create a CustomerEngagementLog
     * const customerEngagementLog = await prisma.customerEngagementLog.upsert({
     *   create: {
     *     // ... data to create a CustomerEngagementLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerEngagementLog we want to update
     *   }
     * })
     */
    upsert<T extends CustomerEngagementLogUpsertArgs>(args: SelectSubset<T, CustomerEngagementLogUpsertArgs<ExtArgs>>): Prisma__CustomerEngagementLogClient<$Result.GetResult<Prisma.$CustomerEngagementLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerEngagementLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEngagementLogCountArgs} args - Arguments to filter CustomerEngagementLogs to count.
     * @example
     * // Count the number of CustomerEngagementLogs
     * const count = await prisma.customerEngagementLog.count({
     *   where: {
     *     // ... the filter for the CustomerEngagementLogs we want to count
     *   }
     * })
    **/
    count<T extends CustomerEngagementLogCountArgs>(
      args?: Subset<T, CustomerEngagementLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerEngagementLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerEngagementLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEngagementLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerEngagementLogAggregateArgs>(args: Subset<T, CustomerEngagementLogAggregateArgs>): Prisma.PrismaPromise<GetCustomerEngagementLogAggregateType<T>>

    /**
     * Group by CustomerEngagementLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerEngagementLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerEngagementLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerEngagementLogGroupByArgs['orderBy'] }
        : { orderBy?: CustomerEngagementLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerEngagementLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerEngagementLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerEngagementLog model
   */
  readonly fields: CustomerEngagementLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerEngagementLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerEngagementLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerEngagementLog model
   */ 
  interface CustomerEngagementLogFieldRefs {
    readonly id: FieldRef<"CustomerEngagementLog", 'String'>
    readonly campaignId: FieldRef<"CustomerEngagementLog", 'String'>
    readonly userId: FieldRef<"CustomerEngagementLog", 'String'>
    readonly sessionId: FieldRef<"CustomerEngagementLog", 'String'>
    readonly interactionType: FieldRef<"CustomerEngagementLog", 'String'>
    readonly message: FieldRef<"CustomerEngagementLog", 'String'>
    readonly resolutionStatus: FieldRef<"CustomerEngagementLog", 'String'>
    readonly responseTime: FieldRef<"CustomerEngagementLog", 'Int'>
    readonly csatScore: FieldRef<"CustomerEngagementLog", 'Int'>
    readonly createdAt: FieldRef<"CustomerEngagementLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerEngagementLog findUnique
   */
  export type CustomerEngagementLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    /**
     * Filter, which CustomerEngagementLog to fetch.
     */
    where: CustomerEngagementLogWhereUniqueInput
  }

  /**
   * CustomerEngagementLog findUniqueOrThrow
   */
  export type CustomerEngagementLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    /**
     * Filter, which CustomerEngagementLog to fetch.
     */
    where: CustomerEngagementLogWhereUniqueInput
  }

  /**
   * CustomerEngagementLog findFirst
   */
  export type CustomerEngagementLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    /**
     * Filter, which CustomerEngagementLog to fetch.
     */
    where?: CustomerEngagementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerEngagementLogs to fetch.
     */
    orderBy?: CustomerEngagementLogOrderByWithRelationInput | CustomerEngagementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerEngagementLogs.
     */
    cursor?: CustomerEngagementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerEngagementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerEngagementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerEngagementLogs.
     */
    distinct?: CustomerEngagementLogScalarFieldEnum | CustomerEngagementLogScalarFieldEnum[]
  }

  /**
   * CustomerEngagementLog findFirstOrThrow
   */
  export type CustomerEngagementLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    /**
     * Filter, which CustomerEngagementLog to fetch.
     */
    where?: CustomerEngagementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerEngagementLogs to fetch.
     */
    orderBy?: CustomerEngagementLogOrderByWithRelationInput | CustomerEngagementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerEngagementLogs.
     */
    cursor?: CustomerEngagementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerEngagementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerEngagementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerEngagementLogs.
     */
    distinct?: CustomerEngagementLogScalarFieldEnum | CustomerEngagementLogScalarFieldEnum[]
  }

  /**
   * CustomerEngagementLog findMany
   */
  export type CustomerEngagementLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    /**
     * Filter, which CustomerEngagementLogs to fetch.
     */
    where?: CustomerEngagementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerEngagementLogs to fetch.
     */
    orderBy?: CustomerEngagementLogOrderByWithRelationInput | CustomerEngagementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerEngagementLogs.
     */
    cursor?: CustomerEngagementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerEngagementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerEngagementLogs.
     */
    skip?: number
    distinct?: CustomerEngagementLogScalarFieldEnum | CustomerEngagementLogScalarFieldEnum[]
  }

  /**
   * CustomerEngagementLog create
   */
  export type CustomerEngagementLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerEngagementLog.
     */
    data: XOR<CustomerEngagementLogCreateInput, CustomerEngagementLogUncheckedCreateInput>
  }

  /**
   * CustomerEngagementLog createMany
   */
  export type CustomerEngagementLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerEngagementLogs.
     */
    data: CustomerEngagementLogCreateManyInput | CustomerEngagementLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerEngagementLog createManyAndReturn
   */
  export type CustomerEngagementLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerEngagementLogs.
     */
    data: CustomerEngagementLogCreateManyInput | CustomerEngagementLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerEngagementLog update
   */
  export type CustomerEngagementLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerEngagementLog.
     */
    data: XOR<CustomerEngagementLogUpdateInput, CustomerEngagementLogUncheckedUpdateInput>
    /**
     * Choose, which CustomerEngagementLog to update.
     */
    where: CustomerEngagementLogWhereUniqueInput
  }

  /**
   * CustomerEngagementLog updateMany
   */
  export type CustomerEngagementLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerEngagementLogs.
     */
    data: XOR<CustomerEngagementLogUpdateManyMutationInput, CustomerEngagementLogUncheckedUpdateManyInput>
    /**
     * Filter which CustomerEngagementLogs to update
     */
    where?: CustomerEngagementLogWhereInput
  }

  /**
   * CustomerEngagementLog upsert
   */
  export type CustomerEngagementLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerEngagementLog to update in case it exists.
     */
    where: CustomerEngagementLogWhereUniqueInput
    /**
     * In case the CustomerEngagementLog found by the `where` argument doesn't exist, create a new CustomerEngagementLog with this data.
     */
    create: XOR<CustomerEngagementLogCreateInput, CustomerEngagementLogUncheckedCreateInput>
    /**
     * In case the CustomerEngagementLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerEngagementLogUpdateInput, CustomerEngagementLogUncheckedUpdateInput>
  }

  /**
   * CustomerEngagementLog delete
   */
  export type CustomerEngagementLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
    /**
     * Filter which CustomerEngagementLog to delete.
     */
    where: CustomerEngagementLogWhereUniqueInput
  }

  /**
   * CustomerEngagementLog deleteMany
   */
  export type CustomerEngagementLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerEngagementLogs to delete
     */
    where?: CustomerEngagementLogWhereInput
  }

  /**
   * CustomerEngagementLog without action
   */
  export type CustomerEngagementLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerEngagementLog
     */
    select?: CustomerEngagementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerEngagementLogInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceReport
   */

  export type AggregatePerformanceReport = {
    _count: PerformanceReportCountAggregateOutputType | null
    _avg: PerformanceReportAvgAggregateOutputType | null
    _sum: PerformanceReportSumAggregateOutputType | null
    _min: PerformanceReportMinAggregateOutputType | null
    _max: PerformanceReportMaxAggregateOutputType | null
  }

  export type PerformanceReportAvgAggregateOutputType = {
    impressions: number | null
    clicks: number | null
    qrScans: number | null
    conversions: number | null
    chatbotSessions: number | null
    escalations: number | null
    escalationRate: number | null
    avgBotResponseTime: number | null
    avgHumanResponseTime: number | null
    csatScoreAverage: number | null
  }

  export type PerformanceReportSumAggregateOutputType = {
    impressions: number | null
    clicks: number | null
    qrScans: number | null
    conversions: number | null
    chatbotSessions: number | null
    escalations: number | null
    escalationRate: number | null
    avgBotResponseTime: number | null
    avgHumanResponseTime: number | null
    csatScoreAverage: number | null
  }

  export type PerformanceReportMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    qrScans: number | null
    conversions: number | null
    chatbotSessions: number | null
    escalations: number | null
    escalationRate: number | null
    avgBotResponseTime: number | null
    avgHumanResponseTime: number | null
    csatScoreAverage: number | null
    anomalies: string | null
    createdAt: Date | null
  }

  export type PerformanceReportMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    qrScans: number | null
    conversions: number | null
    chatbotSessions: number | null
    escalations: number | null
    escalationRate: number | null
    avgBotResponseTime: number | null
    avgHumanResponseTime: number | null
    csatScoreAverage: number | null
    anomalies: string | null
    createdAt: Date | null
  }

  export type PerformanceReportCountAggregateOutputType = {
    id: number
    campaignId: number
    date: number
    impressions: number
    clicks: number
    qrScans: number
    conversions: number
    chatbotSessions: number
    escalations: number
    escalationRate: number
    avgBotResponseTime: number
    avgHumanResponseTime: number
    csatScoreAverage: number
    anomalies: number
    createdAt: number
    _all: number
  }


  export type PerformanceReportAvgAggregateInputType = {
    impressions?: true
    clicks?: true
    qrScans?: true
    conversions?: true
    chatbotSessions?: true
    escalations?: true
    escalationRate?: true
    avgBotResponseTime?: true
    avgHumanResponseTime?: true
    csatScoreAverage?: true
  }

  export type PerformanceReportSumAggregateInputType = {
    impressions?: true
    clicks?: true
    qrScans?: true
    conversions?: true
    chatbotSessions?: true
    escalations?: true
    escalationRate?: true
    avgBotResponseTime?: true
    avgHumanResponseTime?: true
    csatScoreAverage?: true
  }

  export type PerformanceReportMinAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    impressions?: true
    clicks?: true
    qrScans?: true
    conversions?: true
    chatbotSessions?: true
    escalations?: true
    escalationRate?: true
    avgBotResponseTime?: true
    avgHumanResponseTime?: true
    csatScoreAverage?: true
    anomalies?: true
    createdAt?: true
  }

  export type PerformanceReportMaxAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    impressions?: true
    clicks?: true
    qrScans?: true
    conversions?: true
    chatbotSessions?: true
    escalations?: true
    escalationRate?: true
    avgBotResponseTime?: true
    avgHumanResponseTime?: true
    csatScoreAverage?: true
    anomalies?: true
    createdAt?: true
  }

  export type PerformanceReportCountAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    impressions?: true
    clicks?: true
    qrScans?: true
    conversions?: true
    chatbotSessions?: true
    escalations?: true
    escalationRate?: true
    avgBotResponseTime?: true
    avgHumanResponseTime?: true
    csatScoreAverage?: true
    anomalies?: true
    createdAt?: true
    _all?: true
  }

  export type PerformanceReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReport to aggregate.
     */
    where?: PerformanceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReports to fetch.
     */
    orderBy?: PerformanceReportOrderByWithRelationInput | PerformanceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceReports
    **/
    _count?: true | PerformanceReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceReportMaxAggregateInputType
  }

  export type GetPerformanceReportAggregateType<T extends PerformanceReportAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceReport[P]>
      : GetScalarType<T[P], AggregatePerformanceReport[P]>
  }




  export type PerformanceReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReportWhereInput
    orderBy?: PerformanceReportOrderByWithAggregationInput | PerformanceReportOrderByWithAggregationInput[]
    by: PerformanceReportScalarFieldEnum[] | PerformanceReportScalarFieldEnum
    having?: PerformanceReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceReportCountAggregateInputType | true
    _avg?: PerformanceReportAvgAggregateInputType
    _sum?: PerformanceReportSumAggregateInputType
    _min?: PerformanceReportMinAggregateInputType
    _max?: PerformanceReportMaxAggregateInputType
  }

  export type PerformanceReportGroupByOutputType = {
    id: string
    campaignId: string
    date: Date
    impressions: number
    clicks: number
    qrScans: number
    conversions: number
    chatbotSessions: number
    escalations: number
    escalationRate: number
    avgBotResponseTime: number
    avgHumanResponseTime: number
    csatScoreAverage: number
    anomalies: string | null
    createdAt: Date
    _count: PerformanceReportCountAggregateOutputType | null
    _avg: PerformanceReportAvgAggregateOutputType | null
    _sum: PerformanceReportSumAggregateOutputType | null
    _min: PerformanceReportMinAggregateOutputType | null
    _max: PerformanceReportMaxAggregateOutputType | null
  }

  type GetPerformanceReportGroupByPayload<T extends PerformanceReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceReportGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceReportGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    qrScans?: boolean
    conversions?: boolean
    chatbotSessions?: boolean
    escalations?: boolean
    escalationRate?: boolean
    avgBotResponseTime?: boolean
    avgHumanResponseTime?: boolean
    csatScoreAverage?: boolean
    anomalies?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReport"]>

  export type PerformanceReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    qrScans?: boolean
    conversions?: boolean
    chatbotSessions?: boolean
    escalations?: boolean
    escalationRate?: boolean
    avgBotResponseTime?: boolean
    avgHumanResponseTime?: boolean
    csatScoreAverage?: boolean
    anomalies?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReport"]>

  export type PerformanceReportSelectScalar = {
    id?: boolean
    campaignId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    qrScans?: boolean
    conversions?: boolean
    chatbotSessions?: boolean
    escalations?: boolean
    escalationRate?: boolean
    avgBotResponseTime?: boolean
    avgHumanResponseTime?: boolean
    csatScoreAverage?: boolean
    anomalies?: boolean
    createdAt?: boolean
  }

  export type PerformanceReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type PerformanceReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $PerformanceReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceReport"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      date: Date
      impressions: number
      clicks: number
      qrScans: number
      conversions: number
      chatbotSessions: number
      escalations: number
      escalationRate: number
      avgBotResponseTime: number
      avgHumanResponseTime: number
      csatScoreAverage: number
      anomalies: string | null
      createdAt: Date
    }, ExtArgs["result"]["performanceReport"]>
    composites: {}
  }

  type PerformanceReportGetPayload<S extends boolean | null | undefined | PerformanceReportDefaultArgs> = $Result.GetResult<Prisma.$PerformanceReportPayload, S>

  type PerformanceReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PerformanceReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PerformanceReportCountAggregateInputType | true
    }

  export interface PerformanceReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceReport'], meta: { name: 'PerformanceReport' } }
    /**
     * Find zero or one PerformanceReport that matches the filter.
     * @param {PerformanceReportFindUniqueArgs} args - Arguments to find a PerformanceReport
     * @example
     * // Get one PerformanceReport
     * const performanceReport = await prisma.performanceReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceReportFindUniqueArgs>(args: SelectSubset<T, PerformanceReportFindUniqueArgs<ExtArgs>>): Prisma__PerformanceReportClient<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PerformanceReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PerformanceReportFindUniqueOrThrowArgs} args - Arguments to find a PerformanceReport
     * @example
     * // Get one PerformanceReport
     * const performanceReport = await prisma.performanceReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceReportFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceReportClient<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PerformanceReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReportFindFirstArgs} args - Arguments to find a PerformanceReport
     * @example
     * // Get one PerformanceReport
     * const performanceReport = await prisma.performanceReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceReportFindFirstArgs>(args?: SelectSubset<T, PerformanceReportFindFirstArgs<ExtArgs>>): Prisma__PerformanceReportClient<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PerformanceReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReportFindFirstOrThrowArgs} args - Arguments to find a PerformanceReport
     * @example
     * // Get one PerformanceReport
     * const performanceReport = await prisma.performanceReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceReportFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceReportClient<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PerformanceReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceReports
     * const performanceReports = await prisma.performanceReport.findMany()
     * 
     * // Get first 10 PerformanceReports
     * const performanceReports = await prisma.performanceReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceReportWithIdOnly = await prisma.performanceReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceReportFindManyArgs>(args?: SelectSubset<T, PerformanceReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PerformanceReport.
     * @param {PerformanceReportCreateArgs} args - Arguments to create a PerformanceReport.
     * @example
     * // Create one PerformanceReport
     * const PerformanceReport = await prisma.performanceReport.create({
     *   data: {
     *     // ... data to create a PerformanceReport
     *   }
     * })
     * 
     */
    create<T extends PerformanceReportCreateArgs>(args: SelectSubset<T, PerformanceReportCreateArgs<ExtArgs>>): Prisma__PerformanceReportClient<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PerformanceReports.
     * @param {PerformanceReportCreateManyArgs} args - Arguments to create many PerformanceReports.
     * @example
     * // Create many PerformanceReports
     * const performanceReport = await prisma.performanceReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceReportCreateManyArgs>(args?: SelectSubset<T, PerformanceReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceReports and returns the data saved in the database.
     * @param {PerformanceReportCreateManyAndReturnArgs} args - Arguments to create many PerformanceReports.
     * @example
     * // Create many PerformanceReports
     * const performanceReport = await prisma.performanceReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceReports and only return the `id`
     * const performanceReportWithIdOnly = await prisma.performanceReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceReportCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PerformanceReport.
     * @param {PerformanceReportDeleteArgs} args - Arguments to delete one PerformanceReport.
     * @example
     * // Delete one PerformanceReport
     * const PerformanceReport = await prisma.performanceReport.delete({
     *   where: {
     *     // ... filter to delete one PerformanceReport
     *   }
     * })
     * 
     */
    delete<T extends PerformanceReportDeleteArgs>(args: SelectSubset<T, PerformanceReportDeleteArgs<ExtArgs>>): Prisma__PerformanceReportClient<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PerformanceReport.
     * @param {PerformanceReportUpdateArgs} args - Arguments to update one PerformanceReport.
     * @example
     * // Update one PerformanceReport
     * const performanceReport = await prisma.performanceReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceReportUpdateArgs>(args: SelectSubset<T, PerformanceReportUpdateArgs<ExtArgs>>): Prisma__PerformanceReportClient<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PerformanceReports.
     * @param {PerformanceReportDeleteManyArgs} args - Arguments to filter PerformanceReports to delete.
     * @example
     * // Delete a few PerformanceReports
     * const { count } = await prisma.performanceReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceReportDeleteManyArgs>(args?: SelectSubset<T, PerformanceReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceReports
     * const performanceReport = await prisma.performanceReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceReportUpdateManyArgs>(args: SelectSubset<T, PerformanceReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceReport.
     * @param {PerformanceReportUpsertArgs} args - Arguments to update or create a PerformanceReport.
     * @example
     * // Update or create a PerformanceReport
     * const performanceReport = await prisma.performanceReport.upsert({
     *   create: {
     *     // ... data to create a PerformanceReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceReport we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceReportUpsertArgs>(args: SelectSubset<T, PerformanceReportUpsertArgs<ExtArgs>>): Prisma__PerformanceReportClient<$Result.GetResult<Prisma.$PerformanceReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PerformanceReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReportCountArgs} args - Arguments to filter PerformanceReports to count.
     * @example
     * // Count the number of PerformanceReports
     * const count = await prisma.performanceReport.count({
     *   where: {
     *     // ... the filter for the PerformanceReports we want to count
     *   }
     * })
    **/
    count<T extends PerformanceReportCountArgs>(
      args?: Subset<T, PerformanceReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceReportAggregateArgs>(args: Subset<T, PerformanceReportAggregateArgs>): Prisma.PrismaPromise<GetPerformanceReportAggregateType<T>>

    /**
     * Group by PerformanceReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceReportGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceReport model
   */
  readonly fields: PerformanceReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceReport model
   */ 
  interface PerformanceReportFieldRefs {
    readonly id: FieldRef<"PerformanceReport", 'String'>
    readonly campaignId: FieldRef<"PerformanceReport", 'String'>
    readonly date: FieldRef<"PerformanceReport", 'DateTime'>
    readonly impressions: FieldRef<"PerformanceReport", 'Int'>
    readonly clicks: FieldRef<"PerformanceReport", 'Int'>
    readonly qrScans: FieldRef<"PerformanceReport", 'Int'>
    readonly conversions: FieldRef<"PerformanceReport", 'Int'>
    readonly chatbotSessions: FieldRef<"PerformanceReport", 'Int'>
    readonly escalations: FieldRef<"PerformanceReport", 'Int'>
    readonly escalationRate: FieldRef<"PerformanceReport", 'Float'>
    readonly avgBotResponseTime: FieldRef<"PerformanceReport", 'Int'>
    readonly avgHumanResponseTime: FieldRef<"PerformanceReport", 'Int'>
    readonly csatScoreAverage: FieldRef<"PerformanceReport", 'Float'>
    readonly anomalies: FieldRef<"PerformanceReport", 'String'>
    readonly createdAt: FieldRef<"PerformanceReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceReport findUnique
   */
  export type PerformanceReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReport to fetch.
     */
    where: PerformanceReportWhereUniqueInput
  }

  /**
   * PerformanceReport findUniqueOrThrow
   */
  export type PerformanceReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReport to fetch.
     */
    where: PerformanceReportWhereUniqueInput
  }

  /**
   * PerformanceReport findFirst
   */
  export type PerformanceReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReport to fetch.
     */
    where?: PerformanceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReports to fetch.
     */
    orderBy?: PerformanceReportOrderByWithRelationInput | PerformanceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReports.
     */
    cursor?: PerformanceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReports.
     */
    distinct?: PerformanceReportScalarFieldEnum | PerformanceReportScalarFieldEnum[]
  }

  /**
   * PerformanceReport findFirstOrThrow
   */
  export type PerformanceReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReport to fetch.
     */
    where?: PerformanceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReports to fetch.
     */
    orderBy?: PerformanceReportOrderByWithRelationInput | PerformanceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReports.
     */
    cursor?: PerformanceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReports.
     */
    distinct?: PerformanceReportScalarFieldEnum | PerformanceReportScalarFieldEnum[]
  }

  /**
   * PerformanceReport findMany
   */
  export type PerformanceReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReports to fetch.
     */
    where?: PerformanceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReports to fetch.
     */
    orderBy?: PerformanceReportOrderByWithRelationInput | PerformanceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceReports.
     */
    cursor?: PerformanceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReports.
     */
    skip?: number
    distinct?: PerformanceReportScalarFieldEnum | PerformanceReportScalarFieldEnum[]
  }

  /**
   * PerformanceReport create
   */
  export type PerformanceReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceReport.
     */
    data: XOR<PerformanceReportCreateInput, PerformanceReportUncheckedCreateInput>
  }

  /**
   * PerformanceReport createMany
   */
  export type PerformanceReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceReports.
     */
    data: PerformanceReportCreateManyInput | PerformanceReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceReport createManyAndReturn
   */
  export type PerformanceReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PerformanceReports.
     */
    data: PerformanceReportCreateManyInput | PerformanceReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceReport update
   */
  export type PerformanceReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceReport.
     */
    data: XOR<PerformanceReportUpdateInput, PerformanceReportUncheckedUpdateInput>
    /**
     * Choose, which PerformanceReport to update.
     */
    where: PerformanceReportWhereUniqueInput
  }

  /**
   * PerformanceReport updateMany
   */
  export type PerformanceReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceReports.
     */
    data: XOR<PerformanceReportUpdateManyMutationInput, PerformanceReportUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceReports to update
     */
    where?: PerformanceReportWhereInput
  }

  /**
   * PerformanceReport upsert
   */
  export type PerformanceReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceReport to update in case it exists.
     */
    where: PerformanceReportWhereUniqueInput
    /**
     * In case the PerformanceReport found by the `where` argument doesn't exist, create a new PerformanceReport with this data.
     */
    create: XOR<PerformanceReportCreateInput, PerformanceReportUncheckedCreateInput>
    /**
     * In case the PerformanceReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceReportUpdateInput, PerformanceReportUncheckedUpdateInput>
  }

  /**
   * PerformanceReport delete
   */
  export type PerformanceReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
    /**
     * Filter which PerformanceReport to delete.
     */
    where: PerformanceReportWhereUniqueInput
  }

  /**
   * PerformanceReport deleteMany
   */
  export type PerformanceReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReports to delete
     */
    where?: PerformanceReportWhereInput
  }

  /**
   * PerformanceReport without action
   */
  export type PerformanceReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReport
     */
    select?: PerformanceReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReportInclude<ExtArgs> | null
  }


  /**
   * Model CustomerFeedback
   */

  export type AggregateCustomerFeedback = {
    _count: CustomerFeedbackCountAggregateOutputType | null
    _avg: CustomerFeedbackAvgAggregateOutputType | null
    _sum: CustomerFeedbackSumAggregateOutputType | null
    _min: CustomerFeedbackMinAggregateOutputType | null
    _max: CustomerFeedbackMaxAggregateOutputType | null
  }

  export type CustomerFeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type CustomerFeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type CustomerFeedbackMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    interactionId: string | null
    feedbackText: string | null
    rating: number | null
    collectedVia: string | null
    createdAt: Date | null
  }

  export type CustomerFeedbackMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    interactionId: string | null
    feedbackText: string | null
    rating: number | null
    collectedVia: string | null
    createdAt: Date | null
  }

  export type CustomerFeedbackCountAggregateOutputType = {
    id: number
    campaignId: number
    userId: number
    interactionId: number
    feedbackText: number
    rating: number
    collectedVia: number
    createdAt: number
    _all: number
  }


  export type CustomerFeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type CustomerFeedbackSumAggregateInputType = {
    rating?: true
  }

  export type CustomerFeedbackMinAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    interactionId?: true
    feedbackText?: true
    rating?: true
    collectedVia?: true
    createdAt?: true
  }

  export type CustomerFeedbackMaxAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    interactionId?: true
    feedbackText?: true
    rating?: true
    collectedVia?: true
    createdAt?: true
  }

  export type CustomerFeedbackCountAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    interactionId?: true
    feedbackText?: true
    rating?: true
    collectedVia?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerFeedback to aggregate.
     */
    where?: CustomerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFeedbacks to fetch.
     */
    orderBy?: CustomerFeedbackOrderByWithRelationInput | CustomerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerFeedbacks
    **/
    _count?: true | CustomerFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerFeedbackMaxAggregateInputType
  }

  export type GetCustomerFeedbackAggregateType<T extends CustomerFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerFeedback[P]>
      : GetScalarType<T[P], AggregateCustomerFeedback[P]>
  }




  export type CustomerFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerFeedbackWhereInput
    orderBy?: CustomerFeedbackOrderByWithAggregationInput | CustomerFeedbackOrderByWithAggregationInput[]
    by: CustomerFeedbackScalarFieldEnum[] | CustomerFeedbackScalarFieldEnum
    having?: CustomerFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerFeedbackCountAggregateInputType | true
    _avg?: CustomerFeedbackAvgAggregateInputType
    _sum?: CustomerFeedbackSumAggregateInputType
    _min?: CustomerFeedbackMinAggregateInputType
    _max?: CustomerFeedbackMaxAggregateInputType
  }

  export type CustomerFeedbackGroupByOutputType = {
    id: string
    campaignId: string
    userId: string
    interactionId: string | null
    feedbackText: string
    rating: number
    collectedVia: string
    createdAt: Date
    _count: CustomerFeedbackCountAggregateOutputType | null
    _avg: CustomerFeedbackAvgAggregateOutputType | null
    _sum: CustomerFeedbackSumAggregateOutputType | null
    _min: CustomerFeedbackMinAggregateOutputType | null
    _max: CustomerFeedbackMaxAggregateOutputType | null
  }

  type GetCustomerFeedbackGroupByPayload<T extends CustomerFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type CustomerFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    interactionId?: boolean
    feedbackText?: boolean
    rating?: boolean
    collectedVia?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerFeedback"]>

  export type CustomerFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    interactionId?: boolean
    feedbackText?: boolean
    rating?: boolean
    collectedVia?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerFeedback"]>

  export type CustomerFeedbackSelectScalar = {
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    interactionId?: boolean
    feedbackText?: boolean
    rating?: boolean
    collectedVia?: boolean
    createdAt?: boolean
  }

  export type CustomerFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CustomerFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CustomerFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerFeedback"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      userId: string
      interactionId: string | null
      feedbackText: string
      rating: number
      collectedVia: string
      createdAt: Date
    }, ExtArgs["result"]["customerFeedback"]>
    composites: {}
  }

  type CustomerFeedbackGetPayload<S extends boolean | null | undefined | CustomerFeedbackDefaultArgs> = $Result.GetResult<Prisma.$CustomerFeedbackPayload, S>

  type CustomerFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerFeedbackCountAggregateInputType | true
    }

  export interface CustomerFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerFeedback'], meta: { name: 'CustomerFeedback' } }
    /**
     * Find zero or one CustomerFeedback that matches the filter.
     * @param {CustomerFeedbackFindUniqueArgs} args - Arguments to find a CustomerFeedback
     * @example
     * // Get one CustomerFeedback
     * const customerFeedback = await prisma.customerFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFeedbackFindUniqueArgs>(args: SelectSubset<T, CustomerFeedbackFindUniqueArgs<ExtArgs>>): Prisma__CustomerFeedbackClient<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFeedbackFindUniqueOrThrowArgs} args - Arguments to find a CustomerFeedback
     * @example
     * // Get one CustomerFeedback
     * const customerFeedback = await prisma.customerFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerFeedbackClient<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFeedbackFindFirstArgs} args - Arguments to find a CustomerFeedback
     * @example
     * // Get one CustomerFeedback
     * const customerFeedback = await prisma.customerFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFeedbackFindFirstArgs>(args?: SelectSubset<T, CustomerFeedbackFindFirstArgs<ExtArgs>>): Prisma__CustomerFeedbackClient<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFeedbackFindFirstOrThrowArgs} args - Arguments to find a CustomerFeedback
     * @example
     * // Get one CustomerFeedback
     * const customerFeedback = await prisma.customerFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerFeedbackClient<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerFeedbacks
     * const customerFeedbacks = await prisma.customerFeedback.findMany()
     * 
     * // Get first 10 CustomerFeedbacks
     * const customerFeedbacks = await prisma.customerFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerFeedbackWithIdOnly = await prisma.customerFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFeedbackFindManyArgs>(args?: SelectSubset<T, CustomerFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerFeedback.
     * @param {CustomerFeedbackCreateArgs} args - Arguments to create a CustomerFeedback.
     * @example
     * // Create one CustomerFeedback
     * const CustomerFeedback = await prisma.customerFeedback.create({
     *   data: {
     *     // ... data to create a CustomerFeedback
     *   }
     * })
     * 
     */
    create<T extends CustomerFeedbackCreateArgs>(args: SelectSubset<T, CustomerFeedbackCreateArgs<ExtArgs>>): Prisma__CustomerFeedbackClient<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerFeedbacks.
     * @param {CustomerFeedbackCreateManyArgs} args - Arguments to create many CustomerFeedbacks.
     * @example
     * // Create many CustomerFeedbacks
     * const customerFeedback = await prisma.customerFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerFeedbackCreateManyArgs>(args?: SelectSubset<T, CustomerFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerFeedbacks and returns the data saved in the database.
     * @param {CustomerFeedbackCreateManyAndReturnArgs} args - Arguments to create many CustomerFeedbacks.
     * @example
     * // Create many CustomerFeedbacks
     * const customerFeedback = await prisma.customerFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerFeedbacks and only return the `id`
     * const customerFeedbackWithIdOnly = await prisma.customerFeedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerFeedback.
     * @param {CustomerFeedbackDeleteArgs} args - Arguments to delete one CustomerFeedback.
     * @example
     * // Delete one CustomerFeedback
     * const CustomerFeedback = await prisma.customerFeedback.delete({
     *   where: {
     *     // ... filter to delete one CustomerFeedback
     *   }
     * })
     * 
     */
    delete<T extends CustomerFeedbackDeleteArgs>(args: SelectSubset<T, CustomerFeedbackDeleteArgs<ExtArgs>>): Prisma__CustomerFeedbackClient<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerFeedback.
     * @param {CustomerFeedbackUpdateArgs} args - Arguments to update one CustomerFeedback.
     * @example
     * // Update one CustomerFeedback
     * const customerFeedback = await prisma.customerFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerFeedbackUpdateArgs>(args: SelectSubset<T, CustomerFeedbackUpdateArgs<ExtArgs>>): Prisma__CustomerFeedbackClient<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerFeedbacks.
     * @param {CustomerFeedbackDeleteManyArgs} args - Arguments to filter CustomerFeedbacks to delete.
     * @example
     * // Delete a few CustomerFeedbacks
     * const { count } = await prisma.customerFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerFeedbackDeleteManyArgs>(args?: SelectSubset<T, CustomerFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerFeedbacks
     * const customerFeedback = await prisma.customerFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerFeedbackUpdateManyArgs>(args: SelectSubset<T, CustomerFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerFeedback.
     * @param {CustomerFeedbackUpsertArgs} args - Arguments to update or create a CustomerFeedback.
     * @example
     * // Update or create a CustomerFeedback
     * const customerFeedback = await prisma.customerFeedback.upsert({
     *   create: {
     *     // ... data to create a CustomerFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerFeedback we want to update
     *   }
     * })
     */
    upsert<T extends CustomerFeedbackUpsertArgs>(args: SelectSubset<T, CustomerFeedbackUpsertArgs<ExtArgs>>): Prisma__CustomerFeedbackClient<$Result.GetResult<Prisma.$CustomerFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFeedbackCountArgs} args - Arguments to filter CustomerFeedbacks to count.
     * @example
     * // Count the number of CustomerFeedbacks
     * const count = await prisma.customerFeedback.count({
     *   where: {
     *     // ... the filter for the CustomerFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends CustomerFeedbackCountArgs>(
      args?: Subset<T, CustomerFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerFeedbackAggregateArgs>(args: Subset<T, CustomerFeedbackAggregateArgs>): Prisma.PrismaPromise<GetCustomerFeedbackAggregateType<T>>

    /**
     * Group by CustomerFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: CustomerFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerFeedback model
   */
  readonly fields: CustomerFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerFeedback model
   */ 
  interface CustomerFeedbackFieldRefs {
    readonly id: FieldRef<"CustomerFeedback", 'String'>
    readonly campaignId: FieldRef<"CustomerFeedback", 'String'>
    readonly userId: FieldRef<"CustomerFeedback", 'String'>
    readonly interactionId: FieldRef<"CustomerFeedback", 'String'>
    readonly feedbackText: FieldRef<"CustomerFeedback", 'String'>
    readonly rating: FieldRef<"CustomerFeedback", 'Int'>
    readonly collectedVia: FieldRef<"CustomerFeedback", 'String'>
    readonly createdAt: FieldRef<"CustomerFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerFeedback findUnique
   */
  export type CustomerFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFeedback to fetch.
     */
    where: CustomerFeedbackWhereUniqueInput
  }

  /**
   * CustomerFeedback findUniqueOrThrow
   */
  export type CustomerFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFeedback to fetch.
     */
    where: CustomerFeedbackWhereUniqueInput
  }

  /**
   * CustomerFeedback findFirst
   */
  export type CustomerFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFeedback to fetch.
     */
    where?: CustomerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFeedbacks to fetch.
     */
    orderBy?: CustomerFeedbackOrderByWithRelationInput | CustomerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerFeedbacks.
     */
    cursor?: CustomerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerFeedbacks.
     */
    distinct?: CustomerFeedbackScalarFieldEnum | CustomerFeedbackScalarFieldEnum[]
  }

  /**
   * CustomerFeedback findFirstOrThrow
   */
  export type CustomerFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFeedback to fetch.
     */
    where?: CustomerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFeedbacks to fetch.
     */
    orderBy?: CustomerFeedbackOrderByWithRelationInput | CustomerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerFeedbacks.
     */
    cursor?: CustomerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerFeedbacks.
     */
    distinct?: CustomerFeedbackScalarFieldEnum | CustomerFeedbackScalarFieldEnum[]
  }

  /**
   * CustomerFeedback findMany
   */
  export type CustomerFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which CustomerFeedbacks to fetch.
     */
    where?: CustomerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerFeedbacks to fetch.
     */
    orderBy?: CustomerFeedbackOrderByWithRelationInput | CustomerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerFeedbacks.
     */
    cursor?: CustomerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerFeedbacks.
     */
    skip?: number
    distinct?: CustomerFeedbackScalarFieldEnum | CustomerFeedbackScalarFieldEnum[]
  }

  /**
   * CustomerFeedback create
   */
  export type CustomerFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerFeedback.
     */
    data: XOR<CustomerFeedbackCreateInput, CustomerFeedbackUncheckedCreateInput>
  }

  /**
   * CustomerFeedback createMany
   */
  export type CustomerFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerFeedbacks.
     */
    data: CustomerFeedbackCreateManyInput | CustomerFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerFeedback createManyAndReturn
   */
  export type CustomerFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerFeedbacks.
     */
    data: CustomerFeedbackCreateManyInput | CustomerFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerFeedback update
   */
  export type CustomerFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerFeedback.
     */
    data: XOR<CustomerFeedbackUpdateInput, CustomerFeedbackUncheckedUpdateInput>
    /**
     * Choose, which CustomerFeedback to update.
     */
    where: CustomerFeedbackWhereUniqueInput
  }

  /**
   * CustomerFeedback updateMany
   */
  export type CustomerFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerFeedbacks.
     */
    data: XOR<CustomerFeedbackUpdateManyMutationInput, CustomerFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which CustomerFeedbacks to update
     */
    where?: CustomerFeedbackWhereInput
  }

  /**
   * CustomerFeedback upsert
   */
  export type CustomerFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerFeedback to update in case it exists.
     */
    where: CustomerFeedbackWhereUniqueInput
    /**
     * In case the CustomerFeedback found by the `where` argument doesn't exist, create a new CustomerFeedback with this data.
     */
    create: XOR<CustomerFeedbackCreateInput, CustomerFeedbackUncheckedCreateInput>
    /**
     * In case the CustomerFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerFeedbackUpdateInput, CustomerFeedbackUncheckedUpdateInput>
  }

  /**
   * CustomerFeedback delete
   */
  export type CustomerFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
    /**
     * Filter which CustomerFeedback to delete.
     */
    where: CustomerFeedbackWhereUniqueInput
  }

  /**
   * CustomerFeedback deleteMany
   */
  export type CustomerFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerFeedbacks to delete
     */
    where?: CustomerFeedbackWhereInput
  }

  /**
   * CustomerFeedback without action
   */
  export type CustomerFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerFeedback
     */
    select?: CustomerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model ThankYouMessage
   */

  export type AggregateThankYouMessage = {
    _count: ThankYouMessageCountAggregateOutputType | null
    _min: ThankYouMessageMinAggregateOutputType | null
    _max: ThankYouMessageMaxAggregateOutputType | null
  }

  export type ThankYouMessageMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    messageBody: string | null
    sentVia: string | null
    segment: string | null
    sentAt: Date | null
  }

  export type ThankYouMessageMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    messageBody: string | null
    sentVia: string | null
    segment: string | null
    sentAt: Date | null
  }

  export type ThankYouMessageCountAggregateOutputType = {
    id: number
    campaignId: number
    userId: number
    messageBody: number
    sentVia: number
    segment: number
    sentAt: number
    _all: number
  }


  export type ThankYouMessageMinAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    messageBody?: true
    sentVia?: true
    segment?: true
    sentAt?: true
  }

  export type ThankYouMessageMaxAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    messageBody?: true
    sentVia?: true
    segment?: true
    sentAt?: true
  }

  export type ThankYouMessageCountAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    messageBody?: true
    sentVia?: true
    segment?: true
    sentAt?: true
    _all?: true
  }

  export type ThankYouMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThankYouMessage to aggregate.
     */
    where?: ThankYouMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThankYouMessages to fetch.
     */
    orderBy?: ThankYouMessageOrderByWithRelationInput | ThankYouMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThankYouMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThankYouMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThankYouMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThankYouMessages
    **/
    _count?: true | ThankYouMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThankYouMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThankYouMessageMaxAggregateInputType
  }

  export type GetThankYouMessageAggregateType<T extends ThankYouMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateThankYouMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThankYouMessage[P]>
      : GetScalarType<T[P], AggregateThankYouMessage[P]>
  }




  export type ThankYouMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThankYouMessageWhereInput
    orderBy?: ThankYouMessageOrderByWithAggregationInput | ThankYouMessageOrderByWithAggregationInput[]
    by: ThankYouMessageScalarFieldEnum[] | ThankYouMessageScalarFieldEnum
    having?: ThankYouMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThankYouMessageCountAggregateInputType | true
    _min?: ThankYouMessageMinAggregateInputType
    _max?: ThankYouMessageMaxAggregateInputType
  }

  export type ThankYouMessageGroupByOutputType = {
    id: string
    campaignId: string
    userId: string
    messageBody: string
    sentVia: string
    segment: string
    sentAt: Date
    _count: ThankYouMessageCountAggregateOutputType | null
    _min: ThankYouMessageMinAggregateOutputType | null
    _max: ThankYouMessageMaxAggregateOutputType | null
  }

  type GetThankYouMessageGroupByPayload<T extends ThankYouMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThankYouMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThankYouMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThankYouMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ThankYouMessageGroupByOutputType[P]>
        }
      >
    >


  export type ThankYouMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    messageBody?: boolean
    sentVia?: boolean
    segment?: boolean
    sentAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thankYouMessage"]>

  export type ThankYouMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    messageBody?: boolean
    sentVia?: boolean
    segment?: boolean
    sentAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thankYouMessage"]>

  export type ThankYouMessageSelectScalar = {
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    messageBody?: boolean
    sentVia?: boolean
    segment?: boolean
    sentAt?: boolean
  }

  export type ThankYouMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ThankYouMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $ThankYouMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThankYouMessage"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      userId: string
      messageBody: string
      sentVia: string
      segment: string
      sentAt: Date
    }, ExtArgs["result"]["thankYouMessage"]>
    composites: {}
  }

  type ThankYouMessageGetPayload<S extends boolean | null | undefined | ThankYouMessageDefaultArgs> = $Result.GetResult<Prisma.$ThankYouMessagePayload, S>

  type ThankYouMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ThankYouMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ThankYouMessageCountAggregateInputType | true
    }

  export interface ThankYouMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThankYouMessage'], meta: { name: 'ThankYouMessage' } }
    /**
     * Find zero or one ThankYouMessage that matches the filter.
     * @param {ThankYouMessageFindUniqueArgs} args - Arguments to find a ThankYouMessage
     * @example
     * // Get one ThankYouMessage
     * const thankYouMessage = await prisma.thankYouMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThankYouMessageFindUniqueArgs>(args: SelectSubset<T, ThankYouMessageFindUniqueArgs<ExtArgs>>): Prisma__ThankYouMessageClient<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ThankYouMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ThankYouMessageFindUniqueOrThrowArgs} args - Arguments to find a ThankYouMessage
     * @example
     * // Get one ThankYouMessage
     * const thankYouMessage = await prisma.thankYouMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThankYouMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ThankYouMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThankYouMessageClient<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ThankYouMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThankYouMessageFindFirstArgs} args - Arguments to find a ThankYouMessage
     * @example
     * // Get one ThankYouMessage
     * const thankYouMessage = await prisma.thankYouMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThankYouMessageFindFirstArgs>(args?: SelectSubset<T, ThankYouMessageFindFirstArgs<ExtArgs>>): Prisma__ThankYouMessageClient<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ThankYouMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThankYouMessageFindFirstOrThrowArgs} args - Arguments to find a ThankYouMessage
     * @example
     * // Get one ThankYouMessage
     * const thankYouMessage = await prisma.thankYouMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThankYouMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ThankYouMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThankYouMessageClient<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ThankYouMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThankYouMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThankYouMessages
     * const thankYouMessages = await prisma.thankYouMessage.findMany()
     * 
     * // Get first 10 ThankYouMessages
     * const thankYouMessages = await prisma.thankYouMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const thankYouMessageWithIdOnly = await prisma.thankYouMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThankYouMessageFindManyArgs>(args?: SelectSubset<T, ThankYouMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ThankYouMessage.
     * @param {ThankYouMessageCreateArgs} args - Arguments to create a ThankYouMessage.
     * @example
     * // Create one ThankYouMessage
     * const ThankYouMessage = await prisma.thankYouMessage.create({
     *   data: {
     *     // ... data to create a ThankYouMessage
     *   }
     * })
     * 
     */
    create<T extends ThankYouMessageCreateArgs>(args: SelectSubset<T, ThankYouMessageCreateArgs<ExtArgs>>): Prisma__ThankYouMessageClient<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ThankYouMessages.
     * @param {ThankYouMessageCreateManyArgs} args - Arguments to create many ThankYouMessages.
     * @example
     * // Create many ThankYouMessages
     * const thankYouMessage = await prisma.thankYouMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThankYouMessageCreateManyArgs>(args?: SelectSubset<T, ThankYouMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThankYouMessages and returns the data saved in the database.
     * @param {ThankYouMessageCreateManyAndReturnArgs} args - Arguments to create many ThankYouMessages.
     * @example
     * // Create many ThankYouMessages
     * const thankYouMessage = await prisma.thankYouMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThankYouMessages and only return the `id`
     * const thankYouMessageWithIdOnly = await prisma.thankYouMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThankYouMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ThankYouMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ThankYouMessage.
     * @param {ThankYouMessageDeleteArgs} args - Arguments to delete one ThankYouMessage.
     * @example
     * // Delete one ThankYouMessage
     * const ThankYouMessage = await prisma.thankYouMessage.delete({
     *   where: {
     *     // ... filter to delete one ThankYouMessage
     *   }
     * })
     * 
     */
    delete<T extends ThankYouMessageDeleteArgs>(args: SelectSubset<T, ThankYouMessageDeleteArgs<ExtArgs>>): Prisma__ThankYouMessageClient<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ThankYouMessage.
     * @param {ThankYouMessageUpdateArgs} args - Arguments to update one ThankYouMessage.
     * @example
     * // Update one ThankYouMessage
     * const thankYouMessage = await prisma.thankYouMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThankYouMessageUpdateArgs>(args: SelectSubset<T, ThankYouMessageUpdateArgs<ExtArgs>>): Prisma__ThankYouMessageClient<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ThankYouMessages.
     * @param {ThankYouMessageDeleteManyArgs} args - Arguments to filter ThankYouMessages to delete.
     * @example
     * // Delete a few ThankYouMessages
     * const { count } = await prisma.thankYouMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThankYouMessageDeleteManyArgs>(args?: SelectSubset<T, ThankYouMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThankYouMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThankYouMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThankYouMessages
     * const thankYouMessage = await prisma.thankYouMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThankYouMessageUpdateManyArgs>(args: SelectSubset<T, ThankYouMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ThankYouMessage.
     * @param {ThankYouMessageUpsertArgs} args - Arguments to update or create a ThankYouMessage.
     * @example
     * // Update or create a ThankYouMessage
     * const thankYouMessage = await prisma.thankYouMessage.upsert({
     *   create: {
     *     // ... data to create a ThankYouMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThankYouMessage we want to update
     *   }
     * })
     */
    upsert<T extends ThankYouMessageUpsertArgs>(args: SelectSubset<T, ThankYouMessageUpsertArgs<ExtArgs>>): Prisma__ThankYouMessageClient<$Result.GetResult<Prisma.$ThankYouMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ThankYouMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThankYouMessageCountArgs} args - Arguments to filter ThankYouMessages to count.
     * @example
     * // Count the number of ThankYouMessages
     * const count = await prisma.thankYouMessage.count({
     *   where: {
     *     // ... the filter for the ThankYouMessages we want to count
     *   }
     * })
    **/
    count<T extends ThankYouMessageCountArgs>(
      args?: Subset<T, ThankYouMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThankYouMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThankYouMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThankYouMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThankYouMessageAggregateArgs>(args: Subset<T, ThankYouMessageAggregateArgs>): Prisma.PrismaPromise<GetThankYouMessageAggregateType<T>>

    /**
     * Group by ThankYouMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThankYouMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThankYouMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThankYouMessageGroupByArgs['orderBy'] }
        : { orderBy?: ThankYouMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThankYouMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThankYouMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThankYouMessage model
   */
  readonly fields: ThankYouMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThankYouMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThankYouMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThankYouMessage model
   */ 
  interface ThankYouMessageFieldRefs {
    readonly id: FieldRef<"ThankYouMessage", 'String'>
    readonly campaignId: FieldRef<"ThankYouMessage", 'String'>
    readonly userId: FieldRef<"ThankYouMessage", 'String'>
    readonly messageBody: FieldRef<"ThankYouMessage", 'String'>
    readonly sentVia: FieldRef<"ThankYouMessage", 'String'>
    readonly segment: FieldRef<"ThankYouMessage", 'String'>
    readonly sentAt: FieldRef<"ThankYouMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ThankYouMessage findUnique
   */
  export type ThankYouMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThankYouMessage to fetch.
     */
    where: ThankYouMessageWhereUniqueInput
  }

  /**
   * ThankYouMessage findUniqueOrThrow
   */
  export type ThankYouMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThankYouMessage to fetch.
     */
    where: ThankYouMessageWhereUniqueInput
  }

  /**
   * ThankYouMessage findFirst
   */
  export type ThankYouMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThankYouMessage to fetch.
     */
    where?: ThankYouMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThankYouMessages to fetch.
     */
    orderBy?: ThankYouMessageOrderByWithRelationInput | ThankYouMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThankYouMessages.
     */
    cursor?: ThankYouMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThankYouMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThankYouMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThankYouMessages.
     */
    distinct?: ThankYouMessageScalarFieldEnum | ThankYouMessageScalarFieldEnum[]
  }

  /**
   * ThankYouMessage findFirstOrThrow
   */
  export type ThankYouMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThankYouMessage to fetch.
     */
    where?: ThankYouMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThankYouMessages to fetch.
     */
    orderBy?: ThankYouMessageOrderByWithRelationInput | ThankYouMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThankYouMessages.
     */
    cursor?: ThankYouMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThankYouMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThankYouMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThankYouMessages.
     */
    distinct?: ThankYouMessageScalarFieldEnum | ThankYouMessageScalarFieldEnum[]
  }

  /**
   * ThankYouMessage findMany
   */
  export type ThankYouMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    /**
     * Filter, which ThankYouMessages to fetch.
     */
    where?: ThankYouMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThankYouMessages to fetch.
     */
    orderBy?: ThankYouMessageOrderByWithRelationInput | ThankYouMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThankYouMessages.
     */
    cursor?: ThankYouMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThankYouMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThankYouMessages.
     */
    skip?: number
    distinct?: ThankYouMessageScalarFieldEnum | ThankYouMessageScalarFieldEnum[]
  }

  /**
   * ThankYouMessage create
   */
  export type ThankYouMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ThankYouMessage.
     */
    data: XOR<ThankYouMessageCreateInput, ThankYouMessageUncheckedCreateInput>
  }

  /**
   * ThankYouMessage createMany
   */
  export type ThankYouMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThankYouMessages.
     */
    data: ThankYouMessageCreateManyInput | ThankYouMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThankYouMessage createManyAndReturn
   */
  export type ThankYouMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ThankYouMessages.
     */
    data: ThankYouMessageCreateManyInput | ThankYouMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThankYouMessage update
   */
  export type ThankYouMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ThankYouMessage.
     */
    data: XOR<ThankYouMessageUpdateInput, ThankYouMessageUncheckedUpdateInput>
    /**
     * Choose, which ThankYouMessage to update.
     */
    where: ThankYouMessageWhereUniqueInput
  }

  /**
   * ThankYouMessage updateMany
   */
  export type ThankYouMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThankYouMessages.
     */
    data: XOR<ThankYouMessageUpdateManyMutationInput, ThankYouMessageUncheckedUpdateManyInput>
    /**
     * Filter which ThankYouMessages to update
     */
    where?: ThankYouMessageWhereInput
  }

  /**
   * ThankYouMessage upsert
   */
  export type ThankYouMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ThankYouMessage to update in case it exists.
     */
    where: ThankYouMessageWhereUniqueInput
    /**
     * In case the ThankYouMessage found by the `where` argument doesn't exist, create a new ThankYouMessage with this data.
     */
    create: XOR<ThankYouMessageCreateInput, ThankYouMessageUncheckedCreateInput>
    /**
     * In case the ThankYouMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThankYouMessageUpdateInput, ThankYouMessageUncheckedUpdateInput>
  }

  /**
   * ThankYouMessage delete
   */
  export type ThankYouMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
    /**
     * Filter which ThankYouMessage to delete.
     */
    where: ThankYouMessageWhereUniqueInput
  }

  /**
   * ThankYouMessage deleteMany
   */
  export type ThankYouMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThankYouMessages to delete
     */
    where?: ThankYouMessageWhereInput
  }

  /**
   * ThankYouMessage without action
   */
  export type ThankYouMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThankYouMessage
     */
    select?: ThankYouMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThankYouMessageInclude<ExtArgs> | null
  }


  /**
   * Model RetargetingPlan
   */

  export type AggregateRetargetingPlan = {
    _count: RetargetingPlanCountAggregateOutputType | null
    _min: RetargetingPlanMinAggregateOutputType | null
    _max: RetargetingPlanMaxAggregateOutputType | null
  }

  export type RetargetingPlanMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    audienceSegment: string | null
    retargetingChannel: string | null
    offerMessage: string | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type RetargetingPlanMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    audienceSegment: string | null
    retargetingChannel: string | null
    offerMessage: string | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type RetargetingPlanCountAggregateOutputType = {
    id: number
    campaignId: number
    audienceSegment: number
    retargetingChannel: number
    offerMessage: number
    scheduledAt: number
    createdAt: number
    _all: number
  }


  export type RetargetingPlanMinAggregateInputType = {
    id?: true
    campaignId?: true
    audienceSegment?: true
    retargetingChannel?: true
    offerMessage?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type RetargetingPlanMaxAggregateInputType = {
    id?: true
    campaignId?: true
    audienceSegment?: true
    retargetingChannel?: true
    offerMessage?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type RetargetingPlanCountAggregateInputType = {
    id?: true
    campaignId?: true
    audienceSegment?: true
    retargetingChannel?: true
    offerMessage?: true
    scheduledAt?: true
    createdAt?: true
    _all?: true
  }

  export type RetargetingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetargetingPlan to aggregate.
     */
    where?: RetargetingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetargetingPlans to fetch.
     */
    orderBy?: RetargetingPlanOrderByWithRelationInput | RetargetingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RetargetingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetargetingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetargetingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RetargetingPlans
    **/
    _count?: true | RetargetingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RetargetingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RetargetingPlanMaxAggregateInputType
  }

  export type GetRetargetingPlanAggregateType<T extends RetargetingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateRetargetingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetargetingPlan[P]>
      : GetScalarType<T[P], AggregateRetargetingPlan[P]>
  }




  export type RetargetingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetargetingPlanWhereInput
    orderBy?: RetargetingPlanOrderByWithAggregationInput | RetargetingPlanOrderByWithAggregationInput[]
    by: RetargetingPlanScalarFieldEnum[] | RetargetingPlanScalarFieldEnum
    having?: RetargetingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RetargetingPlanCountAggregateInputType | true
    _min?: RetargetingPlanMinAggregateInputType
    _max?: RetargetingPlanMaxAggregateInputType
  }

  export type RetargetingPlanGroupByOutputType = {
    id: string
    campaignId: string
    audienceSegment: string
    retargetingChannel: string
    offerMessage: string
    scheduledAt: Date
    createdAt: Date
    _count: RetargetingPlanCountAggregateOutputType | null
    _min: RetargetingPlanMinAggregateOutputType | null
    _max: RetargetingPlanMaxAggregateOutputType | null
  }

  type GetRetargetingPlanGroupByPayload<T extends RetargetingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RetargetingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RetargetingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RetargetingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], RetargetingPlanGroupByOutputType[P]>
        }
      >
    >


  export type RetargetingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    audienceSegment?: boolean
    retargetingChannel?: boolean
    offerMessage?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retargetingPlan"]>

  export type RetargetingPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    audienceSegment?: boolean
    retargetingChannel?: boolean
    offerMessage?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retargetingPlan"]>

  export type RetargetingPlanSelectScalar = {
    id?: boolean
    campaignId?: boolean
    audienceSegment?: boolean
    retargetingChannel?: boolean
    offerMessage?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
  }

  export type RetargetingPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type RetargetingPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $RetargetingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RetargetingPlan"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      audienceSegment: string
      retargetingChannel: string
      offerMessage: string
      scheduledAt: Date
      createdAt: Date
    }, ExtArgs["result"]["retargetingPlan"]>
    composites: {}
  }

  type RetargetingPlanGetPayload<S extends boolean | null | undefined | RetargetingPlanDefaultArgs> = $Result.GetResult<Prisma.$RetargetingPlanPayload, S>

  type RetargetingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RetargetingPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RetargetingPlanCountAggregateInputType | true
    }

  export interface RetargetingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RetargetingPlan'], meta: { name: 'RetargetingPlan' } }
    /**
     * Find zero or one RetargetingPlan that matches the filter.
     * @param {RetargetingPlanFindUniqueArgs} args - Arguments to find a RetargetingPlan
     * @example
     * // Get one RetargetingPlan
     * const retargetingPlan = await prisma.retargetingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RetargetingPlanFindUniqueArgs>(args: SelectSubset<T, RetargetingPlanFindUniqueArgs<ExtArgs>>): Prisma__RetargetingPlanClient<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RetargetingPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RetargetingPlanFindUniqueOrThrowArgs} args - Arguments to find a RetargetingPlan
     * @example
     * // Get one RetargetingPlan
     * const retargetingPlan = await prisma.retargetingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RetargetingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, RetargetingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RetargetingPlanClient<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RetargetingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetargetingPlanFindFirstArgs} args - Arguments to find a RetargetingPlan
     * @example
     * // Get one RetargetingPlan
     * const retargetingPlan = await prisma.retargetingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RetargetingPlanFindFirstArgs>(args?: SelectSubset<T, RetargetingPlanFindFirstArgs<ExtArgs>>): Prisma__RetargetingPlanClient<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RetargetingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetargetingPlanFindFirstOrThrowArgs} args - Arguments to find a RetargetingPlan
     * @example
     * // Get one RetargetingPlan
     * const retargetingPlan = await prisma.retargetingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RetargetingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, RetargetingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__RetargetingPlanClient<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RetargetingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetargetingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RetargetingPlans
     * const retargetingPlans = await prisma.retargetingPlan.findMany()
     * 
     * // Get first 10 RetargetingPlans
     * const retargetingPlans = await prisma.retargetingPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const retargetingPlanWithIdOnly = await prisma.retargetingPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RetargetingPlanFindManyArgs>(args?: SelectSubset<T, RetargetingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RetargetingPlan.
     * @param {RetargetingPlanCreateArgs} args - Arguments to create a RetargetingPlan.
     * @example
     * // Create one RetargetingPlan
     * const RetargetingPlan = await prisma.retargetingPlan.create({
     *   data: {
     *     // ... data to create a RetargetingPlan
     *   }
     * })
     * 
     */
    create<T extends RetargetingPlanCreateArgs>(args: SelectSubset<T, RetargetingPlanCreateArgs<ExtArgs>>): Prisma__RetargetingPlanClient<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RetargetingPlans.
     * @param {RetargetingPlanCreateManyArgs} args - Arguments to create many RetargetingPlans.
     * @example
     * // Create many RetargetingPlans
     * const retargetingPlan = await prisma.retargetingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RetargetingPlanCreateManyArgs>(args?: SelectSubset<T, RetargetingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RetargetingPlans and returns the data saved in the database.
     * @param {RetargetingPlanCreateManyAndReturnArgs} args - Arguments to create many RetargetingPlans.
     * @example
     * // Create many RetargetingPlans
     * const retargetingPlan = await prisma.retargetingPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RetargetingPlans and only return the `id`
     * const retargetingPlanWithIdOnly = await prisma.retargetingPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RetargetingPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, RetargetingPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RetargetingPlan.
     * @param {RetargetingPlanDeleteArgs} args - Arguments to delete one RetargetingPlan.
     * @example
     * // Delete one RetargetingPlan
     * const RetargetingPlan = await prisma.retargetingPlan.delete({
     *   where: {
     *     // ... filter to delete one RetargetingPlan
     *   }
     * })
     * 
     */
    delete<T extends RetargetingPlanDeleteArgs>(args: SelectSubset<T, RetargetingPlanDeleteArgs<ExtArgs>>): Prisma__RetargetingPlanClient<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RetargetingPlan.
     * @param {RetargetingPlanUpdateArgs} args - Arguments to update one RetargetingPlan.
     * @example
     * // Update one RetargetingPlan
     * const retargetingPlan = await prisma.retargetingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RetargetingPlanUpdateArgs>(args: SelectSubset<T, RetargetingPlanUpdateArgs<ExtArgs>>): Prisma__RetargetingPlanClient<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RetargetingPlans.
     * @param {RetargetingPlanDeleteManyArgs} args - Arguments to filter RetargetingPlans to delete.
     * @example
     * // Delete a few RetargetingPlans
     * const { count } = await prisma.retargetingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RetargetingPlanDeleteManyArgs>(args?: SelectSubset<T, RetargetingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RetargetingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetargetingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RetargetingPlans
     * const retargetingPlan = await prisma.retargetingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RetargetingPlanUpdateManyArgs>(args: SelectSubset<T, RetargetingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RetargetingPlan.
     * @param {RetargetingPlanUpsertArgs} args - Arguments to update or create a RetargetingPlan.
     * @example
     * // Update or create a RetargetingPlan
     * const retargetingPlan = await prisma.retargetingPlan.upsert({
     *   create: {
     *     // ... data to create a RetargetingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RetargetingPlan we want to update
     *   }
     * })
     */
    upsert<T extends RetargetingPlanUpsertArgs>(args: SelectSubset<T, RetargetingPlanUpsertArgs<ExtArgs>>): Prisma__RetargetingPlanClient<$Result.GetResult<Prisma.$RetargetingPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RetargetingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetargetingPlanCountArgs} args - Arguments to filter RetargetingPlans to count.
     * @example
     * // Count the number of RetargetingPlans
     * const count = await prisma.retargetingPlan.count({
     *   where: {
     *     // ... the filter for the RetargetingPlans we want to count
     *   }
     * })
    **/
    count<T extends RetargetingPlanCountArgs>(
      args?: Subset<T, RetargetingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RetargetingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RetargetingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetargetingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RetargetingPlanAggregateArgs>(args: Subset<T, RetargetingPlanAggregateArgs>): Prisma.PrismaPromise<GetRetargetingPlanAggregateType<T>>

    /**
     * Group by RetargetingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetargetingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RetargetingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RetargetingPlanGroupByArgs['orderBy'] }
        : { orderBy?: RetargetingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RetargetingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetargetingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RetargetingPlan model
   */
  readonly fields: RetargetingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RetargetingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RetargetingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RetargetingPlan model
   */ 
  interface RetargetingPlanFieldRefs {
    readonly id: FieldRef<"RetargetingPlan", 'String'>
    readonly campaignId: FieldRef<"RetargetingPlan", 'String'>
    readonly audienceSegment: FieldRef<"RetargetingPlan", 'String'>
    readonly retargetingChannel: FieldRef<"RetargetingPlan", 'String'>
    readonly offerMessage: FieldRef<"RetargetingPlan", 'String'>
    readonly scheduledAt: FieldRef<"RetargetingPlan", 'DateTime'>
    readonly createdAt: FieldRef<"RetargetingPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RetargetingPlan findUnique
   */
  export type RetargetingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    /**
     * Filter, which RetargetingPlan to fetch.
     */
    where: RetargetingPlanWhereUniqueInput
  }

  /**
   * RetargetingPlan findUniqueOrThrow
   */
  export type RetargetingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    /**
     * Filter, which RetargetingPlan to fetch.
     */
    where: RetargetingPlanWhereUniqueInput
  }

  /**
   * RetargetingPlan findFirst
   */
  export type RetargetingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    /**
     * Filter, which RetargetingPlan to fetch.
     */
    where?: RetargetingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetargetingPlans to fetch.
     */
    orderBy?: RetargetingPlanOrderByWithRelationInput | RetargetingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetargetingPlans.
     */
    cursor?: RetargetingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetargetingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetargetingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetargetingPlans.
     */
    distinct?: RetargetingPlanScalarFieldEnum | RetargetingPlanScalarFieldEnum[]
  }

  /**
   * RetargetingPlan findFirstOrThrow
   */
  export type RetargetingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    /**
     * Filter, which RetargetingPlan to fetch.
     */
    where?: RetargetingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetargetingPlans to fetch.
     */
    orderBy?: RetargetingPlanOrderByWithRelationInput | RetargetingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RetargetingPlans.
     */
    cursor?: RetargetingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetargetingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetargetingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RetargetingPlans.
     */
    distinct?: RetargetingPlanScalarFieldEnum | RetargetingPlanScalarFieldEnum[]
  }

  /**
   * RetargetingPlan findMany
   */
  export type RetargetingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    /**
     * Filter, which RetargetingPlans to fetch.
     */
    where?: RetargetingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RetargetingPlans to fetch.
     */
    orderBy?: RetargetingPlanOrderByWithRelationInput | RetargetingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RetargetingPlans.
     */
    cursor?: RetargetingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RetargetingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RetargetingPlans.
     */
    skip?: number
    distinct?: RetargetingPlanScalarFieldEnum | RetargetingPlanScalarFieldEnum[]
  }

  /**
   * RetargetingPlan create
   */
  export type RetargetingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a RetargetingPlan.
     */
    data: XOR<RetargetingPlanCreateInput, RetargetingPlanUncheckedCreateInput>
  }

  /**
   * RetargetingPlan createMany
   */
  export type RetargetingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RetargetingPlans.
     */
    data: RetargetingPlanCreateManyInput | RetargetingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RetargetingPlan createManyAndReturn
   */
  export type RetargetingPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RetargetingPlans.
     */
    data: RetargetingPlanCreateManyInput | RetargetingPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RetargetingPlan update
   */
  export type RetargetingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a RetargetingPlan.
     */
    data: XOR<RetargetingPlanUpdateInput, RetargetingPlanUncheckedUpdateInput>
    /**
     * Choose, which RetargetingPlan to update.
     */
    where: RetargetingPlanWhereUniqueInput
  }

  /**
   * RetargetingPlan updateMany
   */
  export type RetargetingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RetargetingPlans.
     */
    data: XOR<RetargetingPlanUpdateManyMutationInput, RetargetingPlanUncheckedUpdateManyInput>
    /**
     * Filter which RetargetingPlans to update
     */
    where?: RetargetingPlanWhereInput
  }

  /**
   * RetargetingPlan upsert
   */
  export type RetargetingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the RetargetingPlan to update in case it exists.
     */
    where: RetargetingPlanWhereUniqueInput
    /**
     * In case the RetargetingPlan found by the `where` argument doesn't exist, create a new RetargetingPlan with this data.
     */
    create: XOR<RetargetingPlanCreateInput, RetargetingPlanUncheckedCreateInput>
    /**
     * In case the RetargetingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RetargetingPlanUpdateInput, RetargetingPlanUncheckedUpdateInput>
  }

  /**
   * RetargetingPlan delete
   */
  export type RetargetingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
    /**
     * Filter which RetargetingPlan to delete.
     */
    where: RetargetingPlanWhereUniqueInput
  }

  /**
   * RetargetingPlan deleteMany
   */
  export type RetargetingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RetargetingPlans to delete
     */
    where?: RetargetingPlanWhereInput
  }

  /**
   * RetargetingPlan without action
   */
  export type RetargetingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RetargetingPlan
     */
    select?: RetargetingPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetargetingPlanInclude<ExtArgs> | null
  }


  /**
   * Model CampaignExtensionPlan
   */

  export type AggregateCampaignExtensionPlan = {
    _count: CampaignExtensionPlanCountAggregateOutputType | null
    _min: CampaignExtensionPlanMinAggregateOutputType | null
    _max: CampaignExtensionPlanMaxAggregateOutputType | null
  }

  export type CampaignExtensionPlanMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    reason: string | null
    extendedTo: Date | null
    details: string | null
    createdAt: Date | null
  }

  export type CampaignExtensionPlanMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    reason: string | null
    extendedTo: Date | null
    details: string | null
    createdAt: Date | null
  }

  export type CampaignExtensionPlanCountAggregateOutputType = {
    id: number
    campaignId: number
    reason: number
    extendedTo: number
    details: number
    createdAt: number
    _all: number
  }


  export type CampaignExtensionPlanMinAggregateInputType = {
    id?: true
    campaignId?: true
    reason?: true
    extendedTo?: true
    details?: true
    createdAt?: true
  }

  export type CampaignExtensionPlanMaxAggregateInputType = {
    id?: true
    campaignId?: true
    reason?: true
    extendedTo?: true
    details?: true
    createdAt?: true
  }

  export type CampaignExtensionPlanCountAggregateInputType = {
    id?: true
    campaignId?: true
    reason?: true
    extendedTo?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignExtensionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignExtensionPlan to aggregate.
     */
    where?: CampaignExtensionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignExtensionPlans to fetch.
     */
    orderBy?: CampaignExtensionPlanOrderByWithRelationInput | CampaignExtensionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignExtensionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignExtensionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignExtensionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignExtensionPlans
    **/
    _count?: true | CampaignExtensionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignExtensionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignExtensionPlanMaxAggregateInputType
  }

  export type GetCampaignExtensionPlanAggregateType<T extends CampaignExtensionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignExtensionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignExtensionPlan[P]>
      : GetScalarType<T[P], AggregateCampaignExtensionPlan[P]>
  }




  export type CampaignExtensionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignExtensionPlanWhereInput
    orderBy?: CampaignExtensionPlanOrderByWithAggregationInput | CampaignExtensionPlanOrderByWithAggregationInput[]
    by: CampaignExtensionPlanScalarFieldEnum[] | CampaignExtensionPlanScalarFieldEnum
    having?: CampaignExtensionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignExtensionPlanCountAggregateInputType | true
    _min?: CampaignExtensionPlanMinAggregateInputType
    _max?: CampaignExtensionPlanMaxAggregateInputType
  }

  export type CampaignExtensionPlanGroupByOutputType = {
    id: string
    campaignId: string
    reason: string
    extendedTo: Date
    details: string
    createdAt: Date
    _count: CampaignExtensionPlanCountAggregateOutputType | null
    _min: CampaignExtensionPlanMinAggregateOutputType | null
    _max: CampaignExtensionPlanMaxAggregateOutputType | null
  }

  type GetCampaignExtensionPlanGroupByPayload<T extends CampaignExtensionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignExtensionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignExtensionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignExtensionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignExtensionPlanGroupByOutputType[P]>
        }
      >
    >


  export type CampaignExtensionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    reason?: boolean
    extendedTo?: boolean
    details?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignExtensionPlan"]>

  export type CampaignExtensionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    reason?: boolean
    extendedTo?: boolean
    details?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignExtensionPlan"]>

  export type CampaignExtensionPlanSelectScalar = {
    id?: boolean
    campaignId?: boolean
    reason?: boolean
    extendedTo?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type CampaignExtensionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignExtensionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignExtensionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignExtensionPlan"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      reason: string
      extendedTo: Date
      details: string
      createdAt: Date
    }, ExtArgs["result"]["campaignExtensionPlan"]>
    composites: {}
  }

  type CampaignExtensionPlanGetPayload<S extends boolean | null | undefined | CampaignExtensionPlanDefaultArgs> = $Result.GetResult<Prisma.$CampaignExtensionPlanPayload, S>

  type CampaignExtensionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignExtensionPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignExtensionPlanCountAggregateInputType | true
    }

  export interface CampaignExtensionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignExtensionPlan'], meta: { name: 'CampaignExtensionPlan' } }
    /**
     * Find zero or one CampaignExtensionPlan that matches the filter.
     * @param {CampaignExtensionPlanFindUniqueArgs} args - Arguments to find a CampaignExtensionPlan
     * @example
     * // Get one CampaignExtensionPlan
     * const campaignExtensionPlan = await prisma.campaignExtensionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignExtensionPlanFindUniqueArgs>(args: SelectSubset<T, CampaignExtensionPlanFindUniqueArgs<ExtArgs>>): Prisma__CampaignExtensionPlanClient<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignExtensionPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignExtensionPlanFindUniqueOrThrowArgs} args - Arguments to find a CampaignExtensionPlan
     * @example
     * // Get one CampaignExtensionPlan
     * const campaignExtensionPlan = await prisma.campaignExtensionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignExtensionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignExtensionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignExtensionPlanClient<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignExtensionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignExtensionPlanFindFirstArgs} args - Arguments to find a CampaignExtensionPlan
     * @example
     * // Get one CampaignExtensionPlan
     * const campaignExtensionPlan = await prisma.campaignExtensionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignExtensionPlanFindFirstArgs>(args?: SelectSubset<T, CampaignExtensionPlanFindFirstArgs<ExtArgs>>): Prisma__CampaignExtensionPlanClient<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignExtensionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignExtensionPlanFindFirstOrThrowArgs} args - Arguments to find a CampaignExtensionPlan
     * @example
     * // Get one CampaignExtensionPlan
     * const campaignExtensionPlan = await prisma.campaignExtensionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignExtensionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignExtensionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignExtensionPlanClient<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignExtensionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignExtensionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignExtensionPlans
     * const campaignExtensionPlans = await prisma.campaignExtensionPlan.findMany()
     * 
     * // Get first 10 CampaignExtensionPlans
     * const campaignExtensionPlans = await prisma.campaignExtensionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignExtensionPlanWithIdOnly = await prisma.campaignExtensionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignExtensionPlanFindManyArgs>(args?: SelectSubset<T, CampaignExtensionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignExtensionPlan.
     * @param {CampaignExtensionPlanCreateArgs} args - Arguments to create a CampaignExtensionPlan.
     * @example
     * // Create one CampaignExtensionPlan
     * const CampaignExtensionPlan = await prisma.campaignExtensionPlan.create({
     *   data: {
     *     // ... data to create a CampaignExtensionPlan
     *   }
     * })
     * 
     */
    create<T extends CampaignExtensionPlanCreateArgs>(args: SelectSubset<T, CampaignExtensionPlanCreateArgs<ExtArgs>>): Prisma__CampaignExtensionPlanClient<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignExtensionPlans.
     * @param {CampaignExtensionPlanCreateManyArgs} args - Arguments to create many CampaignExtensionPlans.
     * @example
     * // Create many CampaignExtensionPlans
     * const campaignExtensionPlan = await prisma.campaignExtensionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignExtensionPlanCreateManyArgs>(args?: SelectSubset<T, CampaignExtensionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignExtensionPlans and returns the data saved in the database.
     * @param {CampaignExtensionPlanCreateManyAndReturnArgs} args - Arguments to create many CampaignExtensionPlans.
     * @example
     * // Create many CampaignExtensionPlans
     * const campaignExtensionPlan = await prisma.campaignExtensionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignExtensionPlans and only return the `id`
     * const campaignExtensionPlanWithIdOnly = await prisma.campaignExtensionPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignExtensionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignExtensionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignExtensionPlan.
     * @param {CampaignExtensionPlanDeleteArgs} args - Arguments to delete one CampaignExtensionPlan.
     * @example
     * // Delete one CampaignExtensionPlan
     * const CampaignExtensionPlan = await prisma.campaignExtensionPlan.delete({
     *   where: {
     *     // ... filter to delete one CampaignExtensionPlan
     *   }
     * })
     * 
     */
    delete<T extends CampaignExtensionPlanDeleteArgs>(args: SelectSubset<T, CampaignExtensionPlanDeleteArgs<ExtArgs>>): Prisma__CampaignExtensionPlanClient<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignExtensionPlan.
     * @param {CampaignExtensionPlanUpdateArgs} args - Arguments to update one CampaignExtensionPlan.
     * @example
     * // Update one CampaignExtensionPlan
     * const campaignExtensionPlan = await prisma.campaignExtensionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignExtensionPlanUpdateArgs>(args: SelectSubset<T, CampaignExtensionPlanUpdateArgs<ExtArgs>>): Prisma__CampaignExtensionPlanClient<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignExtensionPlans.
     * @param {CampaignExtensionPlanDeleteManyArgs} args - Arguments to filter CampaignExtensionPlans to delete.
     * @example
     * // Delete a few CampaignExtensionPlans
     * const { count } = await prisma.campaignExtensionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignExtensionPlanDeleteManyArgs>(args?: SelectSubset<T, CampaignExtensionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignExtensionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignExtensionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignExtensionPlans
     * const campaignExtensionPlan = await prisma.campaignExtensionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignExtensionPlanUpdateManyArgs>(args: SelectSubset<T, CampaignExtensionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignExtensionPlan.
     * @param {CampaignExtensionPlanUpsertArgs} args - Arguments to update or create a CampaignExtensionPlan.
     * @example
     * // Update or create a CampaignExtensionPlan
     * const campaignExtensionPlan = await prisma.campaignExtensionPlan.upsert({
     *   create: {
     *     // ... data to create a CampaignExtensionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignExtensionPlan we want to update
     *   }
     * })
     */
    upsert<T extends CampaignExtensionPlanUpsertArgs>(args: SelectSubset<T, CampaignExtensionPlanUpsertArgs<ExtArgs>>): Prisma__CampaignExtensionPlanClient<$Result.GetResult<Prisma.$CampaignExtensionPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignExtensionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignExtensionPlanCountArgs} args - Arguments to filter CampaignExtensionPlans to count.
     * @example
     * // Count the number of CampaignExtensionPlans
     * const count = await prisma.campaignExtensionPlan.count({
     *   where: {
     *     // ... the filter for the CampaignExtensionPlans we want to count
     *   }
     * })
    **/
    count<T extends CampaignExtensionPlanCountArgs>(
      args?: Subset<T, CampaignExtensionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignExtensionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignExtensionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignExtensionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignExtensionPlanAggregateArgs>(args: Subset<T, CampaignExtensionPlanAggregateArgs>): Prisma.PrismaPromise<GetCampaignExtensionPlanAggregateType<T>>

    /**
     * Group by CampaignExtensionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignExtensionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignExtensionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignExtensionPlanGroupByArgs['orderBy'] }
        : { orderBy?: CampaignExtensionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignExtensionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignExtensionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignExtensionPlan model
   */
  readonly fields: CampaignExtensionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignExtensionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignExtensionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignExtensionPlan model
   */ 
  interface CampaignExtensionPlanFieldRefs {
    readonly id: FieldRef<"CampaignExtensionPlan", 'String'>
    readonly campaignId: FieldRef<"CampaignExtensionPlan", 'String'>
    readonly reason: FieldRef<"CampaignExtensionPlan", 'String'>
    readonly extendedTo: FieldRef<"CampaignExtensionPlan", 'DateTime'>
    readonly details: FieldRef<"CampaignExtensionPlan", 'String'>
    readonly createdAt: FieldRef<"CampaignExtensionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignExtensionPlan findUnique
   */
  export type CampaignExtensionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    /**
     * Filter, which CampaignExtensionPlan to fetch.
     */
    where: CampaignExtensionPlanWhereUniqueInput
  }

  /**
   * CampaignExtensionPlan findUniqueOrThrow
   */
  export type CampaignExtensionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    /**
     * Filter, which CampaignExtensionPlan to fetch.
     */
    where: CampaignExtensionPlanWhereUniqueInput
  }

  /**
   * CampaignExtensionPlan findFirst
   */
  export type CampaignExtensionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    /**
     * Filter, which CampaignExtensionPlan to fetch.
     */
    where?: CampaignExtensionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignExtensionPlans to fetch.
     */
    orderBy?: CampaignExtensionPlanOrderByWithRelationInput | CampaignExtensionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignExtensionPlans.
     */
    cursor?: CampaignExtensionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignExtensionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignExtensionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignExtensionPlans.
     */
    distinct?: CampaignExtensionPlanScalarFieldEnum | CampaignExtensionPlanScalarFieldEnum[]
  }

  /**
   * CampaignExtensionPlan findFirstOrThrow
   */
  export type CampaignExtensionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    /**
     * Filter, which CampaignExtensionPlan to fetch.
     */
    where?: CampaignExtensionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignExtensionPlans to fetch.
     */
    orderBy?: CampaignExtensionPlanOrderByWithRelationInput | CampaignExtensionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignExtensionPlans.
     */
    cursor?: CampaignExtensionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignExtensionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignExtensionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignExtensionPlans.
     */
    distinct?: CampaignExtensionPlanScalarFieldEnum | CampaignExtensionPlanScalarFieldEnum[]
  }

  /**
   * CampaignExtensionPlan findMany
   */
  export type CampaignExtensionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    /**
     * Filter, which CampaignExtensionPlans to fetch.
     */
    where?: CampaignExtensionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignExtensionPlans to fetch.
     */
    orderBy?: CampaignExtensionPlanOrderByWithRelationInput | CampaignExtensionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignExtensionPlans.
     */
    cursor?: CampaignExtensionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignExtensionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignExtensionPlans.
     */
    skip?: number
    distinct?: CampaignExtensionPlanScalarFieldEnum | CampaignExtensionPlanScalarFieldEnum[]
  }

  /**
   * CampaignExtensionPlan create
   */
  export type CampaignExtensionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignExtensionPlan.
     */
    data: XOR<CampaignExtensionPlanCreateInput, CampaignExtensionPlanUncheckedCreateInput>
  }

  /**
   * CampaignExtensionPlan createMany
   */
  export type CampaignExtensionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignExtensionPlans.
     */
    data: CampaignExtensionPlanCreateManyInput | CampaignExtensionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignExtensionPlan createManyAndReturn
   */
  export type CampaignExtensionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignExtensionPlans.
     */
    data: CampaignExtensionPlanCreateManyInput | CampaignExtensionPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignExtensionPlan update
   */
  export type CampaignExtensionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignExtensionPlan.
     */
    data: XOR<CampaignExtensionPlanUpdateInput, CampaignExtensionPlanUncheckedUpdateInput>
    /**
     * Choose, which CampaignExtensionPlan to update.
     */
    where: CampaignExtensionPlanWhereUniqueInput
  }

  /**
   * CampaignExtensionPlan updateMany
   */
  export type CampaignExtensionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignExtensionPlans.
     */
    data: XOR<CampaignExtensionPlanUpdateManyMutationInput, CampaignExtensionPlanUncheckedUpdateManyInput>
    /**
     * Filter which CampaignExtensionPlans to update
     */
    where?: CampaignExtensionPlanWhereInput
  }

  /**
   * CampaignExtensionPlan upsert
   */
  export type CampaignExtensionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignExtensionPlan to update in case it exists.
     */
    where: CampaignExtensionPlanWhereUniqueInput
    /**
     * In case the CampaignExtensionPlan found by the `where` argument doesn't exist, create a new CampaignExtensionPlan with this data.
     */
    create: XOR<CampaignExtensionPlanCreateInput, CampaignExtensionPlanUncheckedCreateInput>
    /**
     * In case the CampaignExtensionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignExtensionPlanUpdateInput, CampaignExtensionPlanUncheckedUpdateInput>
  }

  /**
   * CampaignExtensionPlan delete
   */
  export type CampaignExtensionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
    /**
     * Filter which CampaignExtensionPlan to delete.
     */
    where: CampaignExtensionPlanWhereUniqueInput
  }

  /**
   * CampaignExtensionPlan deleteMany
   */
  export type CampaignExtensionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignExtensionPlans to delete
     */
    where?: CampaignExtensionPlanWhereInput
  }

  /**
   * CampaignExtensionPlan without action
   */
  export type CampaignExtensionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignExtensionPlan
     */
    select?: CampaignExtensionPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignExtensionPlanInclude<ExtArgs> | null
  }


  /**
   * Model CampaignAnalysisReport
   */

  export type AggregateCampaignAnalysisReport = {
    _count: CampaignAnalysisReportCountAggregateOutputType | null
    _avg: CampaignAnalysisReportAvgAggregateOutputType | null
    _sum: CampaignAnalysisReportSumAggregateOutputType | null
    _min: CampaignAnalysisReportMinAggregateOutputType | null
    _max: CampaignAnalysisReportMaxAggregateOutputType | null
  }

  export type CampaignAnalysisReportAvgAggregateOutputType = {
    totalImpressions: number | null
    totalClicks: number | null
    totalQrScans: number | null
    totalConversions: number | null
    conversionRate: number | null
    revenueGenerated: number | null
    campaignSpend: number | null
    roi: number | null
    engagementRate: number | null
    csatAverage: number | null
    escalationRate: number | null
  }

  export type CampaignAnalysisReportSumAggregateOutputType = {
    totalImpressions: number | null
    totalClicks: number | null
    totalQrScans: number | null
    totalConversions: number | null
    conversionRate: number | null
    revenueGenerated: number | null
    campaignSpend: number | null
    roi: number | null
    engagementRate: number | null
    csatAverage: number | null
    escalationRate: number | null
  }

  export type CampaignAnalysisReportMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    totalImpressions: number | null
    totalClicks: number | null
    totalQrScans: number | null
    totalConversions: number | null
    conversionRate: number | null
    revenueGenerated: number | null
    campaignSpend: number | null
    roi: number | null
    engagementRate: number | null
    csatAverage: number | null
    escalationRate: number | null
    learningsSummary: string | null
    createdAt: Date | null
  }

  export type CampaignAnalysisReportMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    totalImpressions: number | null
    totalClicks: number | null
    totalQrScans: number | null
    totalConversions: number | null
    conversionRate: number | null
    revenueGenerated: number | null
    campaignSpend: number | null
    roi: number | null
    engagementRate: number | null
    csatAverage: number | null
    escalationRate: number | null
    learningsSummary: string | null
    createdAt: Date | null
  }

  export type CampaignAnalysisReportCountAggregateOutputType = {
    id: number
    campaignId: number
    totalImpressions: number
    totalClicks: number
    totalQrScans: number
    totalConversions: number
    conversionRate: number
    revenueGenerated: number
    campaignSpend: number
    roi: number
    engagementRate: number
    csatAverage: number
    escalationRate: number
    learningsSummary: number
    createdAt: number
    _all: number
  }


  export type CampaignAnalysisReportAvgAggregateInputType = {
    totalImpressions?: true
    totalClicks?: true
    totalQrScans?: true
    totalConversions?: true
    conversionRate?: true
    revenueGenerated?: true
    campaignSpend?: true
    roi?: true
    engagementRate?: true
    csatAverage?: true
    escalationRate?: true
  }

  export type CampaignAnalysisReportSumAggregateInputType = {
    totalImpressions?: true
    totalClicks?: true
    totalQrScans?: true
    totalConversions?: true
    conversionRate?: true
    revenueGenerated?: true
    campaignSpend?: true
    roi?: true
    engagementRate?: true
    csatAverage?: true
    escalationRate?: true
  }

  export type CampaignAnalysisReportMinAggregateInputType = {
    id?: true
    campaignId?: true
    totalImpressions?: true
    totalClicks?: true
    totalQrScans?: true
    totalConversions?: true
    conversionRate?: true
    revenueGenerated?: true
    campaignSpend?: true
    roi?: true
    engagementRate?: true
    csatAverage?: true
    escalationRate?: true
    learningsSummary?: true
    createdAt?: true
  }

  export type CampaignAnalysisReportMaxAggregateInputType = {
    id?: true
    campaignId?: true
    totalImpressions?: true
    totalClicks?: true
    totalQrScans?: true
    totalConversions?: true
    conversionRate?: true
    revenueGenerated?: true
    campaignSpend?: true
    roi?: true
    engagementRate?: true
    csatAverage?: true
    escalationRate?: true
    learningsSummary?: true
    createdAt?: true
  }

  export type CampaignAnalysisReportCountAggregateInputType = {
    id?: true
    campaignId?: true
    totalImpressions?: true
    totalClicks?: true
    totalQrScans?: true
    totalConversions?: true
    conversionRate?: true
    revenueGenerated?: true
    campaignSpend?: true
    roi?: true
    engagementRate?: true
    csatAverage?: true
    escalationRate?: true
    learningsSummary?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignAnalysisReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignAnalysisReport to aggregate.
     */
    where?: CampaignAnalysisReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAnalysisReports to fetch.
     */
    orderBy?: CampaignAnalysisReportOrderByWithRelationInput | CampaignAnalysisReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignAnalysisReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAnalysisReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAnalysisReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignAnalysisReports
    **/
    _count?: true | CampaignAnalysisReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAnalysisReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignAnalysisReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignAnalysisReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignAnalysisReportMaxAggregateInputType
  }

  export type GetCampaignAnalysisReportAggregateType<T extends CampaignAnalysisReportAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignAnalysisReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignAnalysisReport[P]>
      : GetScalarType<T[P], AggregateCampaignAnalysisReport[P]>
  }




  export type CampaignAnalysisReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignAnalysisReportWhereInput
    orderBy?: CampaignAnalysisReportOrderByWithAggregationInput | CampaignAnalysisReportOrderByWithAggregationInput[]
    by: CampaignAnalysisReportScalarFieldEnum[] | CampaignAnalysisReportScalarFieldEnum
    having?: CampaignAnalysisReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignAnalysisReportCountAggregateInputType | true
    _avg?: CampaignAnalysisReportAvgAggregateInputType
    _sum?: CampaignAnalysisReportSumAggregateInputType
    _min?: CampaignAnalysisReportMinAggregateInputType
    _max?: CampaignAnalysisReportMaxAggregateInputType
  }

  export type CampaignAnalysisReportGroupByOutputType = {
    id: string
    campaignId: string
    totalImpressions: number
    totalClicks: number
    totalQrScans: number
    totalConversions: number
    conversionRate: number
    revenueGenerated: number
    campaignSpend: number
    roi: number
    engagementRate: number
    csatAverage: number
    escalationRate: number
    learningsSummary: string | null
    createdAt: Date
    _count: CampaignAnalysisReportCountAggregateOutputType | null
    _avg: CampaignAnalysisReportAvgAggregateOutputType | null
    _sum: CampaignAnalysisReportSumAggregateOutputType | null
    _min: CampaignAnalysisReportMinAggregateOutputType | null
    _max: CampaignAnalysisReportMaxAggregateOutputType | null
  }

  type GetCampaignAnalysisReportGroupByPayload<T extends CampaignAnalysisReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignAnalysisReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignAnalysisReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignAnalysisReportGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignAnalysisReportGroupByOutputType[P]>
        }
      >
    >


  export type CampaignAnalysisReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    totalImpressions?: boolean
    totalClicks?: boolean
    totalQrScans?: boolean
    totalConversions?: boolean
    conversionRate?: boolean
    revenueGenerated?: boolean
    campaignSpend?: boolean
    roi?: boolean
    engagementRate?: boolean
    csatAverage?: boolean
    escalationRate?: boolean
    learningsSummary?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignAnalysisReport"]>

  export type CampaignAnalysisReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    totalImpressions?: boolean
    totalClicks?: boolean
    totalQrScans?: boolean
    totalConversions?: boolean
    conversionRate?: boolean
    revenueGenerated?: boolean
    campaignSpend?: boolean
    roi?: boolean
    engagementRate?: boolean
    csatAverage?: boolean
    escalationRate?: boolean
    learningsSummary?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignAnalysisReport"]>

  export type CampaignAnalysisReportSelectScalar = {
    id?: boolean
    campaignId?: boolean
    totalImpressions?: boolean
    totalClicks?: boolean
    totalQrScans?: boolean
    totalConversions?: boolean
    conversionRate?: boolean
    revenueGenerated?: boolean
    campaignSpend?: boolean
    roi?: boolean
    engagementRate?: boolean
    csatAverage?: boolean
    escalationRate?: boolean
    learningsSummary?: boolean
    createdAt?: boolean
  }

  export type CampaignAnalysisReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignAnalysisReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignAnalysisReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignAnalysisReport"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      totalImpressions: number
      totalClicks: number
      totalQrScans: number
      totalConversions: number
      conversionRate: number
      revenueGenerated: number
      campaignSpend: number
      roi: number
      engagementRate: number
      csatAverage: number
      escalationRate: number
      learningsSummary: string | null
      createdAt: Date
    }, ExtArgs["result"]["campaignAnalysisReport"]>
    composites: {}
  }

  type CampaignAnalysisReportGetPayload<S extends boolean | null | undefined | CampaignAnalysisReportDefaultArgs> = $Result.GetResult<Prisma.$CampaignAnalysisReportPayload, S>

  type CampaignAnalysisReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignAnalysisReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignAnalysisReportCountAggregateInputType | true
    }

  export interface CampaignAnalysisReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignAnalysisReport'], meta: { name: 'CampaignAnalysisReport' } }
    /**
     * Find zero or one CampaignAnalysisReport that matches the filter.
     * @param {CampaignAnalysisReportFindUniqueArgs} args - Arguments to find a CampaignAnalysisReport
     * @example
     * // Get one CampaignAnalysisReport
     * const campaignAnalysisReport = await prisma.campaignAnalysisReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignAnalysisReportFindUniqueArgs>(args: SelectSubset<T, CampaignAnalysisReportFindUniqueArgs<ExtArgs>>): Prisma__CampaignAnalysisReportClient<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignAnalysisReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignAnalysisReportFindUniqueOrThrowArgs} args - Arguments to find a CampaignAnalysisReport
     * @example
     * // Get one CampaignAnalysisReport
     * const campaignAnalysisReport = await prisma.campaignAnalysisReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignAnalysisReportFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignAnalysisReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignAnalysisReportClient<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignAnalysisReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalysisReportFindFirstArgs} args - Arguments to find a CampaignAnalysisReport
     * @example
     * // Get one CampaignAnalysisReport
     * const campaignAnalysisReport = await prisma.campaignAnalysisReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignAnalysisReportFindFirstArgs>(args?: SelectSubset<T, CampaignAnalysisReportFindFirstArgs<ExtArgs>>): Prisma__CampaignAnalysisReportClient<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignAnalysisReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalysisReportFindFirstOrThrowArgs} args - Arguments to find a CampaignAnalysisReport
     * @example
     * // Get one CampaignAnalysisReport
     * const campaignAnalysisReport = await prisma.campaignAnalysisReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignAnalysisReportFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignAnalysisReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignAnalysisReportClient<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignAnalysisReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalysisReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignAnalysisReports
     * const campaignAnalysisReports = await prisma.campaignAnalysisReport.findMany()
     * 
     * // Get first 10 CampaignAnalysisReports
     * const campaignAnalysisReports = await prisma.campaignAnalysisReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignAnalysisReportWithIdOnly = await prisma.campaignAnalysisReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignAnalysisReportFindManyArgs>(args?: SelectSubset<T, CampaignAnalysisReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignAnalysisReport.
     * @param {CampaignAnalysisReportCreateArgs} args - Arguments to create a CampaignAnalysisReport.
     * @example
     * // Create one CampaignAnalysisReport
     * const CampaignAnalysisReport = await prisma.campaignAnalysisReport.create({
     *   data: {
     *     // ... data to create a CampaignAnalysisReport
     *   }
     * })
     * 
     */
    create<T extends CampaignAnalysisReportCreateArgs>(args: SelectSubset<T, CampaignAnalysisReportCreateArgs<ExtArgs>>): Prisma__CampaignAnalysisReportClient<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignAnalysisReports.
     * @param {CampaignAnalysisReportCreateManyArgs} args - Arguments to create many CampaignAnalysisReports.
     * @example
     * // Create many CampaignAnalysisReports
     * const campaignAnalysisReport = await prisma.campaignAnalysisReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignAnalysisReportCreateManyArgs>(args?: SelectSubset<T, CampaignAnalysisReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignAnalysisReports and returns the data saved in the database.
     * @param {CampaignAnalysisReportCreateManyAndReturnArgs} args - Arguments to create many CampaignAnalysisReports.
     * @example
     * // Create many CampaignAnalysisReports
     * const campaignAnalysisReport = await prisma.campaignAnalysisReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignAnalysisReports and only return the `id`
     * const campaignAnalysisReportWithIdOnly = await prisma.campaignAnalysisReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignAnalysisReportCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignAnalysisReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignAnalysisReport.
     * @param {CampaignAnalysisReportDeleteArgs} args - Arguments to delete one CampaignAnalysisReport.
     * @example
     * // Delete one CampaignAnalysisReport
     * const CampaignAnalysisReport = await prisma.campaignAnalysisReport.delete({
     *   where: {
     *     // ... filter to delete one CampaignAnalysisReport
     *   }
     * })
     * 
     */
    delete<T extends CampaignAnalysisReportDeleteArgs>(args: SelectSubset<T, CampaignAnalysisReportDeleteArgs<ExtArgs>>): Prisma__CampaignAnalysisReportClient<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignAnalysisReport.
     * @param {CampaignAnalysisReportUpdateArgs} args - Arguments to update one CampaignAnalysisReport.
     * @example
     * // Update one CampaignAnalysisReport
     * const campaignAnalysisReport = await prisma.campaignAnalysisReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignAnalysisReportUpdateArgs>(args: SelectSubset<T, CampaignAnalysisReportUpdateArgs<ExtArgs>>): Prisma__CampaignAnalysisReportClient<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignAnalysisReports.
     * @param {CampaignAnalysisReportDeleteManyArgs} args - Arguments to filter CampaignAnalysisReports to delete.
     * @example
     * // Delete a few CampaignAnalysisReports
     * const { count } = await prisma.campaignAnalysisReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignAnalysisReportDeleteManyArgs>(args?: SelectSubset<T, CampaignAnalysisReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignAnalysisReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalysisReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignAnalysisReports
     * const campaignAnalysisReport = await prisma.campaignAnalysisReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignAnalysisReportUpdateManyArgs>(args: SelectSubset<T, CampaignAnalysisReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignAnalysisReport.
     * @param {CampaignAnalysisReportUpsertArgs} args - Arguments to update or create a CampaignAnalysisReport.
     * @example
     * // Update or create a CampaignAnalysisReport
     * const campaignAnalysisReport = await prisma.campaignAnalysisReport.upsert({
     *   create: {
     *     // ... data to create a CampaignAnalysisReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignAnalysisReport we want to update
     *   }
     * })
     */
    upsert<T extends CampaignAnalysisReportUpsertArgs>(args: SelectSubset<T, CampaignAnalysisReportUpsertArgs<ExtArgs>>): Prisma__CampaignAnalysisReportClient<$Result.GetResult<Prisma.$CampaignAnalysisReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignAnalysisReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalysisReportCountArgs} args - Arguments to filter CampaignAnalysisReports to count.
     * @example
     * // Count the number of CampaignAnalysisReports
     * const count = await prisma.campaignAnalysisReport.count({
     *   where: {
     *     // ... the filter for the CampaignAnalysisReports we want to count
     *   }
     * })
    **/
    count<T extends CampaignAnalysisReportCountArgs>(
      args?: Subset<T, CampaignAnalysisReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignAnalysisReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignAnalysisReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalysisReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAnalysisReportAggregateArgs>(args: Subset<T, CampaignAnalysisReportAggregateArgs>): Prisma.PrismaPromise<GetCampaignAnalysisReportAggregateType<T>>

    /**
     * Group by CampaignAnalysisReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAnalysisReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignAnalysisReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignAnalysisReportGroupByArgs['orderBy'] }
        : { orderBy?: CampaignAnalysisReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignAnalysisReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignAnalysisReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignAnalysisReport model
   */
  readonly fields: CampaignAnalysisReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignAnalysisReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignAnalysisReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignAnalysisReport model
   */ 
  interface CampaignAnalysisReportFieldRefs {
    readonly id: FieldRef<"CampaignAnalysisReport", 'String'>
    readonly campaignId: FieldRef<"CampaignAnalysisReport", 'String'>
    readonly totalImpressions: FieldRef<"CampaignAnalysisReport", 'Int'>
    readonly totalClicks: FieldRef<"CampaignAnalysisReport", 'Int'>
    readonly totalQrScans: FieldRef<"CampaignAnalysisReport", 'Int'>
    readonly totalConversions: FieldRef<"CampaignAnalysisReport", 'Int'>
    readonly conversionRate: FieldRef<"CampaignAnalysisReport", 'Float'>
    readonly revenueGenerated: FieldRef<"CampaignAnalysisReport", 'Float'>
    readonly campaignSpend: FieldRef<"CampaignAnalysisReport", 'Float'>
    readonly roi: FieldRef<"CampaignAnalysisReport", 'Float'>
    readonly engagementRate: FieldRef<"CampaignAnalysisReport", 'Float'>
    readonly csatAverage: FieldRef<"CampaignAnalysisReport", 'Float'>
    readonly escalationRate: FieldRef<"CampaignAnalysisReport", 'Float'>
    readonly learningsSummary: FieldRef<"CampaignAnalysisReport", 'String'>
    readonly createdAt: FieldRef<"CampaignAnalysisReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignAnalysisReport findUnique
   */
  export type CampaignAnalysisReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalysisReport to fetch.
     */
    where: CampaignAnalysisReportWhereUniqueInput
  }

  /**
   * CampaignAnalysisReport findUniqueOrThrow
   */
  export type CampaignAnalysisReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalysisReport to fetch.
     */
    where: CampaignAnalysisReportWhereUniqueInput
  }

  /**
   * CampaignAnalysisReport findFirst
   */
  export type CampaignAnalysisReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalysisReport to fetch.
     */
    where?: CampaignAnalysisReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAnalysisReports to fetch.
     */
    orderBy?: CampaignAnalysisReportOrderByWithRelationInput | CampaignAnalysisReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAnalysisReports.
     */
    cursor?: CampaignAnalysisReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAnalysisReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAnalysisReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAnalysisReports.
     */
    distinct?: CampaignAnalysisReportScalarFieldEnum | CampaignAnalysisReportScalarFieldEnum[]
  }

  /**
   * CampaignAnalysisReport findFirstOrThrow
   */
  export type CampaignAnalysisReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalysisReport to fetch.
     */
    where?: CampaignAnalysisReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAnalysisReports to fetch.
     */
    orderBy?: CampaignAnalysisReportOrderByWithRelationInput | CampaignAnalysisReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAnalysisReports.
     */
    cursor?: CampaignAnalysisReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAnalysisReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAnalysisReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAnalysisReports.
     */
    distinct?: CampaignAnalysisReportScalarFieldEnum | CampaignAnalysisReportScalarFieldEnum[]
  }

  /**
   * CampaignAnalysisReport findMany
   */
  export type CampaignAnalysisReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAnalysisReports to fetch.
     */
    where?: CampaignAnalysisReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAnalysisReports to fetch.
     */
    orderBy?: CampaignAnalysisReportOrderByWithRelationInput | CampaignAnalysisReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignAnalysisReports.
     */
    cursor?: CampaignAnalysisReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAnalysisReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAnalysisReports.
     */
    skip?: number
    distinct?: CampaignAnalysisReportScalarFieldEnum | CampaignAnalysisReportScalarFieldEnum[]
  }

  /**
   * CampaignAnalysisReport create
   */
  export type CampaignAnalysisReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignAnalysisReport.
     */
    data: XOR<CampaignAnalysisReportCreateInput, CampaignAnalysisReportUncheckedCreateInput>
  }

  /**
   * CampaignAnalysisReport createMany
   */
  export type CampaignAnalysisReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignAnalysisReports.
     */
    data: CampaignAnalysisReportCreateManyInput | CampaignAnalysisReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignAnalysisReport createManyAndReturn
   */
  export type CampaignAnalysisReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignAnalysisReports.
     */
    data: CampaignAnalysisReportCreateManyInput | CampaignAnalysisReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignAnalysisReport update
   */
  export type CampaignAnalysisReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignAnalysisReport.
     */
    data: XOR<CampaignAnalysisReportUpdateInput, CampaignAnalysisReportUncheckedUpdateInput>
    /**
     * Choose, which CampaignAnalysisReport to update.
     */
    where: CampaignAnalysisReportWhereUniqueInput
  }

  /**
   * CampaignAnalysisReport updateMany
   */
  export type CampaignAnalysisReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignAnalysisReports.
     */
    data: XOR<CampaignAnalysisReportUpdateManyMutationInput, CampaignAnalysisReportUncheckedUpdateManyInput>
    /**
     * Filter which CampaignAnalysisReports to update
     */
    where?: CampaignAnalysisReportWhereInput
  }

  /**
   * CampaignAnalysisReport upsert
   */
  export type CampaignAnalysisReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignAnalysisReport to update in case it exists.
     */
    where: CampaignAnalysisReportWhereUniqueInput
    /**
     * In case the CampaignAnalysisReport found by the `where` argument doesn't exist, create a new CampaignAnalysisReport with this data.
     */
    create: XOR<CampaignAnalysisReportCreateInput, CampaignAnalysisReportUncheckedCreateInput>
    /**
     * In case the CampaignAnalysisReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignAnalysisReportUpdateInput, CampaignAnalysisReportUncheckedUpdateInput>
  }

  /**
   * CampaignAnalysisReport delete
   */
  export type CampaignAnalysisReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
    /**
     * Filter which CampaignAnalysisReport to delete.
     */
    where: CampaignAnalysisReportWhereUniqueInput
  }

  /**
   * CampaignAnalysisReport deleteMany
   */
  export type CampaignAnalysisReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignAnalysisReports to delete
     */
    where?: CampaignAnalysisReportWhereInput
  }

  /**
   * CampaignAnalysisReport without action
   */
  export type CampaignAnalysisReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAnalysisReport
     */
    select?: CampaignAnalysisReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAnalysisReportInclude<ExtArgs> | null
  }


  /**
   * Model CampaignLearnings
   */

  export type AggregateCampaignLearnings = {
    _count: CampaignLearningsCountAggregateOutputType | null
    _min: CampaignLearningsMinAggregateOutputType | null
    _max: CampaignLearningsMaxAggregateOutputType | null
  }

  export type CampaignLearningsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    whatWorked: string | null
    whatDidNotWork: string | null
    bestPractices: string | null
    improvementAreas: string | null
    createdAt: Date | null
  }

  export type CampaignLearningsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    whatWorked: string | null
    whatDidNotWork: string | null
    bestPractices: string | null
    improvementAreas: string | null
    createdAt: Date | null
  }

  export type CampaignLearningsCountAggregateOutputType = {
    id: number
    campaignId: number
    whatWorked: number
    whatDidNotWork: number
    bestPractices: number
    improvementAreas: number
    createdAt: number
    _all: number
  }


  export type CampaignLearningsMinAggregateInputType = {
    id?: true
    campaignId?: true
    whatWorked?: true
    whatDidNotWork?: true
    bestPractices?: true
    improvementAreas?: true
    createdAt?: true
  }

  export type CampaignLearningsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    whatWorked?: true
    whatDidNotWork?: true
    bestPractices?: true
    improvementAreas?: true
    createdAt?: true
  }

  export type CampaignLearningsCountAggregateInputType = {
    id?: true
    campaignId?: true
    whatWorked?: true
    whatDidNotWork?: true
    bestPractices?: true
    improvementAreas?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignLearningsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLearnings to aggregate.
     */
    where?: CampaignLearningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLearnings to fetch.
     */
    orderBy?: CampaignLearningsOrderByWithRelationInput | CampaignLearningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignLearningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignLearnings
    **/
    _count?: true | CampaignLearningsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignLearningsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignLearningsMaxAggregateInputType
  }

  export type GetCampaignLearningsAggregateType<T extends CampaignLearningsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignLearnings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignLearnings[P]>
      : GetScalarType<T[P], AggregateCampaignLearnings[P]>
  }




  export type CampaignLearningsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLearningsWhereInput
    orderBy?: CampaignLearningsOrderByWithAggregationInput | CampaignLearningsOrderByWithAggregationInput[]
    by: CampaignLearningsScalarFieldEnum[] | CampaignLearningsScalarFieldEnum
    having?: CampaignLearningsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignLearningsCountAggregateInputType | true
    _min?: CampaignLearningsMinAggregateInputType
    _max?: CampaignLearningsMaxAggregateInputType
  }

  export type CampaignLearningsGroupByOutputType = {
    id: string
    campaignId: string
    whatWorked: string
    whatDidNotWork: string
    bestPractices: string
    improvementAreas: string
    createdAt: Date
    _count: CampaignLearningsCountAggregateOutputType | null
    _min: CampaignLearningsMinAggregateOutputType | null
    _max: CampaignLearningsMaxAggregateOutputType | null
  }

  type GetCampaignLearningsGroupByPayload<T extends CampaignLearningsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignLearningsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignLearningsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignLearningsGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignLearningsGroupByOutputType[P]>
        }
      >
    >


  export type CampaignLearningsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    whatWorked?: boolean
    whatDidNotWork?: boolean
    bestPractices?: boolean
    improvementAreas?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLearnings"]>

  export type CampaignLearningsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    whatWorked?: boolean
    whatDidNotWork?: boolean
    bestPractices?: boolean
    improvementAreas?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLearnings"]>

  export type CampaignLearningsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    whatWorked?: boolean
    whatDidNotWork?: boolean
    bestPractices?: boolean
    improvementAreas?: boolean
    createdAt?: boolean
  }

  export type CampaignLearningsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignLearningsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignLearningsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignLearnings"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      whatWorked: string
      whatDidNotWork: string
      bestPractices: string
      improvementAreas: string
      createdAt: Date
    }, ExtArgs["result"]["campaignLearnings"]>
    composites: {}
  }

  type CampaignLearningsGetPayload<S extends boolean | null | undefined | CampaignLearningsDefaultArgs> = $Result.GetResult<Prisma.$CampaignLearningsPayload, S>

  type CampaignLearningsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignLearningsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignLearningsCountAggregateInputType | true
    }

  export interface CampaignLearningsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignLearnings'], meta: { name: 'CampaignLearnings' } }
    /**
     * Find zero or one CampaignLearnings that matches the filter.
     * @param {CampaignLearningsFindUniqueArgs} args - Arguments to find a CampaignLearnings
     * @example
     * // Get one CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignLearningsFindUniqueArgs>(args: SelectSubset<T, CampaignLearningsFindUniqueArgs<ExtArgs>>): Prisma__CampaignLearningsClient<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignLearnings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignLearningsFindUniqueOrThrowArgs} args - Arguments to find a CampaignLearnings
     * @example
     * // Get one CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignLearningsFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignLearningsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignLearningsClient<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignLearnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLearningsFindFirstArgs} args - Arguments to find a CampaignLearnings
     * @example
     * // Get one CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignLearningsFindFirstArgs>(args?: SelectSubset<T, CampaignLearningsFindFirstArgs<ExtArgs>>): Prisma__CampaignLearningsClient<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignLearnings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLearningsFindFirstOrThrowArgs} args - Arguments to find a CampaignLearnings
     * @example
     * // Get one CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignLearningsFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignLearningsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignLearningsClient<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignLearnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLearningsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.findMany()
     * 
     * // Get first 10 CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignLearningsWithIdOnly = await prisma.campaignLearnings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignLearningsFindManyArgs>(args?: SelectSubset<T, CampaignLearningsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignLearnings.
     * @param {CampaignLearningsCreateArgs} args - Arguments to create a CampaignLearnings.
     * @example
     * // Create one CampaignLearnings
     * const CampaignLearnings = await prisma.campaignLearnings.create({
     *   data: {
     *     // ... data to create a CampaignLearnings
     *   }
     * })
     * 
     */
    create<T extends CampaignLearningsCreateArgs>(args: SelectSubset<T, CampaignLearningsCreateArgs<ExtArgs>>): Prisma__CampaignLearningsClient<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignLearnings.
     * @param {CampaignLearningsCreateManyArgs} args - Arguments to create many CampaignLearnings.
     * @example
     * // Create many CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignLearningsCreateManyArgs>(args?: SelectSubset<T, CampaignLearningsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignLearnings and returns the data saved in the database.
     * @param {CampaignLearningsCreateManyAndReturnArgs} args - Arguments to create many CampaignLearnings.
     * @example
     * // Create many CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignLearnings and only return the `id`
     * const campaignLearningsWithIdOnly = await prisma.campaignLearnings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignLearningsCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignLearningsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignLearnings.
     * @param {CampaignLearningsDeleteArgs} args - Arguments to delete one CampaignLearnings.
     * @example
     * // Delete one CampaignLearnings
     * const CampaignLearnings = await prisma.campaignLearnings.delete({
     *   where: {
     *     // ... filter to delete one CampaignLearnings
     *   }
     * })
     * 
     */
    delete<T extends CampaignLearningsDeleteArgs>(args: SelectSubset<T, CampaignLearningsDeleteArgs<ExtArgs>>): Prisma__CampaignLearningsClient<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignLearnings.
     * @param {CampaignLearningsUpdateArgs} args - Arguments to update one CampaignLearnings.
     * @example
     * // Update one CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignLearningsUpdateArgs>(args: SelectSubset<T, CampaignLearningsUpdateArgs<ExtArgs>>): Prisma__CampaignLearningsClient<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignLearnings.
     * @param {CampaignLearningsDeleteManyArgs} args - Arguments to filter CampaignLearnings to delete.
     * @example
     * // Delete a few CampaignLearnings
     * const { count } = await prisma.campaignLearnings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignLearningsDeleteManyArgs>(args?: SelectSubset<T, CampaignLearningsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLearningsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignLearningsUpdateManyArgs>(args: SelectSubset<T, CampaignLearningsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignLearnings.
     * @param {CampaignLearningsUpsertArgs} args - Arguments to update or create a CampaignLearnings.
     * @example
     * // Update or create a CampaignLearnings
     * const campaignLearnings = await prisma.campaignLearnings.upsert({
     *   create: {
     *     // ... data to create a CampaignLearnings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignLearnings we want to update
     *   }
     * })
     */
    upsert<T extends CampaignLearningsUpsertArgs>(args: SelectSubset<T, CampaignLearningsUpsertArgs<ExtArgs>>): Prisma__CampaignLearningsClient<$Result.GetResult<Prisma.$CampaignLearningsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLearningsCountArgs} args - Arguments to filter CampaignLearnings to count.
     * @example
     * // Count the number of CampaignLearnings
     * const count = await prisma.campaignLearnings.count({
     *   where: {
     *     // ... the filter for the CampaignLearnings we want to count
     *   }
     * })
    **/
    count<T extends CampaignLearningsCountArgs>(
      args?: Subset<T, CampaignLearningsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignLearningsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLearningsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignLearningsAggregateArgs>(args: Subset<T, CampaignLearningsAggregateArgs>): Prisma.PrismaPromise<GetCampaignLearningsAggregateType<T>>

    /**
     * Group by CampaignLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLearningsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignLearningsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignLearningsGroupByArgs['orderBy'] }
        : { orderBy?: CampaignLearningsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignLearningsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignLearningsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignLearnings model
   */
  readonly fields: CampaignLearningsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignLearnings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignLearningsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignLearnings model
   */ 
  interface CampaignLearningsFieldRefs {
    readonly id: FieldRef<"CampaignLearnings", 'String'>
    readonly campaignId: FieldRef<"CampaignLearnings", 'String'>
    readonly whatWorked: FieldRef<"CampaignLearnings", 'String'>
    readonly whatDidNotWork: FieldRef<"CampaignLearnings", 'String'>
    readonly bestPractices: FieldRef<"CampaignLearnings", 'String'>
    readonly improvementAreas: FieldRef<"CampaignLearnings", 'String'>
    readonly createdAt: FieldRef<"CampaignLearnings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignLearnings findUnique
   */
  export type CampaignLearningsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLearnings to fetch.
     */
    where: CampaignLearningsWhereUniqueInput
  }

  /**
   * CampaignLearnings findUniqueOrThrow
   */
  export type CampaignLearningsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLearnings to fetch.
     */
    where: CampaignLearningsWhereUniqueInput
  }

  /**
   * CampaignLearnings findFirst
   */
  export type CampaignLearningsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLearnings to fetch.
     */
    where?: CampaignLearningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLearnings to fetch.
     */
    orderBy?: CampaignLearningsOrderByWithRelationInput | CampaignLearningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLearnings.
     */
    cursor?: CampaignLearningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLearnings.
     */
    distinct?: CampaignLearningsScalarFieldEnum | CampaignLearningsScalarFieldEnum[]
  }

  /**
   * CampaignLearnings findFirstOrThrow
   */
  export type CampaignLearningsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLearnings to fetch.
     */
    where?: CampaignLearningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLearnings to fetch.
     */
    orderBy?: CampaignLearningsOrderByWithRelationInput | CampaignLearningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLearnings.
     */
    cursor?: CampaignLearningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLearnings.
     */
    distinct?: CampaignLearningsScalarFieldEnum | CampaignLearningsScalarFieldEnum[]
  }

  /**
   * CampaignLearnings findMany
   */
  export type CampaignLearningsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLearnings to fetch.
     */
    where?: CampaignLearningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLearnings to fetch.
     */
    orderBy?: CampaignLearningsOrderByWithRelationInput | CampaignLearningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignLearnings.
     */
    cursor?: CampaignLearningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLearnings.
     */
    skip?: number
    distinct?: CampaignLearningsScalarFieldEnum | CampaignLearningsScalarFieldEnum[]
  }

  /**
   * CampaignLearnings create
   */
  export type CampaignLearningsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignLearnings.
     */
    data: XOR<CampaignLearningsCreateInput, CampaignLearningsUncheckedCreateInput>
  }

  /**
   * CampaignLearnings createMany
   */
  export type CampaignLearningsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignLearnings.
     */
    data: CampaignLearningsCreateManyInput | CampaignLearningsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignLearnings createManyAndReturn
   */
  export type CampaignLearningsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignLearnings.
     */
    data: CampaignLearningsCreateManyInput | CampaignLearningsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignLearnings update
   */
  export type CampaignLearningsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignLearnings.
     */
    data: XOR<CampaignLearningsUpdateInput, CampaignLearningsUncheckedUpdateInput>
    /**
     * Choose, which CampaignLearnings to update.
     */
    where: CampaignLearningsWhereUniqueInput
  }

  /**
   * CampaignLearnings updateMany
   */
  export type CampaignLearningsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignLearnings.
     */
    data: XOR<CampaignLearningsUpdateManyMutationInput, CampaignLearningsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignLearnings to update
     */
    where?: CampaignLearningsWhereInput
  }

  /**
   * CampaignLearnings upsert
   */
  export type CampaignLearningsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignLearnings to update in case it exists.
     */
    where: CampaignLearningsWhereUniqueInput
    /**
     * In case the CampaignLearnings found by the `where` argument doesn't exist, create a new CampaignLearnings with this data.
     */
    create: XOR<CampaignLearningsCreateInput, CampaignLearningsUncheckedCreateInput>
    /**
     * In case the CampaignLearnings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignLearningsUpdateInput, CampaignLearningsUncheckedUpdateInput>
  }

  /**
   * CampaignLearnings delete
   */
  export type CampaignLearningsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
    /**
     * Filter which CampaignLearnings to delete.
     */
    where: CampaignLearningsWhereUniqueInput
  }

  /**
   * CampaignLearnings deleteMany
   */
  export type CampaignLearningsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLearnings to delete
     */
    where?: CampaignLearningsWhereInput
  }

  /**
   * CampaignLearnings without action
   */
  export type CampaignLearningsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLearnings
     */
    select?: CampaignLearningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLearningsInclude<ExtArgs> | null
  }


  /**
   * Model InternalCampaignReport
   */

  export type AggregateInternalCampaignReport = {
    _count: InternalCampaignReportCountAggregateOutputType | null
    _min: InternalCampaignReportMinAggregateOutputType | null
    _max: InternalCampaignReportMaxAggregateOutputType | null
  }

  export type InternalCampaignReportMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    reportTitle: string | null
    executiveSummary: string | null
    kpiHighlights: string | null
    learningHighlights: string | null
    improvementAreas: string | null
    graphsReference: string | null
    createdAt: Date | null
  }

  export type InternalCampaignReportMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    reportTitle: string | null
    executiveSummary: string | null
    kpiHighlights: string | null
    learningHighlights: string | null
    improvementAreas: string | null
    graphsReference: string | null
    createdAt: Date | null
  }

  export type InternalCampaignReportCountAggregateOutputType = {
    id: number
    campaignId: number
    reportTitle: number
    executiveSummary: number
    kpiHighlights: number
    learningHighlights: number
    improvementAreas: number
    graphsReference: number
    createdAt: number
    _all: number
  }


  export type InternalCampaignReportMinAggregateInputType = {
    id?: true
    campaignId?: true
    reportTitle?: true
    executiveSummary?: true
    kpiHighlights?: true
    learningHighlights?: true
    improvementAreas?: true
    graphsReference?: true
    createdAt?: true
  }

  export type InternalCampaignReportMaxAggregateInputType = {
    id?: true
    campaignId?: true
    reportTitle?: true
    executiveSummary?: true
    kpiHighlights?: true
    learningHighlights?: true
    improvementAreas?: true
    graphsReference?: true
    createdAt?: true
  }

  export type InternalCampaignReportCountAggregateInputType = {
    id?: true
    campaignId?: true
    reportTitle?: true
    executiveSummary?: true
    kpiHighlights?: true
    learningHighlights?: true
    improvementAreas?: true
    graphsReference?: true
    createdAt?: true
    _all?: true
  }

  export type InternalCampaignReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternalCampaignReport to aggregate.
     */
    where?: InternalCampaignReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalCampaignReports to fetch.
     */
    orderBy?: InternalCampaignReportOrderByWithRelationInput | InternalCampaignReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InternalCampaignReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalCampaignReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalCampaignReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InternalCampaignReports
    **/
    _count?: true | InternalCampaignReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternalCampaignReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternalCampaignReportMaxAggregateInputType
  }

  export type GetInternalCampaignReportAggregateType<T extends InternalCampaignReportAggregateArgs> = {
        [P in keyof T & keyof AggregateInternalCampaignReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternalCampaignReport[P]>
      : GetScalarType<T[P], AggregateInternalCampaignReport[P]>
  }




  export type InternalCampaignReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternalCampaignReportWhereInput
    orderBy?: InternalCampaignReportOrderByWithAggregationInput | InternalCampaignReportOrderByWithAggregationInput[]
    by: InternalCampaignReportScalarFieldEnum[] | InternalCampaignReportScalarFieldEnum
    having?: InternalCampaignReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternalCampaignReportCountAggregateInputType | true
    _min?: InternalCampaignReportMinAggregateInputType
    _max?: InternalCampaignReportMaxAggregateInputType
  }

  export type InternalCampaignReportGroupByOutputType = {
    id: string
    campaignId: string
    reportTitle: string
    executiveSummary: string
    kpiHighlights: string
    learningHighlights: string
    improvementAreas: string
    graphsReference: string | null
    createdAt: Date
    _count: InternalCampaignReportCountAggregateOutputType | null
    _min: InternalCampaignReportMinAggregateOutputType | null
    _max: InternalCampaignReportMaxAggregateOutputType | null
  }

  type GetInternalCampaignReportGroupByPayload<T extends InternalCampaignReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternalCampaignReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternalCampaignReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternalCampaignReportGroupByOutputType[P]>
            : GetScalarType<T[P], InternalCampaignReportGroupByOutputType[P]>
        }
      >
    >


  export type InternalCampaignReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    reportTitle?: boolean
    executiveSummary?: boolean
    kpiHighlights?: boolean
    learningHighlights?: boolean
    improvementAreas?: boolean
    graphsReference?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internalCampaignReport"]>

  export type InternalCampaignReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    reportTitle?: boolean
    executiveSummary?: boolean
    kpiHighlights?: boolean
    learningHighlights?: boolean
    improvementAreas?: boolean
    graphsReference?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internalCampaignReport"]>

  export type InternalCampaignReportSelectScalar = {
    id?: boolean
    campaignId?: boolean
    reportTitle?: boolean
    executiveSummary?: boolean
    kpiHighlights?: boolean
    learningHighlights?: boolean
    improvementAreas?: boolean
    graphsReference?: boolean
    createdAt?: boolean
  }

  export type InternalCampaignReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type InternalCampaignReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $InternalCampaignReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InternalCampaignReport"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      reportTitle: string
      executiveSummary: string
      kpiHighlights: string
      learningHighlights: string
      improvementAreas: string
      graphsReference: string | null
      createdAt: Date
    }, ExtArgs["result"]["internalCampaignReport"]>
    composites: {}
  }

  type InternalCampaignReportGetPayload<S extends boolean | null | undefined | InternalCampaignReportDefaultArgs> = $Result.GetResult<Prisma.$InternalCampaignReportPayload, S>

  type InternalCampaignReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InternalCampaignReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InternalCampaignReportCountAggregateInputType | true
    }

  export interface InternalCampaignReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InternalCampaignReport'], meta: { name: 'InternalCampaignReport' } }
    /**
     * Find zero or one InternalCampaignReport that matches the filter.
     * @param {InternalCampaignReportFindUniqueArgs} args - Arguments to find a InternalCampaignReport
     * @example
     * // Get one InternalCampaignReport
     * const internalCampaignReport = await prisma.internalCampaignReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InternalCampaignReportFindUniqueArgs>(args: SelectSubset<T, InternalCampaignReportFindUniqueArgs<ExtArgs>>): Prisma__InternalCampaignReportClient<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InternalCampaignReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InternalCampaignReportFindUniqueOrThrowArgs} args - Arguments to find a InternalCampaignReport
     * @example
     * // Get one InternalCampaignReport
     * const internalCampaignReport = await prisma.internalCampaignReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InternalCampaignReportFindUniqueOrThrowArgs>(args: SelectSubset<T, InternalCampaignReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InternalCampaignReportClient<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InternalCampaignReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalCampaignReportFindFirstArgs} args - Arguments to find a InternalCampaignReport
     * @example
     * // Get one InternalCampaignReport
     * const internalCampaignReport = await prisma.internalCampaignReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InternalCampaignReportFindFirstArgs>(args?: SelectSubset<T, InternalCampaignReportFindFirstArgs<ExtArgs>>): Prisma__InternalCampaignReportClient<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InternalCampaignReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalCampaignReportFindFirstOrThrowArgs} args - Arguments to find a InternalCampaignReport
     * @example
     * // Get one InternalCampaignReport
     * const internalCampaignReport = await prisma.internalCampaignReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InternalCampaignReportFindFirstOrThrowArgs>(args?: SelectSubset<T, InternalCampaignReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__InternalCampaignReportClient<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InternalCampaignReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalCampaignReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InternalCampaignReports
     * const internalCampaignReports = await prisma.internalCampaignReport.findMany()
     * 
     * // Get first 10 InternalCampaignReports
     * const internalCampaignReports = await prisma.internalCampaignReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internalCampaignReportWithIdOnly = await prisma.internalCampaignReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InternalCampaignReportFindManyArgs>(args?: SelectSubset<T, InternalCampaignReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InternalCampaignReport.
     * @param {InternalCampaignReportCreateArgs} args - Arguments to create a InternalCampaignReport.
     * @example
     * // Create one InternalCampaignReport
     * const InternalCampaignReport = await prisma.internalCampaignReport.create({
     *   data: {
     *     // ... data to create a InternalCampaignReport
     *   }
     * })
     * 
     */
    create<T extends InternalCampaignReportCreateArgs>(args: SelectSubset<T, InternalCampaignReportCreateArgs<ExtArgs>>): Prisma__InternalCampaignReportClient<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InternalCampaignReports.
     * @param {InternalCampaignReportCreateManyArgs} args - Arguments to create many InternalCampaignReports.
     * @example
     * // Create many InternalCampaignReports
     * const internalCampaignReport = await prisma.internalCampaignReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InternalCampaignReportCreateManyArgs>(args?: SelectSubset<T, InternalCampaignReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InternalCampaignReports and returns the data saved in the database.
     * @param {InternalCampaignReportCreateManyAndReturnArgs} args - Arguments to create many InternalCampaignReports.
     * @example
     * // Create many InternalCampaignReports
     * const internalCampaignReport = await prisma.internalCampaignReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InternalCampaignReports and only return the `id`
     * const internalCampaignReportWithIdOnly = await prisma.internalCampaignReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InternalCampaignReportCreateManyAndReturnArgs>(args?: SelectSubset<T, InternalCampaignReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InternalCampaignReport.
     * @param {InternalCampaignReportDeleteArgs} args - Arguments to delete one InternalCampaignReport.
     * @example
     * // Delete one InternalCampaignReport
     * const InternalCampaignReport = await prisma.internalCampaignReport.delete({
     *   where: {
     *     // ... filter to delete one InternalCampaignReport
     *   }
     * })
     * 
     */
    delete<T extends InternalCampaignReportDeleteArgs>(args: SelectSubset<T, InternalCampaignReportDeleteArgs<ExtArgs>>): Prisma__InternalCampaignReportClient<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InternalCampaignReport.
     * @param {InternalCampaignReportUpdateArgs} args - Arguments to update one InternalCampaignReport.
     * @example
     * // Update one InternalCampaignReport
     * const internalCampaignReport = await prisma.internalCampaignReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InternalCampaignReportUpdateArgs>(args: SelectSubset<T, InternalCampaignReportUpdateArgs<ExtArgs>>): Prisma__InternalCampaignReportClient<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InternalCampaignReports.
     * @param {InternalCampaignReportDeleteManyArgs} args - Arguments to filter InternalCampaignReports to delete.
     * @example
     * // Delete a few InternalCampaignReports
     * const { count } = await prisma.internalCampaignReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InternalCampaignReportDeleteManyArgs>(args?: SelectSubset<T, InternalCampaignReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InternalCampaignReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalCampaignReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InternalCampaignReports
     * const internalCampaignReport = await prisma.internalCampaignReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InternalCampaignReportUpdateManyArgs>(args: SelectSubset<T, InternalCampaignReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InternalCampaignReport.
     * @param {InternalCampaignReportUpsertArgs} args - Arguments to update or create a InternalCampaignReport.
     * @example
     * // Update or create a InternalCampaignReport
     * const internalCampaignReport = await prisma.internalCampaignReport.upsert({
     *   create: {
     *     // ... data to create a InternalCampaignReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InternalCampaignReport we want to update
     *   }
     * })
     */
    upsert<T extends InternalCampaignReportUpsertArgs>(args: SelectSubset<T, InternalCampaignReportUpsertArgs<ExtArgs>>): Prisma__InternalCampaignReportClient<$Result.GetResult<Prisma.$InternalCampaignReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InternalCampaignReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalCampaignReportCountArgs} args - Arguments to filter InternalCampaignReports to count.
     * @example
     * // Count the number of InternalCampaignReports
     * const count = await prisma.internalCampaignReport.count({
     *   where: {
     *     // ... the filter for the InternalCampaignReports we want to count
     *   }
     * })
    **/
    count<T extends InternalCampaignReportCountArgs>(
      args?: Subset<T, InternalCampaignReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternalCampaignReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InternalCampaignReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalCampaignReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternalCampaignReportAggregateArgs>(args: Subset<T, InternalCampaignReportAggregateArgs>): Prisma.PrismaPromise<GetInternalCampaignReportAggregateType<T>>

    /**
     * Group by InternalCampaignReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalCampaignReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InternalCampaignReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InternalCampaignReportGroupByArgs['orderBy'] }
        : { orderBy?: InternalCampaignReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InternalCampaignReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternalCampaignReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InternalCampaignReport model
   */
  readonly fields: InternalCampaignReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InternalCampaignReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InternalCampaignReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InternalCampaignReport model
   */ 
  interface InternalCampaignReportFieldRefs {
    readonly id: FieldRef<"InternalCampaignReport", 'String'>
    readonly campaignId: FieldRef<"InternalCampaignReport", 'String'>
    readonly reportTitle: FieldRef<"InternalCampaignReport", 'String'>
    readonly executiveSummary: FieldRef<"InternalCampaignReport", 'String'>
    readonly kpiHighlights: FieldRef<"InternalCampaignReport", 'String'>
    readonly learningHighlights: FieldRef<"InternalCampaignReport", 'String'>
    readonly improvementAreas: FieldRef<"InternalCampaignReport", 'String'>
    readonly graphsReference: FieldRef<"InternalCampaignReport", 'String'>
    readonly createdAt: FieldRef<"InternalCampaignReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InternalCampaignReport findUnique
   */
  export type InternalCampaignReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    /**
     * Filter, which InternalCampaignReport to fetch.
     */
    where: InternalCampaignReportWhereUniqueInput
  }

  /**
   * InternalCampaignReport findUniqueOrThrow
   */
  export type InternalCampaignReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    /**
     * Filter, which InternalCampaignReport to fetch.
     */
    where: InternalCampaignReportWhereUniqueInput
  }

  /**
   * InternalCampaignReport findFirst
   */
  export type InternalCampaignReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    /**
     * Filter, which InternalCampaignReport to fetch.
     */
    where?: InternalCampaignReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalCampaignReports to fetch.
     */
    orderBy?: InternalCampaignReportOrderByWithRelationInput | InternalCampaignReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternalCampaignReports.
     */
    cursor?: InternalCampaignReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalCampaignReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalCampaignReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternalCampaignReports.
     */
    distinct?: InternalCampaignReportScalarFieldEnum | InternalCampaignReportScalarFieldEnum[]
  }

  /**
   * InternalCampaignReport findFirstOrThrow
   */
  export type InternalCampaignReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    /**
     * Filter, which InternalCampaignReport to fetch.
     */
    where?: InternalCampaignReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalCampaignReports to fetch.
     */
    orderBy?: InternalCampaignReportOrderByWithRelationInput | InternalCampaignReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternalCampaignReports.
     */
    cursor?: InternalCampaignReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalCampaignReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalCampaignReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternalCampaignReports.
     */
    distinct?: InternalCampaignReportScalarFieldEnum | InternalCampaignReportScalarFieldEnum[]
  }

  /**
   * InternalCampaignReport findMany
   */
  export type InternalCampaignReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    /**
     * Filter, which InternalCampaignReports to fetch.
     */
    where?: InternalCampaignReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalCampaignReports to fetch.
     */
    orderBy?: InternalCampaignReportOrderByWithRelationInput | InternalCampaignReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InternalCampaignReports.
     */
    cursor?: InternalCampaignReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalCampaignReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalCampaignReports.
     */
    skip?: number
    distinct?: InternalCampaignReportScalarFieldEnum | InternalCampaignReportScalarFieldEnum[]
  }

  /**
   * InternalCampaignReport create
   */
  export type InternalCampaignReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    /**
     * The data needed to create a InternalCampaignReport.
     */
    data: XOR<InternalCampaignReportCreateInput, InternalCampaignReportUncheckedCreateInput>
  }

  /**
   * InternalCampaignReport createMany
   */
  export type InternalCampaignReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InternalCampaignReports.
     */
    data: InternalCampaignReportCreateManyInput | InternalCampaignReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InternalCampaignReport createManyAndReturn
   */
  export type InternalCampaignReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InternalCampaignReports.
     */
    data: InternalCampaignReportCreateManyInput | InternalCampaignReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InternalCampaignReport update
   */
  export type InternalCampaignReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    /**
     * The data needed to update a InternalCampaignReport.
     */
    data: XOR<InternalCampaignReportUpdateInput, InternalCampaignReportUncheckedUpdateInput>
    /**
     * Choose, which InternalCampaignReport to update.
     */
    where: InternalCampaignReportWhereUniqueInput
  }

  /**
   * InternalCampaignReport updateMany
   */
  export type InternalCampaignReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InternalCampaignReports.
     */
    data: XOR<InternalCampaignReportUpdateManyMutationInput, InternalCampaignReportUncheckedUpdateManyInput>
    /**
     * Filter which InternalCampaignReports to update
     */
    where?: InternalCampaignReportWhereInput
  }

  /**
   * InternalCampaignReport upsert
   */
  export type InternalCampaignReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    /**
     * The filter to search for the InternalCampaignReport to update in case it exists.
     */
    where: InternalCampaignReportWhereUniqueInput
    /**
     * In case the InternalCampaignReport found by the `where` argument doesn't exist, create a new InternalCampaignReport with this data.
     */
    create: XOR<InternalCampaignReportCreateInput, InternalCampaignReportUncheckedCreateInput>
    /**
     * In case the InternalCampaignReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InternalCampaignReportUpdateInput, InternalCampaignReportUncheckedUpdateInput>
  }

  /**
   * InternalCampaignReport delete
   */
  export type InternalCampaignReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
    /**
     * Filter which InternalCampaignReport to delete.
     */
    where: InternalCampaignReportWhereUniqueInput
  }

  /**
   * InternalCampaignReport deleteMany
   */
  export type InternalCampaignReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternalCampaignReports to delete
     */
    where?: InternalCampaignReportWhereInput
  }

  /**
   * InternalCampaignReport without action
   */
  export type InternalCampaignReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCampaignReport
     */
    select?: InternalCampaignReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalCampaignReportInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompetitorStrategyScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    competitor: 'competitor',
    promotionType: 'promotionType',
    channels: 'channels',
    strength: 'strength',
    weakness: 'weakness',
    createdAt: 'createdAt'
  };

  export type CompetitorStrategyScalarFieldEnum = (typeof CompetitorStrategyScalarFieldEnum)[keyof typeof CompetitorStrategyScalarFieldEnum]


  export const EnterpriseContextScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    companyName: 'companyName',
    domain: 'domain',
    businessModel: 'businessModel',
    background: 'background',
    currentPain: 'currentPain',
    goals: 'goals',
    createdAt: 'createdAt'
  };

  export type EnterpriseContextScalarFieldEnum = (typeof EnterpriseContextScalarFieldEnum)[keyof typeof EnterpriseContextScalarFieldEnum]


  export const AudienceSegmentScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    label: 'label',
    demographics: 'demographics',
    behavior: 'behavior',
    painPoints: 'painPoints',
    createdAt: 'createdAt'
  };

  export type AudienceSegmentScalarFieldEnum = (typeof AudienceSegmentScalarFieldEnum)[keyof typeof AudienceSegmentScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignObjectiveScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    goal: 'goal'
  };

  export type CampaignObjectiveScalarFieldEnum = (typeof CampaignObjectiveScalarFieldEnum)[keyof typeof CampaignObjectiveScalarFieldEnum]


  export const TargetAudienceSegmentScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    segment: 'segment'
  };

  export type TargetAudienceSegmentScalarFieldEnum = (typeof TargetAudienceSegmentScalarFieldEnum)[keyof typeof TargetAudienceSegmentScalarFieldEnum]


  export const PromotionTypeScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    type: 'type'
  };

  export type PromotionTypeScalarFieldEnum = (typeof PromotionTypeScalarFieldEnum)[keyof typeof PromotionTypeScalarFieldEnum]


  export const CampaignOfferScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    description: 'description',
    offerLimit: 'offerLimit',
    offerType: 'offerType',
    successCriteria: 'successCriteria',
    backupOffer: 'backupOffer',
    createdAt: 'createdAt'
  };

  export type CampaignOfferScalarFieldEnum = (typeof CampaignOfferScalarFieldEnum)[keyof typeof CampaignOfferScalarFieldEnum]


  export const CampaignBudgetScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    mediaSpend: 'mediaSpend',
    creativeSpend: 'creativeSpend',
    incentiveSpend: 'incentiveSpend',
    logisticsSpend: 'logisticsSpend',
    totalBudget: 'totalBudget',
    costPerCustomer: 'costPerCustomer',
    expectedROI: 'expectedROI',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type CampaignBudgetScalarFieldEnum = (typeof CampaignBudgetScalarFieldEnum)[keyof typeof CampaignBudgetScalarFieldEnum]


  export const ChannelPlanScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    channels: 'channels',
    primary: 'primary',
    primaryReason: 'primaryReason',
    messageStyles: 'messageStyles',
    createdAt: 'createdAt'
  };

  export type ChannelPlanScalarFieldEnum = (typeof ChannelPlanScalarFieldEnum)[keyof typeof ChannelPlanScalarFieldEnum]


  export const CampaignTimelineScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    milestoneName: 'milestoneName',
    milestoneType: 'milestoneType',
    plannedDate: 'plannedDate',
    createdAt: 'createdAt'
  };

  export type CampaignTimelineScalarFieldEnum = (typeof CampaignTimelineScalarFieldEnum)[keyof typeof CampaignTimelineScalarFieldEnum]


  export const ComplianceChecklistScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    item: 'item',
    severity: 'severity',
    responsibleDepartment: 'responsibleDepartment',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ComplianceChecklistScalarFieldEnum = (typeof ComplianceChecklistScalarFieldEnum)[keyof typeof ComplianceChecklistScalarFieldEnum]


  export const PromotionalMessageScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    platform: 'platform',
    tone: 'tone',
    message: 'message',
    callToAction: 'callToAction',
    createdAt: 'createdAt'
  };

  export type PromotionalMessageScalarFieldEnum = (typeof PromotionalMessageScalarFieldEnum)[keyof typeof PromotionalMessageScalarFieldEnum]


  export const CreativeDesignPlanScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    platform: 'platform',
    creativeTitle: 'creativeTitle',
    headline: 'headline',
    visualTheme: 'visualTheme',
    cta: 'cta',
    mobileOptimizationTip: 'mobileOptimizationTip',
    createdAt: 'createdAt'
  };

  export type CreativeDesignPlanScalarFieldEnum = (typeof CreativeDesignPlanScalarFieldEnum)[keyof typeof CreativeDesignPlanScalarFieldEnum]


  export const CreativeAssetScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    type: 'type',
    assetUrl: 'assetUrl',
    createdAt: 'createdAt'
  };

  export type CreativeAssetScalarFieldEnum = (typeof CreativeAssetScalarFieldEnum)[keyof typeof CreativeAssetScalarFieldEnum]


  export const MediaAssetScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    type: 'type',
    title: 'title',
    concept: 'concept',
    engagementTip: 'engagementTip',
    mobileOptimizationTip: 'mobileOptimizationTip',
    url: 'url',
    createdAt: 'createdAt'
  };

  export type MediaAssetScalarFieldEnum = (typeof MediaAssetScalarFieldEnum)[keyof typeof MediaAssetScalarFieldEnum]


  export const ContentCalendarScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    contentType: 'contentType',
    platform: 'platform',
    contentRef: 'contentRef',
    scheduledFor: 'scheduledFor',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ContentCalendarScalarFieldEnum = (typeof ContentCalendarScalarFieldEnum)[keyof typeof ContentCalendarScalarFieldEnum]


  export const TeaserContentScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    message: 'message',
    platform: 'platform',
    teaserTheme: 'teaserTheme',
    tone: 'tone',
    scheduledAt: 'scheduledAt',
    createdAt: 'createdAt'
  };

  export type TeaserContentScalarFieldEnum = (typeof TeaserContentScalarFieldEnum)[keyof typeof TeaserContentScalarFieldEnum]


  export const CustomerSegmentListScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    segment: 'segment',
    criteria: 'criteria',
    count: 'count',
    createdAt: 'createdAt'
  };

  export type CustomerSegmentListScalarFieldEnum = (typeof CustomerSegmentListScalarFieldEnum)[keyof typeof CustomerSegmentListScalarFieldEnum]


  export const InfluencerPlanScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    influencerName: 'influencerName',
    platform: 'platform',
    postType: 'postType',
    expectedImpact: 'expectedImpact',
    scheduledAt: 'scheduledAt',
    createdAt: 'createdAt'
  };

  export type InfluencerPlanScalarFieldEnum = (typeof InfluencerPlanScalarFieldEnum)[keyof typeof InfluencerPlanScalarFieldEnum]


  export const OperationalChecklistScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    system: 'system',
    checklistItem: 'checklistItem',
    expectedOutcome: 'expectedOutcome',
    responsibility: 'responsibility',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type OperationalChecklistScalarFieldEnum = (typeof OperationalChecklistScalarFieldEnum)[keyof typeof OperationalChecklistScalarFieldEnum]


  export const CampaignActivationScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    platform: 'platform',
    assetType: 'assetType',
    assetReference: 'assetReference',
    activationTime: 'activationTime',
    status: 'status',
    activationResult: 'activationResult',
    createdAt: 'createdAt'
  };

  export type CampaignActivationScalarFieldEnum = (typeof CampaignActivationScalarFieldEnum)[keyof typeof CampaignActivationScalarFieldEnum]


  export const CustomerEngagementLogScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    userId: 'userId',
    sessionId: 'sessionId',
    interactionType: 'interactionType',
    message: 'message',
    resolutionStatus: 'resolutionStatus',
    responseTime: 'responseTime',
    csatScore: 'csatScore',
    createdAt: 'createdAt'
  };

  export type CustomerEngagementLogScalarFieldEnum = (typeof CustomerEngagementLogScalarFieldEnum)[keyof typeof CustomerEngagementLogScalarFieldEnum]


  export const PerformanceReportScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    date: 'date',
    impressions: 'impressions',
    clicks: 'clicks',
    qrScans: 'qrScans',
    conversions: 'conversions',
    chatbotSessions: 'chatbotSessions',
    escalations: 'escalations',
    escalationRate: 'escalationRate',
    avgBotResponseTime: 'avgBotResponseTime',
    avgHumanResponseTime: 'avgHumanResponseTime',
    csatScoreAverage: 'csatScoreAverage',
    anomalies: 'anomalies',
    createdAt: 'createdAt'
  };

  export type PerformanceReportScalarFieldEnum = (typeof PerformanceReportScalarFieldEnum)[keyof typeof PerformanceReportScalarFieldEnum]


  export const CustomerFeedbackScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    userId: 'userId',
    interactionId: 'interactionId',
    feedbackText: 'feedbackText',
    rating: 'rating',
    collectedVia: 'collectedVia',
    createdAt: 'createdAt'
  };

  export type CustomerFeedbackScalarFieldEnum = (typeof CustomerFeedbackScalarFieldEnum)[keyof typeof CustomerFeedbackScalarFieldEnum]


  export const ThankYouMessageScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    userId: 'userId',
    messageBody: 'messageBody',
    sentVia: 'sentVia',
    segment: 'segment',
    sentAt: 'sentAt'
  };

  export type ThankYouMessageScalarFieldEnum = (typeof ThankYouMessageScalarFieldEnum)[keyof typeof ThankYouMessageScalarFieldEnum]


  export const RetargetingPlanScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    audienceSegment: 'audienceSegment',
    retargetingChannel: 'retargetingChannel',
    offerMessage: 'offerMessage',
    scheduledAt: 'scheduledAt',
    createdAt: 'createdAt'
  };

  export type RetargetingPlanScalarFieldEnum = (typeof RetargetingPlanScalarFieldEnum)[keyof typeof RetargetingPlanScalarFieldEnum]


  export const CampaignExtensionPlanScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    reason: 'reason',
    extendedTo: 'extendedTo',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type CampaignExtensionPlanScalarFieldEnum = (typeof CampaignExtensionPlanScalarFieldEnum)[keyof typeof CampaignExtensionPlanScalarFieldEnum]


  export const CampaignAnalysisReportScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    totalImpressions: 'totalImpressions',
    totalClicks: 'totalClicks',
    totalQrScans: 'totalQrScans',
    totalConversions: 'totalConversions',
    conversionRate: 'conversionRate',
    revenueGenerated: 'revenueGenerated',
    campaignSpend: 'campaignSpend',
    roi: 'roi',
    engagementRate: 'engagementRate',
    csatAverage: 'csatAverage',
    escalationRate: 'escalationRate',
    learningsSummary: 'learningsSummary',
    createdAt: 'createdAt'
  };

  export type CampaignAnalysisReportScalarFieldEnum = (typeof CampaignAnalysisReportScalarFieldEnum)[keyof typeof CampaignAnalysisReportScalarFieldEnum]


  export const CampaignLearningsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    whatWorked: 'whatWorked',
    whatDidNotWork: 'whatDidNotWork',
    bestPractices: 'bestPractices',
    improvementAreas: 'improvementAreas',
    createdAt: 'createdAt'
  };

  export type CampaignLearningsScalarFieldEnum = (typeof CampaignLearningsScalarFieldEnum)[keyof typeof CampaignLearningsScalarFieldEnum]


  export const InternalCampaignReportScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    reportTitle: 'reportTitle',
    executiveSummary: 'executiveSummary',
    kpiHighlights: 'kpiHighlights',
    learningHighlights: 'learningHighlights',
    improvementAreas: 'improvementAreas',
    graphsReference: 'graphsReference',
    createdAt: 'createdAt'
  };

  export type InternalCampaignReportScalarFieldEnum = (typeof InternalCampaignReportScalarFieldEnum)[keyof typeof InternalCampaignReportScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CompetitorStrategyWhereInput = {
    AND?: CompetitorStrategyWhereInput | CompetitorStrategyWhereInput[]
    OR?: CompetitorStrategyWhereInput[]
    NOT?: CompetitorStrategyWhereInput | CompetitorStrategyWhereInput[]
    id?: StringFilter<"CompetitorStrategy"> | string
    campaignId?: StringFilter<"CompetitorStrategy"> | string
    competitor?: StringFilter<"CompetitorStrategy"> | string
    promotionType?: StringFilter<"CompetitorStrategy"> | string
    channels?: StringFilter<"CompetitorStrategy"> | string
    strength?: StringFilter<"CompetitorStrategy"> | string
    weakness?: StringFilter<"CompetitorStrategy"> | string
    createdAt?: DateTimeFilter<"CompetitorStrategy"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CompetitorStrategyOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    competitor?: SortOrder
    promotionType?: SortOrder
    channels?: SortOrder
    strength?: SortOrder
    weakness?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CompetitorStrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompetitorStrategyWhereInput | CompetitorStrategyWhereInput[]
    OR?: CompetitorStrategyWhereInput[]
    NOT?: CompetitorStrategyWhereInput | CompetitorStrategyWhereInput[]
    campaignId?: StringFilter<"CompetitorStrategy"> | string
    competitor?: StringFilter<"CompetitorStrategy"> | string
    promotionType?: StringFilter<"CompetitorStrategy"> | string
    channels?: StringFilter<"CompetitorStrategy"> | string
    strength?: StringFilter<"CompetitorStrategy"> | string
    weakness?: StringFilter<"CompetitorStrategy"> | string
    createdAt?: DateTimeFilter<"CompetitorStrategy"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CompetitorStrategyOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    competitor?: SortOrder
    promotionType?: SortOrder
    channels?: SortOrder
    strength?: SortOrder
    weakness?: SortOrder
    createdAt?: SortOrder
    _count?: CompetitorStrategyCountOrderByAggregateInput
    _max?: CompetitorStrategyMaxOrderByAggregateInput
    _min?: CompetitorStrategyMinOrderByAggregateInput
  }

  export type CompetitorStrategyScalarWhereWithAggregatesInput = {
    AND?: CompetitorStrategyScalarWhereWithAggregatesInput | CompetitorStrategyScalarWhereWithAggregatesInput[]
    OR?: CompetitorStrategyScalarWhereWithAggregatesInput[]
    NOT?: CompetitorStrategyScalarWhereWithAggregatesInput | CompetitorStrategyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompetitorStrategy"> | string
    campaignId?: StringWithAggregatesFilter<"CompetitorStrategy"> | string
    competitor?: StringWithAggregatesFilter<"CompetitorStrategy"> | string
    promotionType?: StringWithAggregatesFilter<"CompetitorStrategy"> | string
    channels?: StringWithAggregatesFilter<"CompetitorStrategy"> | string
    strength?: StringWithAggregatesFilter<"CompetitorStrategy"> | string
    weakness?: StringWithAggregatesFilter<"CompetitorStrategy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompetitorStrategy"> | Date | string
  }

  export type EnterpriseContextWhereInput = {
    AND?: EnterpriseContextWhereInput | EnterpriseContextWhereInput[]
    OR?: EnterpriseContextWhereInput[]
    NOT?: EnterpriseContextWhereInput | EnterpriseContextWhereInput[]
    id?: StringFilter<"EnterpriseContext"> | string
    campaignId?: StringFilter<"EnterpriseContext"> | string
    companyName?: StringFilter<"EnterpriseContext"> | string
    domain?: StringFilter<"EnterpriseContext"> | string
    businessModel?: StringFilter<"EnterpriseContext"> | string
    background?: StringFilter<"EnterpriseContext"> | string
    currentPain?: StringFilter<"EnterpriseContext"> | string
    goals?: StringFilter<"EnterpriseContext"> | string
    createdAt?: DateTimeFilter<"EnterpriseContext"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type EnterpriseContextOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    companyName?: SortOrder
    domain?: SortOrder
    businessModel?: SortOrder
    background?: SortOrder
    currentPain?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type EnterpriseContextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EnterpriseContextWhereInput | EnterpriseContextWhereInput[]
    OR?: EnterpriseContextWhereInput[]
    NOT?: EnterpriseContextWhereInput | EnterpriseContextWhereInput[]
    campaignId?: StringFilter<"EnterpriseContext"> | string
    companyName?: StringFilter<"EnterpriseContext"> | string
    domain?: StringFilter<"EnterpriseContext"> | string
    businessModel?: StringFilter<"EnterpriseContext"> | string
    background?: StringFilter<"EnterpriseContext"> | string
    currentPain?: StringFilter<"EnterpriseContext"> | string
    goals?: StringFilter<"EnterpriseContext"> | string
    createdAt?: DateTimeFilter<"EnterpriseContext"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type EnterpriseContextOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    companyName?: SortOrder
    domain?: SortOrder
    businessModel?: SortOrder
    background?: SortOrder
    currentPain?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
    _count?: EnterpriseContextCountOrderByAggregateInput
    _max?: EnterpriseContextMaxOrderByAggregateInput
    _min?: EnterpriseContextMinOrderByAggregateInput
  }

  export type EnterpriseContextScalarWhereWithAggregatesInput = {
    AND?: EnterpriseContextScalarWhereWithAggregatesInput | EnterpriseContextScalarWhereWithAggregatesInput[]
    OR?: EnterpriseContextScalarWhereWithAggregatesInput[]
    NOT?: EnterpriseContextScalarWhereWithAggregatesInput | EnterpriseContextScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EnterpriseContext"> | string
    campaignId?: StringWithAggregatesFilter<"EnterpriseContext"> | string
    companyName?: StringWithAggregatesFilter<"EnterpriseContext"> | string
    domain?: StringWithAggregatesFilter<"EnterpriseContext"> | string
    businessModel?: StringWithAggregatesFilter<"EnterpriseContext"> | string
    background?: StringWithAggregatesFilter<"EnterpriseContext"> | string
    currentPain?: StringWithAggregatesFilter<"EnterpriseContext"> | string
    goals?: StringWithAggregatesFilter<"EnterpriseContext"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EnterpriseContext"> | Date | string
  }

  export type AudienceSegmentWhereInput = {
    AND?: AudienceSegmentWhereInput | AudienceSegmentWhereInput[]
    OR?: AudienceSegmentWhereInput[]
    NOT?: AudienceSegmentWhereInput | AudienceSegmentWhereInput[]
    id?: StringFilter<"AudienceSegment"> | string
    campaignId?: StringFilter<"AudienceSegment"> | string
    label?: StringFilter<"AudienceSegment"> | string
    demographics?: StringFilter<"AudienceSegment"> | string
    behavior?: StringFilter<"AudienceSegment"> | string
    painPoints?: StringFilter<"AudienceSegment"> | string
    createdAt?: DateTimeFilter<"AudienceSegment"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type AudienceSegmentOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    label?: SortOrder
    demographics?: SortOrder
    behavior?: SortOrder
    painPoints?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type AudienceSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudienceSegmentWhereInput | AudienceSegmentWhereInput[]
    OR?: AudienceSegmentWhereInput[]
    NOT?: AudienceSegmentWhereInput | AudienceSegmentWhereInput[]
    campaignId?: StringFilter<"AudienceSegment"> | string
    label?: StringFilter<"AudienceSegment"> | string
    demographics?: StringFilter<"AudienceSegment"> | string
    behavior?: StringFilter<"AudienceSegment"> | string
    painPoints?: StringFilter<"AudienceSegment"> | string
    createdAt?: DateTimeFilter<"AudienceSegment"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type AudienceSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    label?: SortOrder
    demographics?: SortOrder
    behavior?: SortOrder
    painPoints?: SortOrder
    createdAt?: SortOrder
    _count?: AudienceSegmentCountOrderByAggregateInput
    _max?: AudienceSegmentMaxOrderByAggregateInput
    _min?: AudienceSegmentMinOrderByAggregateInput
  }

  export type AudienceSegmentScalarWhereWithAggregatesInput = {
    AND?: AudienceSegmentScalarWhereWithAggregatesInput | AudienceSegmentScalarWhereWithAggregatesInput[]
    OR?: AudienceSegmentScalarWhereWithAggregatesInput[]
    NOT?: AudienceSegmentScalarWhereWithAggregatesInput | AudienceSegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudienceSegment"> | string
    campaignId?: StringWithAggregatesFilter<"AudienceSegment"> | string
    label?: StringWithAggregatesFilter<"AudienceSegment"> | string
    demographics?: StringWithAggregatesFilter<"AudienceSegment"> | string
    behavior?: StringWithAggregatesFilter<"AudienceSegment"> | string
    painPoints?: StringWithAggregatesFilter<"AudienceSegment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AudienceSegment"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    startDate?: DateTimeFilter<"Campaign"> | Date | string
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    enterpriseContexts?: EnterpriseContextListRelationFilter
    audienceSegments?: AudienceSegmentListRelationFilter
    creativePlans?: CreativeDesignPlanListRelationFilter
    objectives?: CampaignObjectiveListRelationFilter
    audiences?: TargetAudienceSegmentListRelationFilter
    competitors?: CompetitorStrategyListRelationFilter
    promotions?: PromotionTypeListRelationFilter
    offers?: CampaignOfferListRelationFilter
    budgets?: CampaignBudgetListRelationFilter
    channels?: ChannelPlanListRelationFilter
    timelines?: CampaignTimelineListRelationFilter
    compliances?: ComplianceChecklistListRelationFilter
    creatives?: CreativeAssetListRelationFilter
    messages?: PromotionalMessageListRelationFilter
    mediaAssets?: MediaAssetListRelationFilter
    calendars?: ContentCalendarListRelationFilter
    teasers?: TeaserContentListRelationFilter
    customers?: CustomerSegmentListListRelationFilter
    influencers?: InfluencerPlanListRelationFilter
    checklists?: OperationalChecklistListRelationFilter
    activations?: CampaignActivationListRelationFilter
    engagements?: CustomerEngagementLogListRelationFilter
    reports?: PerformanceReportListRelationFilter
    feedbacks?: CustomerFeedbackListRelationFilter
    thanks?: ThankYouMessageListRelationFilter
    retargetings?: RetargetingPlanListRelationFilter
    extensions?: CampaignExtensionPlanListRelationFilter
    analysisReports?: CampaignAnalysisReportListRelationFilter
    learnings?: CampaignLearningsListRelationFilter
    internalReports?: InternalCampaignReportListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enterpriseContexts?: EnterpriseContextOrderByRelationAggregateInput
    audienceSegments?: AudienceSegmentOrderByRelationAggregateInput
    creativePlans?: CreativeDesignPlanOrderByRelationAggregateInput
    objectives?: CampaignObjectiveOrderByRelationAggregateInput
    audiences?: TargetAudienceSegmentOrderByRelationAggregateInput
    competitors?: CompetitorStrategyOrderByRelationAggregateInput
    promotions?: PromotionTypeOrderByRelationAggregateInput
    offers?: CampaignOfferOrderByRelationAggregateInput
    budgets?: CampaignBudgetOrderByRelationAggregateInput
    channels?: ChannelPlanOrderByRelationAggregateInput
    timelines?: CampaignTimelineOrderByRelationAggregateInput
    compliances?: ComplianceChecklistOrderByRelationAggregateInput
    creatives?: CreativeAssetOrderByRelationAggregateInput
    messages?: PromotionalMessageOrderByRelationAggregateInput
    mediaAssets?: MediaAssetOrderByRelationAggregateInput
    calendars?: ContentCalendarOrderByRelationAggregateInput
    teasers?: TeaserContentOrderByRelationAggregateInput
    customers?: CustomerSegmentListOrderByRelationAggregateInput
    influencers?: InfluencerPlanOrderByRelationAggregateInput
    checklists?: OperationalChecklistOrderByRelationAggregateInput
    activations?: CampaignActivationOrderByRelationAggregateInput
    engagements?: CustomerEngagementLogOrderByRelationAggregateInput
    reports?: PerformanceReportOrderByRelationAggregateInput
    feedbacks?: CustomerFeedbackOrderByRelationAggregateInput
    thanks?: ThankYouMessageOrderByRelationAggregateInput
    retargetings?: RetargetingPlanOrderByRelationAggregateInput
    extensions?: CampaignExtensionPlanOrderByRelationAggregateInput
    analysisReports?: CampaignAnalysisReportOrderByRelationAggregateInput
    learnings?: CampaignLearningsOrderByRelationAggregateInput
    internalReports?: InternalCampaignReportOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    startDate?: DateTimeFilter<"Campaign"> | Date | string
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    enterpriseContexts?: EnterpriseContextListRelationFilter
    audienceSegments?: AudienceSegmentListRelationFilter
    creativePlans?: CreativeDesignPlanListRelationFilter
    objectives?: CampaignObjectiveListRelationFilter
    audiences?: TargetAudienceSegmentListRelationFilter
    competitors?: CompetitorStrategyListRelationFilter
    promotions?: PromotionTypeListRelationFilter
    offers?: CampaignOfferListRelationFilter
    budgets?: CampaignBudgetListRelationFilter
    channels?: ChannelPlanListRelationFilter
    timelines?: CampaignTimelineListRelationFilter
    compliances?: ComplianceChecklistListRelationFilter
    creatives?: CreativeAssetListRelationFilter
    messages?: PromotionalMessageListRelationFilter
    mediaAssets?: MediaAssetListRelationFilter
    calendars?: ContentCalendarListRelationFilter
    teasers?: TeaserContentListRelationFilter
    customers?: CustomerSegmentListListRelationFilter
    influencers?: InfluencerPlanListRelationFilter
    checklists?: OperationalChecklistListRelationFilter
    activations?: CampaignActivationListRelationFilter
    engagements?: CustomerEngagementLogListRelationFilter
    reports?: PerformanceReportListRelationFilter
    feedbacks?: CustomerFeedbackListRelationFilter
    thanks?: ThankYouMessageListRelationFilter
    retargetings?: RetargetingPlanListRelationFilter
    extensions?: CampaignExtensionPlanListRelationFilter
    analysisReports?: CampaignAnalysisReportListRelationFilter
    learnings?: CampaignLearningsListRelationFilter
    internalReports?: InternalCampaignReportListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type CampaignObjectiveWhereInput = {
    AND?: CampaignObjectiveWhereInput | CampaignObjectiveWhereInput[]
    OR?: CampaignObjectiveWhereInput[]
    NOT?: CampaignObjectiveWhereInput | CampaignObjectiveWhereInput[]
    id?: StringFilter<"CampaignObjective"> | string
    campaignId?: StringFilter<"CampaignObjective"> | string
    goal?: StringFilter<"CampaignObjective"> | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    goal?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignObjectiveWhereInput | CampaignObjectiveWhereInput[]
    OR?: CampaignObjectiveWhereInput[]
    NOT?: CampaignObjectiveWhereInput | CampaignObjectiveWhereInput[]
    campaignId?: StringFilter<"CampaignObjective"> | string
    goal?: StringFilter<"CampaignObjective"> | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    goal?: SortOrder
    _count?: CampaignObjectiveCountOrderByAggregateInput
    _max?: CampaignObjectiveMaxOrderByAggregateInput
    _min?: CampaignObjectiveMinOrderByAggregateInput
  }

  export type CampaignObjectiveScalarWhereWithAggregatesInput = {
    AND?: CampaignObjectiveScalarWhereWithAggregatesInput | CampaignObjectiveScalarWhereWithAggregatesInput[]
    OR?: CampaignObjectiveScalarWhereWithAggregatesInput[]
    NOT?: CampaignObjectiveScalarWhereWithAggregatesInput | CampaignObjectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignObjective"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignObjective"> | string
    goal?: StringWithAggregatesFilter<"CampaignObjective"> | string
  }

  export type TargetAudienceSegmentWhereInput = {
    AND?: TargetAudienceSegmentWhereInput | TargetAudienceSegmentWhereInput[]
    OR?: TargetAudienceSegmentWhereInput[]
    NOT?: TargetAudienceSegmentWhereInput | TargetAudienceSegmentWhereInput[]
    id?: StringFilter<"TargetAudienceSegment"> | string
    campaignId?: StringFilter<"TargetAudienceSegment"> | string
    segment?: StringFilter<"TargetAudienceSegment"> | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type TargetAudienceSegmentOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type TargetAudienceSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TargetAudienceSegmentWhereInput | TargetAudienceSegmentWhereInput[]
    OR?: TargetAudienceSegmentWhereInput[]
    NOT?: TargetAudienceSegmentWhereInput | TargetAudienceSegmentWhereInput[]
    campaignId?: StringFilter<"TargetAudienceSegment"> | string
    segment?: StringFilter<"TargetAudienceSegment"> | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type TargetAudienceSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
    _count?: TargetAudienceSegmentCountOrderByAggregateInput
    _max?: TargetAudienceSegmentMaxOrderByAggregateInput
    _min?: TargetAudienceSegmentMinOrderByAggregateInput
  }

  export type TargetAudienceSegmentScalarWhereWithAggregatesInput = {
    AND?: TargetAudienceSegmentScalarWhereWithAggregatesInput | TargetAudienceSegmentScalarWhereWithAggregatesInput[]
    OR?: TargetAudienceSegmentScalarWhereWithAggregatesInput[]
    NOT?: TargetAudienceSegmentScalarWhereWithAggregatesInput | TargetAudienceSegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TargetAudienceSegment"> | string
    campaignId?: StringWithAggregatesFilter<"TargetAudienceSegment"> | string
    segment?: StringWithAggregatesFilter<"TargetAudienceSegment"> | string
  }

  export type PromotionTypeWhereInput = {
    AND?: PromotionTypeWhereInput | PromotionTypeWhereInput[]
    OR?: PromotionTypeWhereInput[]
    NOT?: PromotionTypeWhereInput | PromotionTypeWhereInput[]
    id?: StringFilter<"PromotionType"> | string
    campaignId?: StringFilter<"PromotionType"> | string
    type?: StringFilter<"PromotionType"> | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type PromotionTypeOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type PromotionTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionTypeWhereInput | PromotionTypeWhereInput[]
    OR?: PromotionTypeWhereInput[]
    NOT?: PromotionTypeWhereInput | PromotionTypeWhereInput[]
    campaignId?: StringFilter<"PromotionType"> | string
    type?: StringFilter<"PromotionType"> | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type PromotionTypeOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    _count?: PromotionTypeCountOrderByAggregateInput
    _max?: PromotionTypeMaxOrderByAggregateInput
    _min?: PromotionTypeMinOrderByAggregateInput
  }

  export type PromotionTypeScalarWhereWithAggregatesInput = {
    AND?: PromotionTypeScalarWhereWithAggregatesInput | PromotionTypeScalarWhereWithAggregatesInput[]
    OR?: PromotionTypeScalarWhereWithAggregatesInput[]
    NOT?: PromotionTypeScalarWhereWithAggregatesInput | PromotionTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromotionType"> | string
    campaignId?: StringWithAggregatesFilter<"PromotionType"> | string
    type?: StringWithAggregatesFilter<"PromotionType"> | string
  }

  export type CampaignOfferWhereInput = {
    AND?: CampaignOfferWhereInput | CampaignOfferWhereInput[]
    OR?: CampaignOfferWhereInput[]
    NOT?: CampaignOfferWhereInput | CampaignOfferWhereInput[]
    id?: StringFilter<"CampaignOffer"> | string
    campaignId?: StringFilter<"CampaignOffer"> | string
    description?: StringFilter<"CampaignOffer"> | string
    offerLimit?: IntNullableFilter<"CampaignOffer"> | number | null
    offerType?: StringNullableFilter<"CampaignOffer"> | string | null
    successCriteria?: StringNullableFilter<"CampaignOffer"> | string | null
    backupOffer?: StringNullableFilter<"CampaignOffer"> | string | null
    createdAt?: DateTimeFilter<"CampaignOffer"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignOfferOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    description?: SortOrder
    offerLimit?: SortOrderInput | SortOrder
    offerType?: SortOrderInput | SortOrder
    successCriteria?: SortOrderInput | SortOrder
    backupOffer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignOfferWhereInput | CampaignOfferWhereInput[]
    OR?: CampaignOfferWhereInput[]
    NOT?: CampaignOfferWhereInput | CampaignOfferWhereInput[]
    campaignId?: StringFilter<"CampaignOffer"> | string
    description?: StringFilter<"CampaignOffer"> | string
    offerLimit?: IntNullableFilter<"CampaignOffer"> | number | null
    offerType?: StringNullableFilter<"CampaignOffer"> | string | null
    successCriteria?: StringNullableFilter<"CampaignOffer"> | string | null
    backupOffer?: StringNullableFilter<"CampaignOffer"> | string | null
    createdAt?: DateTimeFilter<"CampaignOffer"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignOfferOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    description?: SortOrder
    offerLimit?: SortOrderInput | SortOrder
    offerType?: SortOrderInput | SortOrder
    successCriteria?: SortOrderInput | SortOrder
    backupOffer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignOfferCountOrderByAggregateInput
    _avg?: CampaignOfferAvgOrderByAggregateInput
    _max?: CampaignOfferMaxOrderByAggregateInput
    _min?: CampaignOfferMinOrderByAggregateInput
    _sum?: CampaignOfferSumOrderByAggregateInput
  }

  export type CampaignOfferScalarWhereWithAggregatesInput = {
    AND?: CampaignOfferScalarWhereWithAggregatesInput | CampaignOfferScalarWhereWithAggregatesInput[]
    OR?: CampaignOfferScalarWhereWithAggregatesInput[]
    NOT?: CampaignOfferScalarWhereWithAggregatesInput | CampaignOfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignOffer"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignOffer"> | string
    description?: StringWithAggregatesFilter<"CampaignOffer"> | string
    offerLimit?: IntNullableWithAggregatesFilter<"CampaignOffer"> | number | null
    offerType?: StringNullableWithAggregatesFilter<"CampaignOffer"> | string | null
    successCriteria?: StringNullableWithAggregatesFilter<"CampaignOffer"> | string | null
    backupOffer?: StringNullableWithAggregatesFilter<"CampaignOffer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignOffer"> | Date | string
  }

  export type CampaignBudgetWhereInput = {
    AND?: CampaignBudgetWhereInput | CampaignBudgetWhereInput[]
    OR?: CampaignBudgetWhereInput[]
    NOT?: CampaignBudgetWhereInput | CampaignBudgetWhereInput[]
    id?: StringFilter<"CampaignBudget"> | string
    campaignId?: StringFilter<"CampaignBudget"> | string
    mediaSpend?: FloatFilter<"CampaignBudget"> | number
    creativeSpend?: FloatFilter<"CampaignBudget"> | number
    incentiveSpend?: FloatFilter<"CampaignBudget"> | number
    logisticsSpend?: FloatFilter<"CampaignBudget"> | number
    totalBudget?: FloatFilter<"CampaignBudget"> | number
    costPerCustomer?: FloatFilter<"CampaignBudget"> | number
    expectedROI?: FloatNullableFilter<"CampaignBudget"> | number | null
    notes?: StringNullableFilter<"CampaignBudget"> | string | null
    createdAt?: DateTimeFilter<"CampaignBudget"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignBudgetOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mediaSpend?: SortOrder
    creativeSpend?: SortOrder
    incentiveSpend?: SortOrder
    logisticsSpend?: SortOrder
    totalBudget?: SortOrder
    costPerCustomer?: SortOrder
    expectedROI?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignBudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignBudgetWhereInput | CampaignBudgetWhereInput[]
    OR?: CampaignBudgetWhereInput[]
    NOT?: CampaignBudgetWhereInput | CampaignBudgetWhereInput[]
    campaignId?: StringFilter<"CampaignBudget"> | string
    mediaSpend?: FloatFilter<"CampaignBudget"> | number
    creativeSpend?: FloatFilter<"CampaignBudget"> | number
    incentiveSpend?: FloatFilter<"CampaignBudget"> | number
    logisticsSpend?: FloatFilter<"CampaignBudget"> | number
    totalBudget?: FloatFilter<"CampaignBudget"> | number
    costPerCustomer?: FloatFilter<"CampaignBudget"> | number
    expectedROI?: FloatNullableFilter<"CampaignBudget"> | number | null
    notes?: StringNullableFilter<"CampaignBudget"> | string | null
    createdAt?: DateTimeFilter<"CampaignBudget"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignBudgetOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mediaSpend?: SortOrder
    creativeSpend?: SortOrder
    incentiveSpend?: SortOrder
    logisticsSpend?: SortOrder
    totalBudget?: SortOrder
    costPerCustomer?: SortOrder
    expectedROI?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignBudgetCountOrderByAggregateInput
    _avg?: CampaignBudgetAvgOrderByAggregateInput
    _max?: CampaignBudgetMaxOrderByAggregateInput
    _min?: CampaignBudgetMinOrderByAggregateInput
    _sum?: CampaignBudgetSumOrderByAggregateInput
  }

  export type CampaignBudgetScalarWhereWithAggregatesInput = {
    AND?: CampaignBudgetScalarWhereWithAggregatesInput | CampaignBudgetScalarWhereWithAggregatesInput[]
    OR?: CampaignBudgetScalarWhereWithAggregatesInput[]
    NOT?: CampaignBudgetScalarWhereWithAggregatesInput | CampaignBudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignBudget"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignBudget"> | string
    mediaSpend?: FloatWithAggregatesFilter<"CampaignBudget"> | number
    creativeSpend?: FloatWithAggregatesFilter<"CampaignBudget"> | number
    incentiveSpend?: FloatWithAggregatesFilter<"CampaignBudget"> | number
    logisticsSpend?: FloatWithAggregatesFilter<"CampaignBudget"> | number
    totalBudget?: FloatWithAggregatesFilter<"CampaignBudget"> | number
    costPerCustomer?: FloatWithAggregatesFilter<"CampaignBudget"> | number
    expectedROI?: FloatNullableWithAggregatesFilter<"CampaignBudget"> | number | null
    notes?: StringNullableWithAggregatesFilter<"CampaignBudget"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignBudget"> | Date | string
  }

  export type ChannelPlanWhereInput = {
    AND?: ChannelPlanWhereInput | ChannelPlanWhereInput[]
    OR?: ChannelPlanWhereInput[]
    NOT?: ChannelPlanWhereInput | ChannelPlanWhereInput[]
    id?: StringFilter<"ChannelPlan"> | string
    campaignId?: StringFilter<"ChannelPlan"> | string
    channels?: StringNullableListFilter<"ChannelPlan">
    primary?: StringFilter<"ChannelPlan"> | string
    primaryReason?: StringFilter<"ChannelPlan"> | string
    messageStyles?: StringNullableListFilter<"ChannelPlan">
    createdAt?: DateTimeFilter<"ChannelPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type ChannelPlanOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    channels?: SortOrder
    primary?: SortOrder
    primaryReason?: SortOrder
    messageStyles?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type ChannelPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelPlanWhereInput | ChannelPlanWhereInput[]
    OR?: ChannelPlanWhereInput[]
    NOT?: ChannelPlanWhereInput | ChannelPlanWhereInput[]
    campaignId?: StringFilter<"ChannelPlan"> | string
    channels?: StringNullableListFilter<"ChannelPlan">
    primary?: StringFilter<"ChannelPlan"> | string
    primaryReason?: StringFilter<"ChannelPlan"> | string
    messageStyles?: StringNullableListFilter<"ChannelPlan">
    createdAt?: DateTimeFilter<"ChannelPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type ChannelPlanOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    channels?: SortOrder
    primary?: SortOrder
    primaryReason?: SortOrder
    messageStyles?: SortOrder
    createdAt?: SortOrder
    _count?: ChannelPlanCountOrderByAggregateInput
    _max?: ChannelPlanMaxOrderByAggregateInput
    _min?: ChannelPlanMinOrderByAggregateInput
  }

  export type ChannelPlanScalarWhereWithAggregatesInput = {
    AND?: ChannelPlanScalarWhereWithAggregatesInput | ChannelPlanScalarWhereWithAggregatesInput[]
    OR?: ChannelPlanScalarWhereWithAggregatesInput[]
    NOT?: ChannelPlanScalarWhereWithAggregatesInput | ChannelPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelPlan"> | string
    campaignId?: StringWithAggregatesFilter<"ChannelPlan"> | string
    channels?: StringNullableListFilter<"ChannelPlan">
    primary?: StringWithAggregatesFilter<"ChannelPlan"> | string
    primaryReason?: StringWithAggregatesFilter<"ChannelPlan"> | string
    messageStyles?: StringNullableListFilter<"ChannelPlan">
    createdAt?: DateTimeWithAggregatesFilter<"ChannelPlan"> | Date | string
  }

  export type CampaignTimelineWhereInput = {
    AND?: CampaignTimelineWhereInput | CampaignTimelineWhereInput[]
    OR?: CampaignTimelineWhereInput[]
    NOT?: CampaignTimelineWhereInput | CampaignTimelineWhereInput[]
    id?: StringFilter<"CampaignTimeline"> | string
    campaignId?: StringFilter<"CampaignTimeline"> | string
    milestoneName?: StringFilter<"CampaignTimeline"> | string
    milestoneType?: StringFilter<"CampaignTimeline"> | string
    plannedDate?: DateTimeFilter<"CampaignTimeline"> | Date | string
    createdAt?: DateTimeFilter<"CampaignTimeline"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignTimelineOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    milestoneName?: SortOrder
    milestoneType?: SortOrder
    plannedDate?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignTimelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignTimelineWhereInput | CampaignTimelineWhereInput[]
    OR?: CampaignTimelineWhereInput[]
    NOT?: CampaignTimelineWhereInput | CampaignTimelineWhereInput[]
    campaignId?: StringFilter<"CampaignTimeline"> | string
    milestoneName?: StringFilter<"CampaignTimeline"> | string
    milestoneType?: StringFilter<"CampaignTimeline"> | string
    plannedDate?: DateTimeFilter<"CampaignTimeline"> | Date | string
    createdAt?: DateTimeFilter<"CampaignTimeline"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignTimelineOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    milestoneName?: SortOrder
    milestoneType?: SortOrder
    plannedDate?: SortOrder
    createdAt?: SortOrder
    _count?: CampaignTimelineCountOrderByAggregateInput
    _max?: CampaignTimelineMaxOrderByAggregateInput
    _min?: CampaignTimelineMinOrderByAggregateInput
  }

  export type CampaignTimelineScalarWhereWithAggregatesInput = {
    AND?: CampaignTimelineScalarWhereWithAggregatesInput | CampaignTimelineScalarWhereWithAggregatesInput[]
    OR?: CampaignTimelineScalarWhereWithAggregatesInput[]
    NOT?: CampaignTimelineScalarWhereWithAggregatesInput | CampaignTimelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignTimeline"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignTimeline"> | string
    milestoneName?: StringWithAggregatesFilter<"CampaignTimeline"> | string
    milestoneType?: StringWithAggregatesFilter<"CampaignTimeline"> | string
    plannedDate?: DateTimeWithAggregatesFilter<"CampaignTimeline"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignTimeline"> | Date | string
  }

  export type ComplianceChecklistWhereInput = {
    AND?: ComplianceChecklistWhereInput | ComplianceChecklistWhereInput[]
    OR?: ComplianceChecklistWhereInput[]
    NOT?: ComplianceChecklistWhereInput | ComplianceChecklistWhereInput[]
    id?: StringFilter<"ComplianceChecklist"> | string
    campaignId?: StringFilter<"ComplianceChecklist"> | string
    item?: StringFilter<"ComplianceChecklist"> | string
    severity?: StringFilter<"ComplianceChecklist"> | string
    responsibleDepartment?: StringFilter<"ComplianceChecklist"> | string
    status?: StringFilter<"ComplianceChecklist"> | string
    createdAt?: DateTimeFilter<"ComplianceChecklist"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type ComplianceChecklistOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    item?: SortOrder
    severity?: SortOrder
    responsibleDepartment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type ComplianceChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComplianceChecklistWhereInput | ComplianceChecklistWhereInput[]
    OR?: ComplianceChecklistWhereInput[]
    NOT?: ComplianceChecklistWhereInput | ComplianceChecklistWhereInput[]
    campaignId?: StringFilter<"ComplianceChecklist"> | string
    item?: StringFilter<"ComplianceChecklist"> | string
    severity?: StringFilter<"ComplianceChecklist"> | string
    responsibleDepartment?: StringFilter<"ComplianceChecklist"> | string
    status?: StringFilter<"ComplianceChecklist"> | string
    createdAt?: DateTimeFilter<"ComplianceChecklist"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type ComplianceChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    item?: SortOrder
    severity?: SortOrder
    responsibleDepartment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ComplianceChecklistCountOrderByAggregateInput
    _max?: ComplianceChecklistMaxOrderByAggregateInput
    _min?: ComplianceChecklistMinOrderByAggregateInput
  }

  export type ComplianceChecklistScalarWhereWithAggregatesInput = {
    AND?: ComplianceChecklistScalarWhereWithAggregatesInput | ComplianceChecklistScalarWhereWithAggregatesInput[]
    OR?: ComplianceChecklistScalarWhereWithAggregatesInput[]
    NOT?: ComplianceChecklistScalarWhereWithAggregatesInput | ComplianceChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComplianceChecklist"> | string
    campaignId?: StringWithAggregatesFilter<"ComplianceChecklist"> | string
    item?: StringWithAggregatesFilter<"ComplianceChecklist"> | string
    severity?: StringWithAggregatesFilter<"ComplianceChecklist"> | string
    responsibleDepartment?: StringWithAggregatesFilter<"ComplianceChecklist"> | string
    status?: StringWithAggregatesFilter<"ComplianceChecklist"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComplianceChecklist"> | Date | string
  }

  export type PromotionalMessageWhereInput = {
    AND?: PromotionalMessageWhereInput | PromotionalMessageWhereInput[]
    OR?: PromotionalMessageWhereInput[]
    NOT?: PromotionalMessageWhereInput | PromotionalMessageWhereInput[]
    id?: StringFilter<"PromotionalMessage"> | string
    campaignId?: StringFilter<"PromotionalMessage"> | string
    platform?: StringFilter<"PromotionalMessage"> | string
    tone?: StringFilter<"PromotionalMessage"> | string
    message?: StringFilter<"PromotionalMessage"> | string
    callToAction?: StringFilter<"PromotionalMessage"> | string
    createdAt?: DateTimeFilter<"PromotionalMessage"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type PromotionalMessageOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    tone?: SortOrder
    message?: SortOrder
    callToAction?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type PromotionalMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionalMessageWhereInput | PromotionalMessageWhereInput[]
    OR?: PromotionalMessageWhereInput[]
    NOT?: PromotionalMessageWhereInput | PromotionalMessageWhereInput[]
    campaignId?: StringFilter<"PromotionalMessage"> | string
    platform?: StringFilter<"PromotionalMessage"> | string
    tone?: StringFilter<"PromotionalMessage"> | string
    message?: StringFilter<"PromotionalMessage"> | string
    callToAction?: StringFilter<"PromotionalMessage"> | string
    createdAt?: DateTimeFilter<"PromotionalMessage"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type PromotionalMessageOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    tone?: SortOrder
    message?: SortOrder
    callToAction?: SortOrder
    createdAt?: SortOrder
    _count?: PromotionalMessageCountOrderByAggregateInput
    _max?: PromotionalMessageMaxOrderByAggregateInput
    _min?: PromotionalMessageMinOrderByAggregateInput
  }

  export type PromotionalMessageScalarWhereWithAggregatesInput = {
    AND?: PromotionalMessageScalarWhereWithAggregatesInput | PromotionalMessageScalarWhereWithAggregatesInput[]
    OR?: PromotionalMessageScalarWhereWithAggregatesInput[]
    NOT?: PromotionalMessageScalarWhereWithAggregatesInput | PromotionalMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromotionalMessage"> | string
    campaignId?: StringWithAggregatesFilter<"PromotionalMessage"> | string
    platform?: StringWithAggregatesFilter<"PromotionalMessage"> | string
    tone?: StringWithAggregatesFilter<"PromotionalMessage"> | string
    message?: StringWithAggregatesFilter<"PromotionalMessage"> | string
    callToAction?: StringWithAggregatesFilter<"PromotionalMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PromotionalMessage"> | Date | string
  }

  export type CreativeDesignPlanWhereInput = {
    AND?: CreativeDesignPlanWhereInput | CreativeDesignPlanWhereInput[]
    OR?: CreativeDesignPlanWhereInput[]
    NOT?: CreativeDesignPlanWhereInput | CreativeDesignPlanWhereInput[]
    id?: StringFilter<"CreativeDesignPlan"> | string
    campaignId?: StringFilter<"CreativeDesignPlan"> | string
    platform?: StringFilter<"CreativeDesignPlan"> | string
    creativeTitle?: StringFilter<"CreativeDesignPlan"> | string
    headline?: StringFilter<"CreativeDesignPlan"> | string
    visualTheme?: StringFilter<"CreativeDesignPlan"> | string
    cta?: StringFilter<"CreativeDesignPlan"> | string
    mobileOptimizationTip?: StringFilter<"CreativeDesignPlan"> | string
    createdAt?: DateTimeFilter<"CreativeDesignPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CreativeDesignPlanOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    creativeTitle?: SortOrder
    headline?: SortOrder
    visualTheme?: SortOrder
    cta?: SortOrder
    mobileOptimizationTip?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CreativeDesignPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreativeDesignPlanWhereInput | CreativeDesignPlanWhereInput[]
    OR?: CreativeDesignPlanWhereInput[]
    NOT?: CreativeDesignPlanWhereInput | CreativeDesignPlanWhereInput[]
    campaignId?: StringFilter<"CreativeDesignPlan"> | string
    platform?: StringFilter<"CreativeDesignPlan"> | string
    creativeTitle?: StringFilter<"CreativeDesignPlan"> | string
    headline?: StringFilter<"CreativeDesignPlan"> | string
    visualTheme?: StringFilter<"CreativeDesignPlan"> | string
    cta?: StringFilter<"CreativeDesignPlan"> | string
    mobileOptimizationTip?: StringFilter<"CreativeDesignPlan"> | string
    createdAt?: DateTimeFilter<"CreativeDesignPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CreativeDesignPlanOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    creativeTitle?: SortOrder
    headline?: SortOrder
    visualTheme?: SortOrder
    cta?: SortOrder
    mobileOptimizationTip?: SortOrder
    createdAt?: SortOrder
    _count?: CreativeDesignPlanCountOrderByAggregateInput
    _max?: CreativeDesignPlanMaxOrderByAggregateInput
    _min?: CreativeDesignPlanMinOrderByAggregateInput
  }

  export type CreativeDesignPlanScalarWhereWithAggregatesInput = {
    AND?: CreativeDesignPlanScalarWhereWithAggregatesInput | CreativeDesignPlanScalarWhereWithAggregatesInput[]
    OR?: CreativeDesignPlanScalarWhereWithAggregatesInput[]
    NOT?: CreativeDesignPlanScalarWhereWithAggregatesInput | CreativeDesignPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreativeDesignPlan"> | string
    campaignId?: StringWithAggregatesFilter<"CreativeDesignPlan"> | string
    platform?: StringWithAggregatesFilter<"CreativeDesignPlan"> | string
    creativeTitle?: StringWithAggregatesFilter<"CreativeDesignPlan"> | string
    headline?: StringWithAggregatesFilter<"CreativeDesignPlan"> | string
    visualTheme?: StringWithAggregatesFilter<"CreativeDesignPlan"> | string
    cta?: StringWithAggregatesFilter<"CreativeDesignPlan"> | string
    mobileOptimizationTip?: StringWithAggregatesFilter<"CreativeDesignPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CreativeDesignPlan"> | Date | string
  }

  export type CreativeAssetWhereInput = {
    AND?: CreativeAssetWhereInput | CreativeAssetWhereInput[]
    OR?: CreativeAssetWhereInput[]
    NOT?: CreativeAssetWhereInput | CreativeAssetWhereInput[]
    id?: StringFilter<"CreativeAsset"> | string
    campaignId?: StringFilter<"CreativeAsset"> | string
    type?: StringFilter<"CreativeAsset"> | string
    assetUrl?: StringFilter<"CreativeAsset"> | string
    createdAt?: DateTimeFilter<"CreativeAsset"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CreativeAssetOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    assetUrl?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CreativeAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreativeAssetWhereInput | CreativeAssetWhereInput[]
    OR?: CreativeAssetWhereInput[]
    NOT?: CreativeAssetWhereInput | CreativeAssetWhereInput[]
    campaignId?: StringFilter<"CreativeAsset"> | string
    type?: StringFilter<"CreativeAsset"> | string
    assetUrl?: StringFilter<"CreativeAsset"> | string
    createdAt?: DateTimeFilter<"CreativeAsset"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CreativeAssetOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    assetUrl?: SortOrder
    createdAt?: SortOrder
    _count?: CreativeAssetCountOrderByAggregateInput
    _max?: CreativeAssetMaxOrderByAggregateInput
    _min?: CreativeAssetMinOrderByAggregateInput
  }

  export type CreativeAssetScalarWhereWithAggregatesInput = {
    AND?: CreativeAssetScalarWhereWithAggregatesInput | CreativeAssetScalarWhereWithAggregatesInput[]
    OR?: CreativeAssetScalarWhereWithAggregatesInput[]
    NOT?: CreativeAssetScalarWhereWithAggregatesInput | CreativeAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreativeAsset"> | string
    campaignId?: StringWithAggregatesFilter<"CreativeAsset"> | string
    type?: StringWithAggregatesFilter<"CreativeAsset"> | string
    assetUrl?: StringWithAggregatesFilter<"CreativeAsset"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CreativeAsset"> | Date | string
  }

  export type MediaAssetWhereInput = {
    AND?: MediaAssetWhereInput | MediaAssetWhereInput[]
    OR?: MediaAssetWhereInput[]
    NOT?: MediaAssetWhereInput | MediaAssetWhereInput[]
    id?: StringFilter<"MediaAsset"> | string
    campaignId?: StringFilter<"MediaAsset"> | string
    type?: StringFilter<"MediaAsset"> | string
    title?: StringFilter<"MediaAsset"> | string
    concept?: StringFilter<"MediaAsset"> | string
    engagementTip?: StringFilter<"MediaAsset"> | string
    mobileOptimizationTip?: StringFilter<"MediaAsset"> | string
    url?: StringNullableFilter<"MediaAsset"> | string | null
    createdAt?: DateTimeFilter<"MediaAsset"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type MediaAssetOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    concept?: SortOrder
    engagementTip?: SortOrder
    mobileOptimizationTip?: SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type MediaAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaAssetWhereInput | MediaAssetWhereInput[]
    OR?: MediaAssetWhereInput[]
    NOT?: MediaAssetWhereInput | MediaAssetWhereInput[]
    campaignId?: StringFilter<"MediaAsset"> | string
    type?: StringFilter<"MediaAsset"> | string
    title?: StringFilter<"MediaAsset"> | string
    concept?: StringFilter<"MediaAsset"> | string
    engagementTip?: StringFilter<"MediaAsset"> | string
    mobileOptimizationTip?: StringFilter<"MediaAsset"> | string
    url?: StringNullableFilter<"MediaAsset"> | string | null
    createdAt?: DateTimeFilter<"MediaAsset"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type MediaAssetOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    concept?: SortOrder
    engagementTip?: SortOrder
    mobileOptimizationTip?: SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MediaAssetCountOrderByAggregateInput
    _max?: MediaAssetMaxOrderByAggregateInput
    _min?: MediaAssetMinOrderByAggregateInput
  }

  export type MediaAssetScalarWhereWithAggregatesInput = {
    AND?: MediaAssetScalarWhereWithAggregatesInput | MediaAssetScalarWhereWithAggregatesInput[]
    OR?: MediaAssetScalarWhereWithAggregatesInput[]
    NOT?: MediaAssetScalarWhereWithAggregatesInput | MediaAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaAsset"> | string
    campaignId?: StringWithAggregatesFilter<"MediaAsset"> | string
    type?: StringWithAggregatesFilter<"MediaAsset"> | string
    title?: StringWithAggregatesFilter<"MediaAsset"> | string
    concept?: StringWithAggregatesFilter<"MediaAsset"> | string
    engagementTip?: StringWithAggregatesFilter<"MediaAsset"> | string
    mobileOptimizationTip?: StringWithAggregatesFilter<"MediaAsset"> | string
    url?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MediaAsset"> | Date | string
  }

  export type ContentCalendarWhereInput = {
    AND?: ContentCalendarWhereInput | ContentCalendarWhereInput[]
    OR?: ContentCalendarWhereInput[]
    NOT?: ContentCalendarWhereInput | ContentCalendarWhereInput[]
    id?: StringFilter<"ContentCalendar"> | string
    campaignId?: StringFilter<"ContentCalendar"> | string
    contentType?: StringFilter<"ContentCalendar"> | string
    platform?: StringFilter<"ContentCalendar"> | string
    contentRef?: StringFilter<"ContentCalendar"> | string
    scheduledFor?: DateTimeFilter<"ContentCalendar"> | Date | string
    notes?: StringNullableFilter<"ContentCalendar"> | string | null
    createdAt?: DateTimeFilter<"ContentCalendar"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type ContentCalendarOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contentType?: SortOrder
    platform?: SortOrder
    contentRef?: SortOrder
    scheduledFor?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type ContentCalendarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentCalendarWhereInput | ContentCalendarWhereInput[]
    OR?: ContentCalendarWhereInput[]
    NOT?: ContentCalendarWhereInput | ContentCalendarWhereInput[]
    campaignId?: StringFilter<"ContentCalendar"> | string
    contentType?: StringFilter<"ContentCalendar"> | string
    platform?: StringFilter<"ContentCalendar"> | string
    contentRef?: StringFilter<"ContentCalendar"> | string
    scheduledFor?: DateTimeFilter<"ContentCalendar"> | Date | string
    notes?: StringNullableFilter<"ContentCalendar"> | string | null
    createdAt?: DateTimeFilter<"ContentCalendar"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type ContentCalendarOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contentType?: SortOrder
    platform?: SortOrder
    contentRef?: SortOrder
    scheduledFor?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContentCalendarCountOrderByAggregateInput
    _max?: ContentCalendarMaxOrderByAggregateInput
    _min?: ContentCalendarMinOrderByAggregateInput
  }

  export type ContentCalendarScalarWhereWithAggregatesInput = {
    AND?: ContentCalendarScalarWhereWithAggregatesInput | ContentCalendarScalarWhereWithAggregatesInput[]
    OR?: ContentCalendarScalarWhereWithAggregatesInput[]
    NOT?: ContentCalendarScalarWhereWithAggregatesInput | ContentCalendarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentCalendar"> | string
    campaignId?: StringWithAggregatesFilter<"ContentCalendar"> | string
    contentType?: StringWithAggregatesFilter<"ContentCalendar"> | string
    platform?: StringWithAggregatesFilter<"ContentCalendar"> | string
    contentRef?: StringWithAggregatesFilter<"ContentCalendar"> | string
    scheduledFor?: DateTimeWithAggregatesFilter<"ContentCalendar"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"ContentCalendar"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentCalendar"> | Date | string
  }

  export type TeaserContentWhereInput = {
    AND?: TeaserContentWhereInput | TeaserContentWhereInput[]
    OR?: TeaserContentWhereInput[]
    NOT?: TeaserContentWhereInput | TeaserContentWhereInput[]
    id?: StringFilter<"TeaserContent"> | string
    campaignId?: StringFilter<"TeaserContent"> | string
    message?: StringFilter<"TeaserContent"> | string
    platform?: StringFilter<"TeaserContent"> | string
    teaserTheme?: StringNullableFilter<"TeaserContent"> | string | null
    tone?: StringFilter<"TeaserContent"> | string
    scheduledAt?: DateTimeFilter<"TeaserContent"> | Date | string
    createdAt?: DateTimeFilter<"TeaserContent"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type TeaserContentOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    message?: SortOrder
    platform?: SortOrder
    teaserTheme?: SortOrderInput | SortOrder
    tone?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type TeaserContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeaserContentWhereInput | TeaserContentWhereInput[]
    OR?: TeaserContentWhereInput[]
    NOT?: TeaserContentWhereInput | TeaserContentWhereInput[]
    campaignId?: StringFilter<"TeaserContent"> | string
    message?: StringFilter<"TeaserContent"> | string
    platform?: StringFilter<"TeaserContent"> | string
    teaserTheme?: StringNullableFilter<"TeaserContent"> | string | null
    tone?: StringFilter<"TeaserContent"> | string
    scheduledAt?: DateTimeFilter<"TeaserContent"> | Date | string
    createdAt?: DateTimeFilter<"TeaserContent"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type TeaserContentOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    message?: SortOrder
    platform?: SortOrder
    teaserTheme?: SortOrderInput | SortOrder
    tone?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    _count?: TeaserContentCountOrderByAggregateInput
    _max?: TeaserContentMaxOrderByAggregateInput
    _min?: TeaserContentMinOrderByAggregateInput
  }

  export type TeaserContentScalarWhereWithAggregatesInput = {
    AND?: TeaserContentScalarWhereWithAggregatesInput | TeaserContentScalarWhereWithAggregatesInput[]
    OR?: TeaserContentScalarWhereWithAggregatesInput[]
    NOT?: TeaserContentScalarWhereWithAggregatesInput | TeaserContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeaserContent"> | string
    campaignId?: StringWithAggregatesFilter<"TeaserContent"> | string
    message?: StringWithAggregatesFilter<"TeaserContent"> | string
    platform?: StringWithAggregatesFilter<"TeaserContent"> | string
    teaserTheme?: StringNullableWithAggregatesFilter<"TeaserContent"> | string | null
    tone?: StringWithAggregatesFilter<"TeaserContent"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"TeaserContent"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TeaserContent"> | Date | string
  }

  export type CustomerSegmentListWhereInput = {
    AND?: CustomerSegmentListWhereInput | CustomerSegmentListWhereInput[]
    OR?: CustomerSegmentListWhereInput[]
    NOT?: CustomerSegmentListWhereInput | CustomerSegmentListWhereInput[]
    id?: StringFilter<"CustomerSegmentList"> | string
    campaignId?: StringFilter<"CustomerSegmentList"> | string
    segment?: StringFilter<"CustomerSegmentList"> | string
    criteria?: StringFilter<"CustomerSegmentList"> | string
    count?: IntFilter<"CustomerSegmentList"> | number
    createdAt?: DateTimeFilter<"CustomerSegmentList"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CustomerSegmentListOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
    criteria?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CustomerSegmentListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerSegmentListWhereInput | CustomerSegmentListWhereInput[]
    OR?: CustomerSegmentListWhereInput[]
    NOT?: CustomerSegmentListWhereInput | CustomerSegmentListWhereInput[]
    campaignId?: StringFilter<"CustomerSegmentList"> | string
    segment?: StringFilter<"CustomerSegmentList"> | string
    criteria?: StringFilter<"CustomerSegmentList"> | string
    count?: IntFilter<"CustomerSegmentList"> | number
    createdAt?: DateTimeFilter<"CustomerSegmentList"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CustomerSegmentListOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
    criteria?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerSegmentListCountOrderByAggregateInput
    _avg?: CustomerSegmentListAvgOrderByAggregateInput
    _max?: CustomerSegmentListMaxOrderByAggregateInput
    _min?: CustomerSegmentListMinOrderByAggregateInput
    _sum?: CustomerSegmentListSumOrderByAggregateInput
  }

  export type CustomerSegmentListScalarWhereWithAggregatesInput = {
    AND?: CustomerSegmentListScalarWhereWithAggregatesInput | CustomerSegmentListScalarWhereWithAggregatesInput[]
    OR?: CustomerSegmentListScalarWhereWithAggregatesInput[]
    NOT?: CustomerSegmentListScalarWhereWithAggregatesInput | CustomerSegmentListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerSegmentList"> | string
    campaignId?: StringWithAggregatesFilter<"CustomerSegmentList"> | string
    segment?: StringWithAggregatesFilter<"CustomerSegmentList"> | string
    criteria?: StringWithAggregatesFilter<"CustomerSegmentList"> | string
    count?: IntWithAggregatesFilter<"CustomerSegmentList"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomerSegmentList"> | Date | string
  }

  export type InfluencerPlanWhereInput = {
    AND?: InfluencerPlanWhereInput | InfluencerPlanWhereInput[]
    OR?: InfluencerPlanWhereInput[]
    NOT?: InfluencerPlanWhereInput | InfluencerPlanWhereInput[]
    id?: StringFilter<"InfluencerPlan"> | string
    campaignId?: StringFilter<"InfluencerPlan"> | string
    influencerName?: StringFilter<"InfluencerPlan"> | string
    platform?: StringFilter<"InfluencerPlan"> | string
    postType?: StringFilter<"InfluencerPlan"> | string
    expectedImpact?: StringNullableFilter<"InfluencerPlan"> | string | null
    scheduledAt?: DateTimeFilter<"InfluencerPlan"> | Date | string
    createdAt?: DateTimeFilter<"InfluencerPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type InfluencerPlanOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    influencerName?: SortOrder
    platform?: SortOrder
    postType?: SortOrder
    expectedImpact?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type InfluencerPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InfluencerPlanWhereInput | InfluencerPlanWhereInput[]
    OR?: InfluencerPlanWhereInput[]
    NOT?: InfluencerPlanWhereInput | InfluencerPlanWhereInput[]
    campaignId?: StringFilter<"InfluencerPlan"> | string
    influencerName?: StringFilter<"InfluencerPlan"> | string
    platform?: StringFilter<"InfluencerPlan"> | string
    postType?: StringFilter<"InfluencerPlan"> | string
    expectedImpact?: StringNullableFilter<"InfluencerPlan"> | string | null
    scheduledAt?: DateTimeFilter<"InfluencerPlan"> | Date | string
    createdAt?: DateTimeFilter<"InfluencerPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type InfluencerPlanOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    influencerName?: SortOrder
    platform?: SortOrder
    postType?: SortOrder
    expectedImpact?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    _count?: InfluencerPlanCountOrderByAggregateInput
    _max?: InfluencerPlanMaxOrderByAggregateInput
    _min?: InfluencerPlanMinOrderByAggregateInput
  }

  export type InfluencerPlanScalarWhereWithAggregatesInput = {
    AND?: InfluencerPlanScalarWhereWithAggregatesInput | InfluencerPlanScalarWhereWithAggregatesInput[]
    OR?: InfluencerPlanScalarWhereWithAggregatesInput[]
    NOT?: InfluencerPlanScalarWhereWithAggregatesInput | InfluencerPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InfluencerPlan"> | string
    campaignId?: StringWithAggregatesFilter<"InfluencerPlan"> | string
    influencerName?: StringWithAggregatesFilter<"InfluencerPlan"> | string
    platform?: StringWithAggregatesFilter<"InfluencerPlan"> | string
    postType?: StringWithAggregatesFilter<"InfluencerPlan"> | string
    expectedImpact?: StringNullableWithAggregatesFilter<"InfluencerPlan"> | string | null
    scheduledAt?: DateTimeWithAggregatesFilter<"InfluencerPlan"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"InfluencerPlan"> | Date | string
  }

  export type OperationalChecklistWhereInput = {
    AND?: OperationalChecklistWhereInput | OperationalChecklistWhereInput[]
    OR?: OperationalChecklistWhereInput[]
    NOT?: OperationalChecklistWhereInput | OperationalChecklistWhereInput[]
    id?: StringFilter<"OperationalChecklist"> | string
    campaignId?: StringFilter<"OperationalChecklist"> | string
    system?: StringFilter<"OperationalChecklist"> | string
    checklistItem?: StringFilter<"OperationalChecklist"> | string
    expectedOutcome?: StringFilter<"OperationalChecklist"> | string
    responsibility?: StringFilter<"OperationalChecklist"> | string
    status?: StringFilter<"OperationalChecklist"> | string
    createdAt?: DateTimeFilter<"OperationalChecklist"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type OperationalChecklistOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    system?: SortOrder
    checklistItem?: SortOrder
    expectedOutcome?: SortOrder
    responsibility?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type OperationalChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OperationalChecklistWhereInput | OperationalChecklistWhereInput[]
    OR?: OperationalChecklistWhereInput[]
    NOT?: OperationalChecklistWhereInput | OperationalChecklistWhereInput[]
    campaignId?: StringFilter<"OperationalChecklist"> | string
    system?: StringFilter<"OperationalChecklist"> | string
    checklistItem?: StringFilter<"OperationalChecklist"> | string
    expectedOutcome?: StringFilter<"OperationalChecklist"> | string
    responsibility?: StringFilter<"OperationalChecklist"> | string
    status?: StringFilter<"OperationalChecklist"> | string
    createdAt?: DateTimeFilter<"OperationalChecklist"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type OperationalChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    system?: SortOrder
    checklistItem?: SortOrder
    expectedOutcome?: SortOrder
    responsibility?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: OperationalChecklistCountOrderByAggregateInput
    _max?: OperationalChecklistMaxOrderByAggregateInput
    _min?: OperationalChecklistMinOrderByAggregateInput
  }

  export type OperationalChecklistScalarWhereWithAggregatesInput = {
    AND?: OperationalChecklistScalarWhereWithAggregatesInput | OperationalChecklistScalarWhereWithAggregatesInput[]
    OR?: OperationalChecklistScalarWhereWithAggregatesInput[]
    NOT?: OperationalChecklistScalarWhereWithAggregatesInput | OperationalChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OperationalChecklist"> | string
    campaignId?: StringWithAggregatesFilter<"OperationalChecklist"> | string
    system?: StringWithAggregatesFilter<"OperationalChecklist"> | string
    checklistItem?: StringWithAggregatesFilter<"OperationalChecklist"> | string
    expectedOutcome?: StringWithAggregatesFilter<"OperationalChecklist"> | string
    responsibility?: StringWithAggregatesFilter<"OperationalChecklist"> | string
    status?: StringWithAggregatesFilter<"OperationalChecklist"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OperationalChecklist"> | Date | string
  }

  export type CampaignActivationWhereInput = {
    AND?: CampaignActivationWhereInput | CampaignActivationWhereInput[]
    OR?: CampaignActivationWhereInput[]
    NOT?: CampaignActivationWhereInput | CampaignActivationWhereInput[]
    id?: StringFilter<"CampaignActivation"> | string
    campaignId?: StringFilter<"CampaignActivation"> | string
    platform?: StringFilter<"CampaignActivation"> | string
    assetType?: StringFilter<"CampaignActivation"> | string
    assetReference?: StringFilter<"CampaignActivation"> | string
    activationTime?: DateTimeFilter<"CampaignActivation"> | Date | string
    status?: StringFilter<"CampaignActivation"> | string
    activationResult?: StringFilter<"CampaignActivation"> | string
    createdAt?: DateTimeFilter<"CampaignActivation"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignActivationOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    assetType?: SortOrder
    assetReference?: SortOrder
    activationTime?: SortOrder
    status?: SortOrder
    activationResult?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignActivationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignActivationWhereInput | CampaignActivationWhereInput[]
    OR?: CampaignActivationWhereInput[]
    NOT?: CampaignActivationWhereInput | CampaignActivationWhereInput[]
    campaignId?: StringFilter<"CampaignActivation"> | string
    platform?: StringFilter<"CampaignActivation"> | string
    assetType?: StringFilter<"CampaignActivation"> | string
    assetReference?: StringFilter<"CampaignActivation"> | string
    activationTime?: DateTimeFilter<"CampaignActivation"> | Date | string
    status?: StringFilter<"CampaignActivation"> | string
    activationResult?: StringFilter<"CampaignActivation"> | string
    createdAt?: DateTimeFilter<"CampaignActivation"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignActivationOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    assetType?: SortOrder
    assetReference?: SortOrder
    activationTime?: SortOrder
    status?: SortOrder
    activationResult?: SortOrder
    createdAt?: SortOrder
    _count?: CampaignActivationCountOrderByAggregateInput
    _max?: CampaignActivationMaxOrderByAggregateInput
    _min?: CampaignActivationMinOrderByAggregateInput
  }

  export type CampaignActivationScalarWhereWithAggregatesInput = {
    AND?: CampaignActivationScalarWhereWithAggregatesInput | CampaignActivationScalarWhereWithAggregatesInput[]
    OR?: CampaignActivationScalarWhereWithAggregatesInput[]
    NOT?: CampaignActivationScalarWhereWithAggregatesInput | CampaignActivationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignActivation"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignActivation"> | string
    platform?: StringWithAggregatesFilter<"CampaignActivation"> | string
    assetType?: StringWithAggregatesFilter<"CampaignActivation"> | string
    assetReference?: StringWithAggregatesFilter<"CampaignActivation"> | string
    activationTime?: DateTimeWithAggregatesFilter<"CampaignActivation"> | Date | string
    status?: StringWithAggregatesFilter<"CampaignActivation"> | string
    activationResult?: StringWithAggregatesFilter<"CampaignActivation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignActivation"> | Date | string
  }

  export type CustomerEngagementLogWhereInput = {
    AND?: CustomerEngagementLogWhereInput | CustomerEngagementLogWhereInput[]
    OR?: CustomerEngagementLogWhereInput[]
    NOT?: CustomerEngagementLogWhereInput | CustomerEngagementLogWhereInput[]
    id?: StringFilter<"CustomerEngagementLog"> | string
    campaignId?: StringFilter<"CustomerEngagementLog"> | string
    userId?: StringFilter<"CustomerEngagementLog"> | string
    sessionId?: StringFilter<"CustomerEngagementLog"> | string
    interactionType?: StringFilter<"CustomerEngagementLog"> | string
    message?: StringFilter<"CustomerEngagementLog"> | string
    resolutionStatus?: StringFilter<"CustomerEngagementLog"> | string
    responseTime?: IntFilter<"CustomerEngagementLog"> | number
    csatScore?: IntNullableFilter<"CustomerEngagementLog"> | number | null
    createdAt?: DateTimeFilter<"CustomerEngagementLog"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CustomerEngagementLogOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    message?: SortOrder
    resolutionStatus?: SortOrder
    responseTime?: SortOrder
    csatScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CustomerEngagementLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerEngagementLogWhereInput | CustomerEngagementLogWhereInput[]
    OR?: CustomerEngagementLogWhereInput[]
    NOT?: CustomerEngagementLogWhereInput | CustomerEngagementLogWhereInput[]
    campaignId?: StringFilter<"CustomerEngagementLog"> | string
    userId?: StringFilter<"CustomerEngagementLog"> | string
    sessionId?: StringFilter<"CustomerEngagementLog"> | string
    interactionType?: StringFilter<"CustomerEngagementLog"> | string
    message?: StringFilter<"CustomerEngagementLog"> | string
    resolutionStatus?: StringFilter<"CustomerEngagementLog"> | string
    responseTime?: IntFilter<"CustomerEngagementLog"> | number
    csatScore?: IntNullableFilter<"CustomerEngagementLog"> | number | null
    createdAt?: DateTimeFilter<"CustomerEngagementLog"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CustomerEngagementLogOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    message?: SortOrder
    resolutionStatus?: SortOrder
    responseTime?: SortOrder
    csatScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CustomerEngagementLogCountOrderByAggregateInput
    _avg?: CustomerEngagementLogAvgOrderByAggregateInput
    _max?: CustomerEngagementLogMaxOrderByAggregateInput
    _min?: CustomerEngagementLogMinOrderByAggregateInput
    _sum?: CustomerEngagementLogSumOrderByAggregateInput
  }

  export type CustomerEngagementLogScalarWhereWithAggregatesInput = {
    AND?: CustomerEngagementLogScalarWhereWithAggregatesInput | CustomerEngagementLogScalarWhereWithAggregatesInput[]
    OR?: CustomerEngagementLogScalarWhereWithAggregatesInput[]
    NOT?: CustomerEngagementLogScalarWhereWithAggregatesInput | CustomerEngagementLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerEngagementLog"> | string
    campaignId?: StringWithAggregatesFilter<"CustomerEngagementLog"> | string
    userId?: StringWithAggregatesFilter<"CustomerEngagementLog"> | string
    sessionId?: StringWithAggregatesFilter<"CustomerEngagementLog"> | string
    interactionType?: StringWithAggregatesFilter<"CustomerEngagementLog"> | string
    message?: StringWithAggregatesFilter<"CustomerEngagementLog"> | string
    resolutionStatus?: StringWithAggregatesFilter<"CustomerEngagementLog"> | string
    responseTime?: IntWithAggregatesFilter<"CustomerEngagementLog"> | number
    csatScore?: IntNullableWithAggregatesFilter<"CustomerEngagementLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomerEngagementLog"> | Date | string
  }

  export type PerformanceReportWhereInput = {
    AND?: PerformanceReportWhereInput | PerformanceReportWhereInput[]
    OR?: PerformanceReportWhereInput[]
    NOT?: PerformanceReportWhereInput | PerformanceReportWhereInput[]
    id?: StringFilter<"PerformanceReport"> | string
    campaignId?: StringFilter<"PerformanceReport"> | string
    date?: DateTimeFilter<"PerformanceReport"> | Date | string
    impressions?: IntFilter<"PerformanceReport"> | number
    clicks?: IntFilter<"PerformanceReport"> | number
    qrScans?: IntFilter<"PerformanceReport"> | number
    conversions?: IntFilter<"PerformanceReport"> | number
    chatbotSessions?: IntFilter<"PerformanceReport"> | number
    escalations?: IntFilter<"PerformanceReport"> | number
    escalationRate?: FloatFilter<"PerformanceReport"> | number
    avgBotResponseTime?: IntFilter<"PerformanceReport"> | number
    avgHumanResponseTime?: IntFilter<"PerformanceReport"> | number
    csatScoreAverage?: FloatFilter<"PerformanceReport"> | number
    anomalies?: StringNullableFilter<"PerformanceReport"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReport"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type PerformanceReportOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    qrScans?: SortOrder
    conversions?: SortOrder
    chatbotSessions?: SortOrder
    escalations?: SortOrder
    escalationRate?: SortOrder
    avgBotResponseTime?: SortOrder
    avgHumanResponseTime?: SortOrder
    csatScoreAverage?: SortOrder
    anomalies?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type PerformanceReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceReportWhereInput | PerformanceReportWhereInput[]
    OR?: PerformanceReportWhereInput[]
    NOT?: PerformanceReportWhereInput | PerformanceReportWhereInput[]
    campaignId?: StringFilter<"PerformanceReport"> | string
    date?: DateTimeFilter<"PerformanceReport"> | Date | string
    impressions?: IntFilter<"PerformanceReport"> | number
    clicks?: IntFilter<"PerformanceReport"> | number
    qrScans?: IntFilter<"PerformanceReport"> | number
    conversions?: IntFilter<"PerformanceReport"> | number
    chatbotSessions?: IntFilter<"PerformanceReport"> | number
    escalations?: IntFilter<"PerformanceReport"> | number
    escalationRate?: FloatFilter<"PerformanceReport"> | number
    avgBotResponseTime?: IntFilter<"PerformanceReport"> | number
    avgHumanResponseTime?: IntFilter<"PerformanceReport"> | number
    csatScoreAverage?: FloatFilter<"PerformanceReport"> | number
    anomalies?: StringNullableFilter<"PerformanceReport"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReport"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type PerformanceReportOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    qrScans?: SortOrder
    conversions?: SortOrder
    chatbotSessions?: SortOrder
    escalations?: SortOrder
    escalationRate?: SortOrder
    avgBotResponseTime?: SortOrder
    avgHumanResponseTime?: SortOrder
    csatScoreAverage?: SortOrder
    anomalies?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PerformanceReportCountOrderByAggregateInput
    _avg?: PerformanceReportAvgOrderByAggregateInput
    _max?: PerformanceReportMaxOrderByAggregateInput
    _min?: PerformanceReportMinOrderByAggregateInput
    _sum?: PerformanceReportSumOrderByAggregateInput
  }

  export type PerformanceReportScalarWhereWithAggregatesInput = {
    AND?: PerformanceReportScalarWhereWithAggregatesInput | PerformanceReportScalarWhereWithAggregatesInput[]
    OR?: PerformanceReportScalarWhereWithAggregatesInput[]
    NOT?: PerformanceReportScalarWhereWithAggregatesInput | PerformanceReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceReport"> | string
    campaignId?: StringWithAggregatesFilter<"PerformanceReport"> | string
    date?: DateTimeWithAggregatesFilter<"PerformanceReport"> | Date | string
    impressions?: IntWithAggregatesFilter<"PerformanceReport"> | number
    clicks?: IntWithAggregatesFilter<"PerformanceReport"> | number
    qrScans?: IntWithAggregatesFilter<"PerformanceReport"> | number
    conversions?: IntWithAggregatesFilter<"PerformanceReport"> | number
    chatbotSessions?: IntWithAggregatesFilter<"PerformanceReport"> | number
    escalations?: IntWithAggregatesFilter<"PerformanceReport"> | number
    escalationRate?: FloatWithAggregatesFilter<"PerformanceReport"> | number
    avgBotResponseTime?: IntWithAggregatesFilter<"PerformanceReport"> | number
    avgHumanResponseTime?: IntWithAggregatesFilter<"PerformanceReport"> | number
    csatScoreAverage?: FloatWithAggregatesFilter<"PerformanceReport"> | number
    anomalies?: StringNullableWithAggregatesFilter<"PerformanceReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceReport"> | Date | string
  }

  export type CustomerFeedbackWhereInput = {
    AND?: CustomerFeedbackWhereInput | CustomerFeedbackWhereInput[]
    OR?: CustomerFeedbackWhereInput[]
    NOT?: CustomerFeedbackWhereInput | CustomerFeedbackWhereInput[]
    id?: StringFilter<"CustomerFeedback"> | string
    campaignId?: StringFilter<"CustomerFeedback"> | string
    userId?: StringFilter<"CustomerFeedback"> | string
    interactionId?: StringNullableFilter<"CustomerFeedback"> | string | null
    feedbackText?: StringFilter<"CustomerFeedback"> | string
    rating?: IntFilter<"CustomerFeedback"> | number
    collectedVia?: StringFilter<"CustomerFeedback"> | string
    createdAt?: DateTimeFilter<"CustomerFeedback"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CustomerFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    interactionId?: SortOrderInput | SortOrder
    feedbackText?: SortOrder
    rating?: SortOrder
    collectedVia?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CustomerFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerFeedbackWhereInput | CustomerFeedbackWhereInput[]
    OR?: CustomerFeedbackWhereInput[]
    NOT?: CustomerFeedbackWhereInput | CustomerFeedbackWhereInput[]
    campaignId?: StringFilter<"CustomerFeedback"> | string
    userId?: StringFilter<"CustomerFeedback"> | string
    interactionId?: StringNullableFilter<"CustomerFeedback"> | string | null
    feedbackText?: StringFilter<"CustomerFeedback"> | string
    rating?: IntFilter<"CustomerFeedback"> | number
    collectedVia?: StringFilter<"CustomerFeedback"> | string
    createdAt?: DateTimeFilter<"CustomerFeedback"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CustomerFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    interactionId?: SortOrderInput | SortOrder
    feedbackText?: SortOrder
    rating?: SortOrder
    collectedVia?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerFeedbackCountOrderByAggregateInput
    _avg?: CustomerFeedbackAvgOrderByAggregateInput
    _max?: CustomerFeedbackMaxOrderByAggregateInput
    _min?: CustomerFeedbackMinOrderByAggregateInput
    _sum?: CustomerFeedbackSumOrderByAggregateInput
  }

  export type CustomerFeedbackScalarWhereWithAggregatesInput = {
    AND?: CustomerFeedbackScalarWhereWithAggregatesInput | CustomerFeedbackScalarWhereWithAggregatesInput[]
    OR?: CustomerFeedbackScalarWhereWithAggregatesInput[]
    NOT?: CustomerFeedbackScalarWhereWithAggregatesInput | CustomerFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerFeedback"> | string
    campaignId?: StringWithAggregatesFilter<"CustomerFeedback"> | string
    userId?: StringWithAggregatesFilter<"CustomerFeedback"> | string
    interactionId?: StringNullableWithAggregatesFilter<"CustomerFeedback"> | string | null
    feedbackText?: StringWithAggregatesFilter<"CustomerFeedback"> | string
    rating?: IntWithAggregatesFilter<"CustomerFeedback"> | number
    collectedVia?: StringWithAggregatesFilter<"CustomerFeedback"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerFeedback"> | Date | string
  }

  export type ThankYouMessageWhereInput = {
    AND?: ThankYouMessageWhereInput | ThankYouMessageWhereInput[]
    OR?: ThankYouMessageWhereInput[]
    NOT?: ThankYouMessageWhereInput | ThankYouMessageWhereInput[]
    id?: StringFilter<"ThankYouMessage"> | string
    campaignId?: StringFilter<"ThankYouMessage"> | string
    userId?: StringFilter<"ThankYouMessage"> | string
    messageBody?: StringFilter<"ThankYouMessage"> | string
    sentVia?: StringFilter<"ThankYouMessage"> | string
    segment?: StringFilter<"ThankYouMessage"> | string
    sentAt?: DateTimeFilter<"ThankYouMessage"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type ThankYouMessageOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    messageBody?: SortOrder
    sentVia?: SortOrder
    segment?: SortOrder
    sentAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type ThankYouMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThankYouMessageWhereInput | ThankYouMessageWhereInput[]
    OR?: ThankYouMessageWhereInput[]
    NOT?: ThankYouMessageWhereInput | ThankYouMessageWhereInput[]
    campaignId?: StringFilter<"ThankYouMessage"> | string
    userId?: StringFilter<"ThankYouMessage"> | string
    messageBody?: StringFilter<"ThankYouMessage"> | string
    sentVia?: StringFilter<"ThankYouMessage"> | string
    segment?: StringFilter<"ThankYouMessage"> | string
    sentAt?: DateTimeFilter<"ThankYouMessage"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type ThankYouMessageOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    messageBody?: SortOrder
    sentVia?: SortOrder
    segment?: SortOrder
    sentAt?: SortOrder
    _count?: ThankYouMessageCountOrderByAggregateInput
    _max?: ThankYouMessageMaxOrderByAggregateInput
    _min?: ThankYouMessageMinOrderByAggregateInput
  }

  export type ThankYouMessageScalarWhereWithAggregatesInput = {
    AND?: ThankYouMessageScalarWhereWithAggregatesInput | ThankYouMessageScalarWhereWithAggregatesInput[]
    OR?: ThankYouMessageScalarWhereWithAggregatesInput[]
    NOT?: ThankYouMessageScalarWhereWithAggregatesInput | ThankYouMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ThankYouMessage"> | string
    campaignId?: StringWithAggregatesFilter<"ThankYouMessage"> | string
    userId?: StringWithAggregatesFilter<"ThankYouMessage"> | string
    messageBody?: StringWithAggregatesFilter<"ThankYouMessage"> | string
    sentVia?: StringWithAggregatesFilter<"ThankYouMessage"> | string
    segment?: StringWithAggregatesFilter<"ThankYouMessage"> | string
    sentAt?: DateTimeWithAggregatesFilter<"ThankYouMessage"> | Date | string
  }

  export type RetargetingPlanWhereInput = {
    AND?: RetargetingPlanWhereInput | RetargetingPlanWhereInput[]
    OR?: RetargetingPlanWhereInput[]
    NOT?: RetargetingPlanWhereInput | RetargetingPlanWhereInput[]
    id?: StringFilter<"RetargetingPlan"> | string
    campaignId?: StringFilter<"RetargetingPlan"> | string
    audienceSegment?: StringFilter<"RetargetingPlan"> | string
    retargetingChannel?: StringFilter<"RetargetingPlan"> | string
    offerMessage?: StringFilter<"RetargetingPlan"> | string
    scheduledAt?: DateTimeFilter<"RetargetingPlan"> | Date | string
    createdAt?: DateTimeFilter<"RetargetingPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type RetargetingPlanOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    audienceSegment?: SortOrder
    retargetingChannel?: SortOrder
    offerMessage?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type RetargetingPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RetargetingPlanWhereInput | RetargetingPlanWhereInput[]
    OR?: RetargetingPlanWhereInput[]
    NOT?: RetargetingPlanWhereInput | RetargetingPlanWhereInput[]
    campaignId?: StringFilter<"RetargetingPlan"> | string
    audienceSegment?: StringFilter<"RetargetingPlan"> | string
    retargetingChannel?: StringFilter<"RetargetingPlan"> | string
    offerMessage?: StringFilter<"RetargetingPlan"> | string
    scheduledAt?: DateTimeFilter<"RetargetingPlan"> | Date | string
    createdAt?: DateTimeFilter<"RetargetingPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type RetargetingPlanOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    audienceSegment?: SortOrder
    retargetingChannel?: SortOrder
    offerMessage?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    _count?: RetargetingPlanCountOrderByAggregateInput
    _max?: RetargetingPlanMaxOrderByAggregateInput
    _min?: RetargetingPlanMinOrderByAggregateInput
  }

  export type RetargetingPlanScalarWhereWithAggregatesInput = {
    AND?: RetargetingPlanScalarWhereWithAggregatesInput | RetargetingPlanScalarWhereWithAggregatesInput[]
    OR?: RetargetingPlanScalarWhereWithAggregatesInput[]
    NOT?: RetargetingPlanScalarWhereWithAggregatesInput | RetargetingPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RetargetingPlan"> | string
    campaignId?: StringWithAggregatesFilter<"RetargetingPlan"> | string
    audienceSegment?: StringWithAggregatesFilter<"RetargetingPlan"> | string
    retargetingChannel?: StringWithAggregatesFilter<"RetargetingPlan"> | string
    offerMessage?: StringWithAggregatesFilter<"RetargetingPlan"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"RetargetingPlan"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RetargetingPlan"> | Date | string
  }

  export type CampaignExtensionPlanWhereInput = {
    AND?: CampaignExtensionPlanWhereInput | CampaignExtensionPlanWhereInput[]
    OR?: CampaignExtensionPlanWhereInput[]
    NOT?: CampaignExtensionPlanWhereInput | CampaignExtensionPlanWhereInput[]
    id?: StringFilter<"CampaignExtensionPlan"> | string
    campaignId?: StringFilter<"CampaignExtensionPlan"> | string
    reason?: StringFilter<"CampaignExtensionPlan"> | string
    extendedTo?: DateTimeFilter<"CampaignExtensionPlan"> | Date | string
    details?: StringFilter<"CampaignExtensionPlan"> | string
    createdAt?: DateTimeFilter<"CampaignExtensionPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignExtensionPlanOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reason?: SortOrder
    extendedTo?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignExtensionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignExtensionPlanWhereInput | CampaignExtensionPlanWhereInput[]
    OR?: CampaignExtensionPlanWhereInput[]
    NOT?: CampaignExtensionPlanWhereInput | CampaignExtensionPlanWhereInput[]
    campaignId?: StringFilter<"CampaignExtensionPlan"> | string
    reason?: StringFilter<"CampaignExtensionPlan"> | string
    extendedTo?: DateTimeFilter<"CampaignExtensionPlan"> | Date | string
    details?: StringFilter<"CampaignExtensionPlan"> | string
    createdAt?: DateTimeFilter<"CampaignExtensionPlan"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignExtensionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reason?: SortOrder
    extendedTo?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    _count?: CampaignExtensionPlanCountOrderByAggregateInput
    _max?: CampaignExtensionPlanMaxOrderByAggregateInput
    _min?: CampaignExtensionPlanMinOrderByAggregateInput
  }

  export type CampaignExtensionPlanScalarWhereWithAggregatesInput = {
    AND?: CampaignExtensionPlanScalarWhereWithAggregatesInput | CampaignExtensionPlanScalarWhereWithAggregatesInput[]
    OR?: CampaignExtensionPlanScalarWhereWithAggregatesInput[]
    NOT?: CampaignExtensionPlanScalarWhereWithAggregatesInput | CampaignExtensionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignExtensionPlan"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignExtensionPlan"> | string
    reason?: StringWithAggregatesFilter<"CampaignExtensionPlan"> | string
    extendedTo?: DateTimeWithAggregatesFilter<"CampaignExtensionPlan"> | Date | string
    details?: StringWithAggregatesFilter<"CampaignExtensionPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignExtensionPlan"> | Date | string
  }

  export type CampaignAnalysisReportWhereInput = {
    AND?: CampaignAnalysisReportWhereInput | CampaignAnalysisReportWhereInput[]
    OR?: CampaignAnalysisReportWhereInput[]
    NOT?: CampaignAnalysisReportWhereInput | CampaignAnalysisReportWhereInput[]
    id?: StringFilter<"CampaignAnalysisReport"> | string
    campaignId?: StringFilter<"CampaignAnalysisReport"> | string
    totalImpressions?: IntFilter<"CampaignAnalysisReport"> | number
    totalClicks?: IntFilter<"CampaignAnalysisReport"> | number
    totalQrScans?: IntFilter<"CampaignAnalysisReport"> | number
    totalConversions?: IntFilter<"CampaignAnalysisReport"> | number
    conversionRate?: FloatFilter<"CampaignAnalysisReport"> | number
    revenueGenerated?: FloatFilter<"CampaignAnalysisReport"> | number
    campaignSpend?: FloatFilter<"CampaignAnalysisReport"> | number
    roi?: FloatFilter<"CampaignAnalysisReport"> | number
    engagementRate?: FloatFilter<"CampaignAnalysisReport"> | number
    csatAverage?: FloatFilter<"CampaignAnalysisReport"> | number
    escalationRate?: FloatFilter<"CampaignAnalysisReport"> | number
    learningsSummary?: StringNullableFilter<"CampaignAnalysisReport"> | string | null
    createdAt?: DateTimeFilter<"CampaignAnalysisReport"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignAnalysisReportOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    totalQrScans?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    revenueGenerated?: SortOrder
    campaignSpend?: SortOrder
    roi?: SortOrder
    engagementRate?: SortOrder
    csatAverage?: SortOrder
    escalationRate?: SortOrder
    learningsSummary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignAnalysisReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignAnalysisReportWhereInput | CampaignAnalysisReportWhereInput[]
    OR?: CampaignAnalysisReportWhereInput[]
    NOT?: CampaignAnalysisReportWhereInput | CampaignAnalysisReportWhereInput[]
    campaignId?: StringFilter<"CampaignAnalysisReport"> | string
    totalImpressions?: IntFilter<"CampaignAnalysisReport"> | number
    totalClicks?: IntFilter<"CampaignAnalysisReport"> | number
    totalQrScans?: IntFilter<"CampaignAnalysisReport"> | number
    totalConversions?: IntFilter<"CampaignAnalysisReport"> | number
    conversionRate?: FloatFilter<"CampaignAnalysisReport"> | number
    revenueGenerated?: FloatFilter<"CampaignAnalysisReport"> | number
    campaignSpend?: FloatFilter<"CampaignAnalysisReport"> | number
    roi?: FloatFilter<"CampaignAnalysisReport"> | number
    engagementRate?: FloatFilter<"CampaignAnalysisReport"> | number
    csatAverage?: FloatFilter<"CampaignAnalysisReport"> | number
    escalationRate?: FloatFilter<"CampaignAnalysisReport"> | number
    learningsSummary?: StringNullableFilter<"CampaignAnalysisReport"> | string | null
    createdAt?: DateTimeFilter<"CampaignAnalysisReport"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignAnalysisReportOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    totalQrScans?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    revenueGenerated?: SortOrder
    campaignSpend?: SortOrder
    roi?: SortOrder
    engagementRate?: SortOrder
    csatAverage?: SortOrder
    escalationRate?: SortOrder
    learningsSummary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignAnalysisReportCountOrderByAggregateInput
    _avg?: CampaignAnalysisReportAvgOrderByAggregateInput
    _max?: CampaignAnalysisReportMaxOrderByAggregateInput
    _min?: CampaignAnalysisReportMinOrderByAggregateInput
    _sum?: CampaignAnalysisReportSumOrderByAggregateInput
  }

  export type CampaignAnalysisReportScalarWhereWithAggregatesInput = {
    AND?: CampaignAnalysisReportScalarWhereWithAggregatesInput | CampaignAnalysisReportScalarWhereWithAggregatesInput[]
    OR?: CampaignAnalysisReportScalarWhereWithAggregatesInput[]
    NOT?: CampaignAnalysisReportScalarWhereWithAggregatesInput | CampaignAnalysisReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignAnalysisReport"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignAnalysisReport"> | string
    totalImpressions?: IntWithAggregatesFilter<"CampaignAnalysisReport"> | number
    totalClicks?: IntWithAggregatesFilter<"CampaignAnalysisReport"> | number
    totalQrScans?: IntWithAggregatesFilter<"CampaignAnalysisReport"> | number
    totalConversions?: IntWithAggregatesFilter<"CampaignAnalysisReport"> | number
    conversionRate?: FloatWithAggregatesFilter<"CampaignAnalysisReport"> | number
    revenueGenerated?: FloatWithAggregatesFilter<"CampaignAnalysisReport"> | number
    campaignSpend?: FloatWithAggregatesFilter<"CampaignAnalysisReport"> | number
    roi?: FloatWithAggregatesFilter<"CampaignAnalysisReport"> | number
    engagementRate?: FloatWithAggregatesFilter<"CampaignAnalysisReport"> | number
    csatAverage?: FloatWithAggregatesFilter<"CampaignAnalysisReport"> | number
    escalationRate?: FloatWithAggregatesFilter<"CampaignAnalysisReport"> | number
    learningsSummary?: StringNullableWithAggregatesFilter<"CampaignAnalysisReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignAnalysisReport"> | Date | string
  }

  export type CampaignLearningsWhereInput = {
    AND?: CampaignLearningsWhereInput | CampaignLearningsWhereInput[]
    OR?: CampaignLearningsWhereInput[]
    NOT?: CampaignLearningsWhereInput | CampaignLearningsWhereInput[]
    id?: StringFilter<"CampaignLearnings"> | string
    campaignId?: StringFilter<"CampaignLearnings"> | string
    whatWorked?: StringFilter<"CampaignLearnings"> | string
    whatDidNotWork?: StringFilter<"CampaignLearnings"> | string
    bestPractices?: StringFilter<"CampaignLearnings"> | string
    improvementAreas?: StringFilter<"CampaignLearnings"> | string
    createdAt?: DateTimeFilter<"CampaignLearnings"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignLearningsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    whatWorked?: SortOrder
    whatDidNotWork?: SortOrder
    bestPractices?: SortOrder
    improvementAreas?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignLearningsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignLearningsWhereInput | CampaignLearningsWhereInput[]
    OR?: CampaignLearningsWhereInput[]
    NOT?: CampaignLearningsWhereInput | CampaignLearningsWhereInput[]
    campaignId?: StringFilter<"CampaignLearnings"> | string
    whatWorked?: StringFilter<"CampaignLearnings"> | string
    whatDidNotWork?: StringFilter<"CampaignLearnings"> | string
    bestPractices?: StringFilter<"CampaignLearnings"> | string
    improvementAreas?: StringFilter<"CampaignLearnings"> | string
    createdAt?: DateTimeFilter<"CampaignLearnings"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignLearningsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    whatWorked?: SortOrder
    whatDidNotWork?: SortOrder
    bestPractices?: SortOrder
    improvementAreas?: SortOrder
    createdAt?: SortOrder
    _count?: CampaignLearningsCountOrderByAggregateInput
    _max?: CampaignLearningsMaxOrderByAggregateInput
    _min?: CampaignLearningsMinOrderByAggregateInput
  }

  export type CampaignLearningsScalarWhereWithAggregatesInput = {
    AND?: CampaignLearningsScalarWhereWithAggregatesInput | CampaignLearningsScalarWhereWithAggregatesInput[]
    OR?: CampaignLearningsScalarWhereWithAggregatesInput[]
    NOT?: CampaignLearningsScalarWhereWithAggregatesInput | CampaignLearningsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignLearnings"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignLearnings"> | string
    whatWorked?: StringWithAggregatesFilter<"CampaignLearnings"> | string
    whatDidNotWork?: StringWithAggregatesFilter<"CampaignLearnings"> | string
    bestPractices?: StringWithAggregatesFilter<"CampaignLearnings"> | string
    improvementAreas?: StringWithAggregatesFilter<"CampaignLearnings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignLearnings"> | Date | string
  }

  export type InternalCampaignReportWhereInput = {
    AND?: InternalCampaignReportWhereInput | InternalCampaignReportWhereInput[]
    OR?: InternalCampaignReportWhereInput[]
    NOT?: InternalCampaignReportWhereInput | InternalCampaignReportWhereInput[]
    id?: StringFilter<"InternalCampaignReport"> | string
    campaignId?: StringFilter<"InternalCampaignReport"> | string
    reportTitle?: StringFilter<"InternalCampaignReport"> | string
    executiveSummary?: StringFilter<"InternalCampaignReport"> | string
    kpiHighlights?: StringFilter<"InternalCampaignReport"> | string
    learningHighlights?: StringFilter<"InternalCampaignReport"> | string
    improvementAreas?: StringFilter<"InternalCampaignReport"> | string
    graphsReference?: StringNullableFilter<"InternalCampaignReport"> | string | null
    createdAt?: DateTimeFilter<"InternalCampaignReport"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type InternalCampaignReportOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reportTitle?: SortOrder
    executiveSummary?: SortOrder
    kpiHighlights?: SortOrder
    learningHighlights?: SortOrder
    improvementAreas?: SortOrder
    graphsReference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type InternalCampaignReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InternalCampaignReportWhereInput | InternalCampaignReportWhereInput[]
    OR?: InternalCampaignReportWhereInput[]
    NOT?: InternalCampaignReportWhereInput | InternalCampaignReportWhereInput[]
    campaignId?: StringFilter<"InternalCampaignReport"> | string
    reportTitle?: StringFilter<"InternalCampaignReport"> | string
    executiveSummary?: StringFilter<"InternalCampaignReport"> | string
    kpiHighlights?: StringFilter<"InternalCampaignReport"> | string
    learningHighlights?: StringFilter<"InternalCampaignReport"> | string
    improvementAreas?: StringFilter<"InternalCampaignReport"> | string
    graphsReference?: StringNullableFilter<"InternalCampaignReport"> | string | null
    createdAt?: DateTimeFilter<"InternalCampaignReport"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type InternalCampaignReportOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reportTitle?: SortOrder
    executiveSummary?: SortOrder
    kpiHighlights?: SortOrder
    learningHighlights?: SortOrder
    improvementAreas?: SortOrder
    graphsReference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InternalCampaignReportCountOrderByAggregateInput
    _max?: InternalCampaignReportMaxOrderByAggregateInput
    _min?: InternalCampaignReportMinOrderByAggregateInput
  }

  export type InternalCampaignReportScalarWhereWithAggregatesInput = {
    AND?: InternalCampaignReportScalarWhereWithAggregatesInput | InternalCampaignReportScalarWhereWithAggregatesInput[]
    OR?: InternalCampaignReportScalarWhereWithAggregatesInput[]
    NOT?: InternalCampaignReportScalarWhereWithAggregatesInput | InternalCampaignReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InternalCampaignReport"> | string
    campaignId?: StringWithAggregatesFilter<"InternalCampaignReport"> | string
    reportTitle?: StringWithAggregatesFilter<"InternalCampaignReport"> | string
    executiveSummary?: StringWithAggregatesFilter<"InternalCampaignReport"> | string
    kpiHighlights?: StringWithAggregatesFilter<"InternalCampaignReport"> | string
    learningHighlights?: StringWithAggregatesFilter<"InternalCampaignReport"> | string
    improvementAreas?: StringWithAggregatesFilter<"InternalCampaignReport"> | string
    graphsReference?: StringNullableWithAggregatesFilter<"InternalCampaignReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InternalCampaignReport"> | Date | string
  }

  export type CompetitorStrategyCreateInput = {
    id?: string
    competitor: string
    promotionType: string
    channels: string
    strength: string
    weakness: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutCompetitorsInput
  }

  export type CompetitorStrategyUncheckedCreateInput = {
    id?: string
    campaignId: string
    competitor: string
    promotionType: string
    channels: string
    strength: string
    weakness: string
    createdAt?: Date | string
  }

  export type CompetitorStrategyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    competitor?: StringFieldUpdateOperationsInput | string
    promotionType?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    weakness?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutCompetitorsNestedInput
  }

  export type CompetitorStrategyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    competitor?: StringFieldUpdateOperationsInput | string
    promotionType?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    weakness?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorStrategyCreateManyInput = {
    id?: string
    campaignId: string
    competitor: string
    promotionType: string
    channels: string
    strength: string
    weakness: string
    createdAt?: Date | string
  }

  export type CompetitorStrategyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    competitor?: StringFieldUpdateOperationsInput | string
    promotionType?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    weakness?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorStrategyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    competitor?: StringFieldUpdateOperationsInput | string
    promotionType?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    weakness?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseContextCreateInput = {
    id?: string
    companyName: string
    domain: string
    businessModel: string
    background: string
    currentPain: string
    goals: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEnterpriseContextsInput
  }

  export type EnterpriseContextUncheckedCreateInput = {
    id?: string
    campaignId: string
    companyName: string
    domain: string
    businessModel: string
    background: string
    currentPain: string
    goals: string
    createdAt?: Date | string
  }

  export type EnterpriseContextUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    businessModel?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    currentPain?: StringFieldUpdateOperationsInput | string
    goals?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEnterpriseContextsNestedInput
  }

  export type EnterpriseContextUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    businessModel?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    currentPain?: StringFieldUpdateOperationsInput | string
    goals?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseContextCreateManyInput = {
    id?: string
    campaignId: string
    companyName: string
    domain: string
    businessModel: string
    background: string
    currentPain: string
    goals: string
    createdAt?: Date | string
  }

  export type EnterpriseContextUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    businessModel?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    currentPain?: StringFieldUpdateOperationsInput | string
    goals?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseContextUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    businessModel?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    currentPain?: StringFieldUpdateOperationsInput | string
    goals?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudienceSegmentCreateInput = {
    id?: string
    label: string
    demographics: string
    behavior: string
    painPoints: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutAudienceSegmentsInput
  }

  export type AudienceSegmentUncheckedCreateInput = {
    id?: string
    campaignId: string
    label: string
    demographics: string
    behavior: string
    painPoints: string
    createdAt?: Date | string
  }

  export type AudienceSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    demographics?: StringFieldUpdateOperationsInput | string
    behavior?: StringFieldUpdateOperationsInput | string
    painPoints?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutAudienceSegmentsNestedInput
  }

  export type AudienceSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    demographics?: StringFieldUpdateOperationsInput | string
    behavior?: StringFieldUpdateOperationsInput | string
    painPoints?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudienceSegmentCreateManyInput = {
    id?: string
    campaignId: string
    label: string
    demographics: string
    behavior: string
    painPoints: string
    createdAt?: Date | string
  }

  export type AudienceSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    demographics?: StringFieldUpdateOperationsInput | string
    behavior?: StringFieldUpdateOperationsInput | string
    painPoints?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudienceSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    demographics?: StringFieldUpdateOperationsInput | string
    behavior?: StringFieldUpdateOperationsInput | string
    painPoints?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignObjectiveCreateInput = {
    id?: string
    goal: string
    campaign: CampaignCreateNestedOneWithoutObjectivesInput
  }

  export type CampaignObjectiveUncheckedCreateInput = {
    id?: string
    campaignId: string
    goal: string
  }

  export type CampaignObjectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutObjectivesNestedInput
  }

  export type CampaignObjectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignObjectiveCreateManyInput = {
    id?: string
    campaignId: string
    goal: string
  }

  export type CampaignObjectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignObjectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type TargetAudienceSegmentCreateInput = {
    id?: string
    segment: string
    campaign: CampaignCreateNestedOneWithoutAudiencesInput
  }

  export type TargetAudienceSegmentUncheckedCreateInput = {
    id?: string
    campaignId: string
    segment: string
  }

  export type TargetAudienceSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutAudiencesNestedInput
  }

  export type TargetAudienceSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
  }

  export type TargetAudienceSegmentCreateManyInput = {
    id?: string
    campaignId: string
    segment: string
  }

  export type TargetAudienceSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
  }

  export type TargetAudienceSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionTypeCreateInput = {
    id?: string
    type: string
    campaign: CampaignCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionTypeUncheckedCreateInput = {
    id?: string
    campaignId: string
    type: string
  }

  export type PromotionTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutPromotionsNestedInput
  }

  export type PromotionTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionTypeCreateManyInput = {
    id?: string
    campaignId: string
    type: string
  }

  export type PromotionTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignOfferCreateInput = {
    id?: string
    description: string
    offerLimit?: number | null
    offerType?: string | null
    successCriteria?: string | null
    backupOffer?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutOffersInput
  }

  export type CampaignOfferUncheckedCreateInput = {
    id?: string
    campaignId: string
    description: string
    offerLimit?: number | null
    offerType?: string | null
    successCriteria?: string | null
    backupOffer?: string | null
    createdAt?: Date | string
  }

  export type CampaignOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    offerLimit?: NullableIntFieldUpdateOperationsInput | number | null
    offerType?: NullableStringFieldUpdateOperationsInput | string | null
    successCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    backupOffer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutOffersNestedInput
  }

  export type CampaignOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    offerLimit?: NullableIntFieldUpdateOperationsInput | number | null
    offerType?: NullableStringFieldUpdateOperationsInput | string | null
    successCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    backupOffer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOfferCreateManyInput = {
    id?: string
    campaignId: string
    description: string
    offerLimit?: number | null
    offerType?: string | null
    successCriteria?: string | null
    backupOffer?: string | null
    createdAt?: Date | string
  }

  export type CampaignOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    offerLimit?: NullableIntFieldUpdateOperationsInput | number | null
    offerType?: NullableStringFieldUpdateOperationsInput | string | null
    successCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    backupOffer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    offerLimit?: NullableIntFieldUpdateOperationsInput | number | null
    offerType?: NullableStringFieldUpdateOperationsInput | string | null
    successCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    backupOffer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignBudgetCreateInput = {
    id?: string
    mediaSpend: number
    creativeSpend: number
    incentiveSpend: number
    logisticsSpend: number
    totalBudget: number
    costPerCustomer: number
    expectedROI?: number | null
    notes?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutBudgetsInput
  }

  export type CampaignBudgetUncheckedCreateInput = {
    id?: string
    campaignId: string
    mediaSpend: number
    creativeSpend: number
    incentiveSpend: number
    logisticsSpend: number
    totalBudget: number
    costPerCustomer: number
    expectedROI?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CampaignBudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaSpend?: FloatFieldUpdateOperationsInput | number
    creativeSpend?: FloatFieldUpdateOperationsInput | number
    incentiveSpend?: FloatFieldUpdateOperationsInput | number
    logisticsSpend?: FloatFieldUpdateOperationsInput | number
    totalBudget?: FloatFieldUpdateOperationsInput | number
    costPerCustomer?: FloatFieldUpdateOperationsInput | number
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type CampaignBudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    mediaSpend?: FloatFieldUpdateOperationsInput | number
    creativeSpend?: FloatFieldUpdateOperationsInput | number
    incentiveSpend?: FloatFieldUpdateOperationsInput | number
    logisticsSpend?: FloatFieldUpdateOperationsInput | number
    totalBudget?: FloatFieldUpdateOperationsInput | number
    costPerCustomer?: FloatFieldUpdateOperationsInput | number
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignBudgetCreateManyInput = {
    id?: string
    campaignId: string
    mediaSpend: number
    creativeSpend: number
    incentiveSpend: number
    logisticsSpend: number
    totalBudget: number
    costPerCustomer: number
    expectedROI?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CampaignBudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaSpend?: FloatFieldUpdateOperationsInput | number
    creativeSpend?: FloatFieldUpdateOperationsInput | number
    incentiveSpend?: FloatFieldUpdateOperationsInput | number
    logisticsSpend?: FloatFieldUpdateOperationsInput | number
    totalBudget?: FloatFieldUpdateOperationsInput | number
    costPerCustomer?: FloatFieldUpdateOperationsInput | number
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignBudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    mediaSpend?: FloatFieldUpdateOperationsInput | number
    creativeSpend?: FloatFieldUpdateOperationsInput | number
    incentiveSpend?: FloatFieldUpdateOperationsInput | number
    logisticsSpend?: FloatFieldUpdateOperationsInput | number
    totalBudget?: FloatFieldUpdateOperationsInput | number
    costPerCustomer?: FloatFieldUpdateOperationsInput | number
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelPlanCreateInput = {
    id?: string
    channels?: ChannelPlanCreatechannelsInput | string[]
    primary: string
    primaryReason: string
    messageStyles?: ChannelPlanCreatemessageStylesInput | string[]
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutChannelsInput
  }

  export type ChannelPlanUncheckedCreateInput = {
    id?: string
    campaignId: string
    channels?: ChannelPlanCreatechannelsInput | string[]
    primary: string
    primaryReason: string
    messageStyles?: ChannelPlanCreatemessageStylesInput | string[]
    createdAt?: Date | string
  }

  export type ChannelPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: ChannelPlanUpdatechannelsInput | string[]
    primary?: StringFieldUpdateOperationsInput | string
    primaryReason?: StringFieldUpdateOperationsInput | string
    messageStyles?: ChannelPlanUpdatemessageStylesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutChannelsNestedInput
  }

  export type ChannelPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    channels?: ChannelPlanUpdatechannelsInput | string[]
    primary?: StringFieldUpdateOperationsInput | string
    primaryReason?: StringFieldUpdateOperationsInput | string
    messageStyles?: ChannelPlanUpdatemessageStylesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelPlanCreateManyInput = {
    id?: string
    campaignId: string
    channels?: ChannelPlanCreatechannelsInput | string[]
    primary: string
    primaryReason: string
    messageStyles?: ChannelPlanCreatemessageStylesInput | string[]
    createdAt?: Date | string
  }

  export type ChannelPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: ChannelPlanUpdatechannelsInput | string[]
    primary?: StringFieldUpdateOperationsInput | string
    primaryReason?: StringFieldUpdateOperationsInput | string
    messageStyles?: ChannelPlanUpdatemessageStylesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    channels?: ChannelPlanUpdatechannelsInput | string[]
    primary?: StringFieldUpdateOperationsInput | string
    primaryReason?: StringFieldUpdateOperationsInput | string
    messageStyles?: ChannelPlanUpdatemessageStylesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTimelineCreateInput = {
    id?: string
    milestoneName: string
    milestoneType: string
    plannedDate: Date | string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutTimelinesInput
  }

  export type CampaignTimelineUncheckedCreateInput = {
    id?: string
    campaignId: string
    milestoneName: string
    milestoneType: string
    plannedDate: Date | string
    createdAt?: Date | string
  }

  export type CampaignTimelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutTimelinesNestedInput
  }

  export type CampaignTimelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTimelineCreateManyInput = {
    id?: string
    campaignId: string
    milestoneName: string
    milestoneType: string
    plannedDate: Date | string
    createdAt?: Date | string
  }

  export type CampaignTimelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTimelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceChecklistCreateInput = {
    id?: string
    item: string
    severity: string
    responsibleDepartment: string
    status?: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutCompliancesInput
  }

  export type ComplianceChecklistUncheckedCreateInput = {
    id?: string
    campaignId: string
    item: string
    severity: string
    responsibleDepartment: string
    status?: string
    createdAt?: Date | string
  }

  export type ComplianceChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    responsibleDepartment?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutCompliancesNestedInput
  }

  export type ComplianceChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    responsibleDepartment?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceChecklistCreateManyInput = {
    id?: string
    campaignId: string
    item: string
    severity: string
    responsibleDepartment: string
    status?: string
    createdAt?: Date | string
  }

  export type ComplianceChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    responsibleDepartment?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    responsibleDepartment?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionalMessageCreateInput = {
    id?: string
    platform: string
    tone: string
    message: string
    callToAction: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMessagesInput
  }

  export type PromotionalMessageUncheckedCreateInput = {
    id?: string
    campaignId: string
    platform: string
    tone: string
    message: string
    callToAction: string
    createdAt?: Date | string
  }

  export type PromotionalMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    callToAction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type PromotionalMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    callToAction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionalMessageCreateManyInput = {
    id?: string
    campaignId: string
    platform: string
    tone: string
    message: string
    callToAction: string
    createdAt?: Date | string
  }

  export type PromotionalMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    callToAction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionalMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    callToAction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeDesignPlanCreateInput = {
    id?: string
    platform: string
    creativeTitle: string
    headline: string
    visualTheme: string
    cta: string
    mobileOptimizationTip: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutCreativePlansInput
  }

  export type CreativeDesignPlanUncheckedCreateInput = {
    id?: string
    campaignId: string
    platform: string
    creativeTitle: string
    headline: string
    visualTheme: string
    cta: string
    mobileOptimizationTip: string
    createdAt?: Date | string
  }

  export type CreativeDesignPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    creativeTitle?: StringFieldUpdateOperationsInput | string
    headline?: StringFieldUpdateOperationsInput | string
    visualTheme?: StringFieldUpdateOperationsInput | string
    cta?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutCreativePlansNestedInput
  }

  export type CreativeDesignPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    creativeTitle?: StringFieldUpdateOperationsInput | string
    headline?: StringFieldUpdateOperationsInput | string
    visualTheme?: StringFieldUpdateOperationsInput | string
    cta?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeDesignPlanCreateManyInput = {
    id?: string
    campaignId: string
    platform: string
    creativeTitle: string
    headline: string
    visualTheme: string
    cta: string
    mobileOptimizationTip: string
    createdAt?: Date | string
  }

  export type CreativeDesignPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    creativeTitle?: StringFieldUpdateOperationsInput | string
    headline?: StringFieldUpdateOperationsInput | string
    visualTheme?: StringFieldUpdateOperationsInput | string
    cta?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeDesignPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    creativeTitle?: StringFieldUpdateOperationsInput | string
    headline?: StringFieldUpdateOperationsInput | string
    visualTheme?: StringFieldUpdateOperationsInput | string
    cta?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeAssetCreateInput = {
    id?: string
    type: string
    assetUrl: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutCreativesInput
  }

  export type CreativeAssetUncheckedCreateInput = {
    id?: string
    campaignId: string
    type: string
    assetUrl: string
    createdAt?: Date | string
  }

  export type CreativeAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    assetUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutCreativesNestedInput
  }

  export type CreativeAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    assetUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeAssetCreateManyInput = {
    id?: string
    campaignId: string
    type: string
    assetUrl: string
    createdAt?: Date | string
  }

  export type CreativeAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    assetUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    assetUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetCreateInput = {
    id?: string
    type: string
    title: string
    concept: string
    engagementTip: string
    mobileOptimizationTip: string
    url?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMediaAssetsInput
  }

  export type MediaAssetUncheckedCreateInput = {
    id?: string
    campaignId: string
    type: string
    title: string
    concept: string
    engagementTip: string
    mobileOptimizationTip: string
    url?: string | null
    createdAt?: Date | string
  }

  export type MediaAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    concept?: StringFieldUpdateOperationsInput | string
    engagementTip?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMediaAssetsNestedInput
  }

  export type MediaAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    concept?: StringFieldUpdateOperationsInput | string
    engagementTip?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetCreateManyInput = {
    id?: string
    campaignId: string
    type: string
    title: string
    concept: string
    engagementTip: string
    mobileOptimizationTip: string
    url?: string | null
    createdAt?: Date | string
  }

  export type MediaAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    concept?: StringFieldUpdateOperationsInput | string
    engagementTip?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    concept?: StringFieldUpdateOperationsInput | string
    engagementTip?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCalendarCreateInput = {
    id?: string
    contentType: string
    platform: string
    contentRef: string
    scheduledFor: Date | string
    notes?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutCalendarsInput
  }

  export type ContentCalendarUncheckedCreateInput = {
    id?: string
    campaignId: string
    contentType: string
    platform: string
    contentRef: string
    scheduledFor: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ContentCalendarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    contentRef?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutCalendarsNestedInput
  }

  export type ContentCalendarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    contentRef?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCalendarCreateManyInput = {
    id?: string
    campaignId: string
    contentType: string
    platform: string
    contentRef: string
    scheduledFor: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ContentCalendarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    contentRef?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCalendarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    contentRef?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeaserContentCreateInput = {
    id?: string
    message: string
    platform: string
    teaserTheme?: string | null
    tone: string
    scheduledAt: Date | string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutTeasersInput
  }

  export type TeaserContentUncheckedCreateInput = {
    id?: string
    campaignId: string
    message: string
    platform: string
    teaserTheme?: string | null
    tone: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type TeaserContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    teaserTheme?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutTeasersNestedInput
  }

  export type TeaserContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    teaserTheme?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeaserContentCreateManyInput = {
    id?: string
    campaignId: string
    message: string
    platform: string
    teaserTheme?: string | null
    tone: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type TeaserContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    teaserTheme?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeaserContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    teaserTheme?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSegmentListCreateInput = {
    id?: string
    segment: string
    criteria: string
    count: number
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutCustomersInput
  }

  export type CustomerSegmentListUncheckedCreateInput = {
    id?: string
    campaignId: string
    segment: string
    criteria: string
    count: number
    createdAt?: Date | string
  }

  export type CustomerSegmentListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutCustomersNestedInput
  }

  export type CustomerSegmentListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSegmentListCreateManyInput = {
    id?: string
    campaignId: string
    segment: string
    criteria: string
    count: number
    createdAt?: Date | string
  }

  export type CustomerSegmentListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSegmentListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerPlanCreateInput = {
    id?: string
    influencerName: string
    platform: string
    postType: string
    expectedImpact?: string | null
    scheduledAt: Date | string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutInfluencersInput
  }

  export type InfluencerPlanUncheckedCreateInput = {
    id?: string
    campaignId: string
    influencerName: string
    platform: string
    postType: string
    expectedImpact?: string | null
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type InfluencerPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    influencerName?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    expectedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutInfluencersNestedInput
  }

  export type InfluencerPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    influencerName?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    expectedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerPlanCreateManyInput = {
    id?: string
    campaignId: string
    influencerName: string
    platform: string
    postType: string
    expectedImpact?: string | null
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type InfluencerPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    influencerName?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    expectedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    influencerName?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    expectedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationalChecklistCreateInput = {
    id?: string
    system: string
    checklistItem: string
    expectedOutcome: string
    responsibility: string
    status: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutChecklistsInput
  }

  export type OperationalChecklistUncheckedCreateInput = {
    id?: string
    campaignId: string
    system: string
    checklistItem: string
    expectedOutcome: string
    responsibility: string
    status: string
    createdAt?: Date | string
  }

  export type OperationalChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    checklistItem?: StringFieldUpdateOperationsInput | string
    expectedOutcome?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutChecklistsNestedInput
  }

  export type OperationalChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    checklistItem?: StringFieldUpdateOperationsInput | string
    expectedOutcome?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationalChecklistCreateManyInput = {
    id?: string
    campaignId: string
    system: string
    checklistItem: string
    expectedOutcome: string
    responsibility: string
    status: string
    createdAt?: Date | string
  }

  export type OperationalChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    checklistItem?: StringFieldUpdateOperationsInput | string
    expectedOutcome?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationalChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    checklistItem?: StringFieldUpdateOperationsInput | string
    expectedOutcome?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivationCreateInput = {
    id?: string
    platform: string
    assetType: string
    assetReference: string
    activationTime: Date | string
    status: string
    activationResult: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutActivationsInput
  }

  export type CampaignActivationUncheckedCreateInput = {
    id?: string
    campaignId: string
    platform: string
    assetType: string
    assetReference: string
    activationTime: Date | string
    status: string
    activationResult: string
    createdAt?: Date | string
  }

  export type CampaignActivationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    assetType?: StringFieldUpdateOperationsInput | string
    assetReference?: StringFieldUpdateOperationsInput | string
    activationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    activationResult?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutActivationsNestedInput
  }

  export type CampaignActivationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    assetType?: StringFieldUpdateOperationsInput | string
    assetReference?: StringFieldUpdateOperationsInput | string
    activationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    activationResult?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivationCreateManyInput = {
    id?: string
    campaignId: string
    platform: string
    assetType: string
    assetReference: string
    activationTime: Date | string
    status: string
    activationResult: string
    createdAt?: Date | string
  }

  export type CampaignActivationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    assetType?: StringFieldUpdateOperationsInput | string
    assetReference?: StringFieldUpdateOperationsInput | string
    activationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    activationResult?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    assetType?: StringFieldUpdateOperationsInput | string
    assetReference?: StringFieldUpdateOperationsInput | string
    activationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    activationResult?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerEngagementLogCreateInput = {
    id?: string
    userId: string
    sessionId: string
    interactionType: string
    message: string
    resolutionStatus: string
    responseTime: number
    csatScore?: number | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEngagementsInput
  }

  export type CustomerEngagementLogUncheckedCreateInput = {
    id?: string
    campaignId: string
    userId: string
    sessionId: string
    interactionType: string
    message: string
    resolutionStatus: string
    responseTime: number
    csatScore?: number | null
    createdAt?: Date | string
  }

  export type CustomerEngagementLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolutionStatus?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    csatScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEngagementsNestedInput
  }

  export type CustomerEngagementLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolutionStatus?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    csatScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerEngagementLogCreateManyInput = {
    id?: string
    campaignId: string
    userId: string
    sessionId: string
    interactionType: string
    message: string
    resolutionStatus: string
    responseTime: number
    csatScore?: number | null
    createdAt?: Date | string
  }

  export type CustomerEngagementLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolutionStatus?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    csatScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerEngagementLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolutionStatus?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    csatScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReportCreateInput = {
    id?: string
    date: Date | string
    impressions: number
    clicks: number
    qrScans: number
    conversions: number
    chatbotSessions: number
    escalations: number
    escalationRate: number
    avgBotResponseTime: number
    avgHumanResponseTime: number
    csatScoreAverage: number
    anomalies?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutReportsInput
  }

  export type PerformanceReportUncheckedCreateInput = {
    id?: string
    campaignId: string
    date: Date | string
    impressions: number
    clicks: number
    qrScans: number
    conversions: number
    chatbotSessions: number
    escalations: number
    escalationRate: number
    avgBotResponseTime: number
    avgHumanResponseTime: number
    csatScoreAverage: number
    anomalies?: string | null
    createdAt?: Date | string
  }

  export type PerformanceReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    qrScans?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    chatbotSessions?: IntFieldUpdateOperationsInput | number
    escalations?: IntFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    avgBotResponseTime?: IntFieldUpdateOperationsInput | number
    avgHumanResponseTime?: IntFieldUpdateOperationsInput | number
    csatScoreAverage?: FloatFieldUpdateOperationsInput | number
    anomalies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutReportsNestedInput
  }

  export type PerformanceReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    qrScans?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    chatbotSessions?: IntFieldUpdateOperationsInput | number
    escalations?: IntFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    avgBotResponseTime?: IntFieldUpdateOperationsInput | number
    avgHumanResponseTime?: IntFieldUpdateOperationsInput | number
    csatScoreAverage?: FloatFieldUpdateOperationsInput | number
    anomalies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReportCreateManyInput = {
    id?: string
    campaignId: string
    date: Date | string
    impressions: number
    clicks: number
    qrScans: number
    conversions: number
    chatbotSessions: number
    escalations: number
    escalationRate: number
    avgBotResponseTime: number
    avgHumanResponseTime: number
    csatScoreAverage: number
    anomalies?: string | null
    createdAt?: Date | string
  }

  export type PerformanceReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    qrScans?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    chatbotSessions?: IntFieldUpdateOperationsInput | number
    escalations?: IntFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    avgBotResponseTime?: IntFieldUpdateOperationsInput | number
    avgHumanResponseTime?: IntFieldUpdateOperationsInput | number
    csatScoreAverage?: FloatFieldUpdateOperationsInput | number
    anomalies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    qrScans?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    chatbotSessions?: IntFieldUpdateOperationsInput | number
    escalations?: IntFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    avgBotResponseTime?: IntFieldUpdateOperationsInput | number
    avgHumanResponseTime?: IntFieldUpdateOperationsInput | number
    csatScoreAverage?: FloatFieldUpdateOperationsInput | number
    anomalies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFeedbackCreateInput = {
    id?: string
    userId: string
    interactionId?: string | null
    feedbackText: string
    rating: number
    collectedVia: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutFeedbacksInput
  }

  export type CustomerFeedbackUncheckedCreateInput = {
    id?: string
    campaignId: string
    userId: string
    interactionId?: string | null
    feedbackText: string
    rating: number
    collectedVia: string
    createdAt?: Date | string
  }

  export type CustomerFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackText?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    collectedVia?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type CustomerFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackText?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    collectedVia?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFeedbackCreateManyInput = {
    id?: string
    campaignId: string
    userId: string
    interactionId?: string | null
    feedbackText: string
    rating: number
    collectedVia: string
    createdAt?: Date | string
  }

  export type CustomerFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackText?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    collectedVia?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackText?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    collectedVia?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThankYouMessageCreateInput = {
    id?: string
    userId: string
    messageBody: string
    sentVia: string
    segment: string
    sentAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutThanksInput
  }

  export type ThankYouMessageUncheckedCreateInput = {
    id?: string
    campaignId: string
    userId: string
    messageBody: string
    sentVia: string
    segment: string
    sentAt?: Date | string
  }

  export type ThankYouMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageBody?: StringFieldUpdateOperationsInput | string
    sentVia?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutThanksNestedInput
  }

  export type ThankYouMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageBody?: StringFieldUpdateOperationsInput | string
    sentVia?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThankYouMessageCreateManyInput = {
    id?: string
    campaignId: string
    userId: string
    messageBody: string
    sentVia: string
    segment: string
    sentAt?: Date | string
  }

  export type ThankYouMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageBody?: StringFieldUpdateOperationsInput | string
    sentVia?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThankYouMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageBody?: StringFieldUpdateOperationsInput | string
    sentVia?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetargetingPlanCreateInput = {
    id?: string
    audienceSegment: string
    retargetingChannel: string
    offerMessage: string
    scheduledAt: Date | string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutRetargetingsInput
  }

  export type RetargetingPlanUncheckedCreateInput = {
    id?: string
    campaignId: string
    audienceSegment: string
    retargetingChannel: string
    offerMessage: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type RetargetingPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    audienceSegment?: StringFieldUpdateOperationsInput | string
    retargetingChannel?: StringFieldUpdateOperationsInput | string
    offerMessage?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutRetargetingsNestedInput
  }

  export type RetargetingPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    audienceSegment?: StringFieldUpdateOperationsInput | string
    retargetingChannel?: StringFieldUpdateOperationsInput | string
    offerMessage?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetargetingPlanCreateManyInput = {
    id?: string
    campaignId: string
    audienceSegment: string
    retargetingChannel: string
    offerMessage: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type RetargetingPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    audienceSegment?: StringFieldUpdateOperationsInput | string
    retargetingChannel?: StringFieldUpdateOperationsInput | string
    offerMessage?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetargetingPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    audienceSegment?: StringFieldUpdateOperationsInput | string
    retargetingChannel?: StringFieldUpdateOperationsInput | string
    offerMessage?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignExtensionPlanCreateInput = {
    id?: string
    reason: string
    extendedTo: Date | string
    details: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutExtensionsInput
  }

  export type CampaignExtensionPlanUncheckedCreateInput = {
    id?: string
    campaignId: string
    reason: string
    extendedTo: Date | string
    details: string
    createdAt?: Date | string
  }

  export type CampaignExtensionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    extendedTo?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutExtensionsNestedInput
  }

  export type CampaignExtensionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    extendedTo?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignExtensionPlanCreateManyInput = {
    id?: string
    campaignId: string
    reason: string
    extendedTo: Date | string
    details: string
    createdAt?: Date | string
  }

  export type CampaignExtensionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    extendedTo?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignExtensionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    extendedTo?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalysisReportCreateInput = {
    id?: string
    totalImpressions: number
    totalClicks: number
    totalQrScans: number
    totalConversions: number
    conversionRate: number
    revenueGenerated: number
    campaignSpend: number
    roi: number
    engagementRate: number
    csatAverage: number
    escalationRate: number
    learningsSummary?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutAnalysisReportsInput
  }

  export type CampaignAnalysisReportUncheckedCreateInput = {
    id?: string
    campaignId: string
    totalImpressions: number
    totalClicks: number
    totalQrScans: number
    totalConversions: number
    conversionRate: number
    revenueGenerated: number
    campaignSpend: number
    roi: number
    engagementRate: number
    csatAverage: number
    escalationRate: number
    learningsSummary?: string | null
    createdAt?: Date | string
  }

  export type CampaignAnalysisReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalImpressions?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalQrScans?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    campaignSpend?: FloatFieldUpdateOperationsInput | number
    roi?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    csatAverage?: FloatFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    learningsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutAnalysisReportsNestedInput
  }

  export type CampaignAnalysisReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    totalImpressions?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalQrScans?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    campaignSpend?: FloatFieldUpdateOperationsInput | number
    roi?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    csatAverage?: FloatFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    learningsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalysisReportCreateManyInput = {
    id?: string
    campaignId: string
    totalImpressions: number
    totalClicks: number
    totalQrScans: number
    totalConversions: number
    conversionRate: number
    revenueGenerated: number
    campaignSpend: number
    roi: number
    engagementRate: number
    csatAverage: number
    escalationRate: number
    learningsSummary?: string | null
    createdAt?: Date | string
  }

  export type CampaignAnalysisReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalImpressions?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalQrScans?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    campaignSpend?: FloatFieldUpdateOperationsInput | number
    roi?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    csatAverage?: FloatFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    learningsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalysisReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    totalImpressions?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalQrScans?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    campaignSpend?: FloatFieldUpdateOperationsInput | number
    roi?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    csatAverage?: FloatFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    learningsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLearningsCreateInput = {
    id?: string
    whatWorked: string
    whatDidNotWork: string
    bestPractices: string
    improvementAreas: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLearningsInput
  }

  export type CampaignLearningsUncheckedCreateInput = {
    id?: string
    campaignId: string
    whatWorked: string
    whatDidNotWork: string
    bestPractices: string
    improvementAreas: string
    createdAt?: Date | string
  }

  export type CampaignLearningsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatWorked?: StringFieldUpdateOperationsInput | string
    whatDidNotWork?: StringFieldUpdateOperationsInput | string
    bestPractices?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLearningsNestedInput
  }

  export type CampaignLearningsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    whatWorked?: StringFieldUpdateOperationsInput | string
    whatDidNotWork?: StringFieldUpdateOperationsInput | string
    bestPractices?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLearningsCreateManyInput = {
    id?: string
    campaignId: string
    whatWorked: string
    whatDidNotWork: string
    bestPractices: string
    improvementAreas: string
    createdAt?: Date | string
  }

  export type CampaignLearningsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatWorked?: StringFieldUpdateOperationsInput | string
    whatDidNotWork?: StringFieldUpdateOperationsInput | string
    bestPractices?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLearningsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    whatWorked?: StringFieldUpdateOperationsInput | string
    whatDidNotWork?: StringFieldUpdateOperationsInput | string
    bestPractices?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalCampaignReportCreateInput = {
    id?: string
    reportTitle: string
    executiveSummary: string
    kpiHighlights: string
    learningHighlights: string
    improvementAreas: string
    graphsReference?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutInternalReportsInput
  }

  export type InternalCampaignReportUncheckedCreateInput = {
    id?: string
    campaignId: string
    reportTitle: string
    executiveSummary: string
    kpiHighlights: string
    learningHighlights: string
    improvementAreas: string
    graphsReference?: string | null
    createdAt?: Date | string
  }

  export type InternalCampaignReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportTitle?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    kpiHighlights?: StringFieldUpdateOperationsInput | string
    learningHighlights?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    graphsReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutInternalReportsNestedInput
  }

  export type InternalCampaignReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    reportTitle?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    kpiHighlights?: StringFieldUpdateOperationsInput | string
    learningHighlights?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    graphsReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalCampaignReportCreateManyInput = {
    id?: string
    campaignId: string
    reportTitle: string
    executiveSummary: string
    kpiHighlights: string
    learningHighlights: string
    improvementAreas: string
    graphsReference?: string | null
    createdAt?: Date | string
  }

  export type InternalCampaignReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportTitle?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    kpiHighlights?: StringFieldUpdateOperationsInput | string
    learningHighlights?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    graphsReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalCampaignReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    reportTitle?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    kpiHighlights?: StringFieldUpdateOperationsInput | string
    learningHighlights?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    graphsReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CompetitorStrategyCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    competitor?: SortOrder
    promotionType?: SortOrder
    channels?: SortOrder
    strength?: SortOrder
    weakness?: SortOrder
    createdAt?: SortOrder
  }

  export type CompetitorStrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    competitor?: SortOrder
    promotionType?: SortOrder
    channels?: SortOrder
    strength?: SortOrder
    weakness?: SortOrder
    createdAt?: SortOrder
  }

  export type CompetitorStrategyMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    competitor?: SortOrder
    promotionType?: SortOrder
    channels?: SortOrder
    strength?: SortOrder
    weakness?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnterpriseContextCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    companyName?: SortOrder
    domain?: SortOrder
    businessModel?: SortOrder
    background?: SortOrder
    currentPain?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
  }

  export type EnterpriseContextMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    companyName?: SortOrder
    domain?: SortOrder
    businessModel?: SortOrder
    background?: SortOrder
    currentPain?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
  }

  export type EnterpriseContextMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    companyName?: SortOrder
    domain?: SortOrder
    businessModel?: SortOrder
    background?: SortOrder
    currentPain?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
  }

  export type AudienceSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    label?: SortOrder
    demographics?: SortOrder
    behavior?: SortOrder
    painPoints?: SortOrder
    createdAt?: SortOrder
  }

  export type AudienceSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    label?: SortOrder
    demographics?: SortOrder
    behavior?: SortOrder
    painPoints?: SortOrder
    createdAt?: SortOrder
  }

  export type AudienceSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    label?: SortOrder
    demographics?: SortOrder
    behavior?: SortOrder
    painPoints?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnterpriseContextListRelationFilter = {
    every?: EnterpriseContextWhereInput
    some?: EnterpriseContextWhereInput
    none?: EnterpriseContextWhereInput
  }

  export type AudienceSegmentListRelationFilter = {
    every?: AudienceSegmentWhereInput
    some?: AudienceSegmentWhereInput
    none?: AudienceSegmentWhereInput
  }

  export type CreativeDesignPlanListRelationFilter = {
    every?: CreativeDesignPlanWhereInput
    some?: CreativeDesignPlanWhereInput
    none?: CreativeDesignPlanWhereInput
  }

  export type CampaignObjectiveListRelationFilter = {
    every?: CampaignObjectiveWhereInput
    some?: CampaignObjectiveWhereInput
    none?: CampaignObjectiveWhereInput
  }

  export type TargetAudienceSegmentListRelationFilter = {
    every?: TargetAudienceSegmentWhereInput
    some?: TargetAudienceSegmentWhereInput
    none?: TargetAudienceSegmentWhereInput
  }

  export type CompetitorStrategyListRelationFilter = {
    every?: CompetitorStrategyWhereInput
    some?: CompetitorStrategyWhereInput
    none?: CompetitorStrategyWhereInput
  }

  export type PromotionTypeListRelationFilter = {
    every?: PromotionTypeWhereInput
    some?: PromotionTypeWhereInput
    none?: PromotionTypeWhereInput
  }

  export type CampaignOfferListRelationFilter = {
    every?: CampaignOfferWhereInput
    some?: CampaignOfferWhereInput
    none?: CampaignOfferWhereInput
  }

  export type CampaignBudgetListRelationFilter = {
    every?: CampaignBudgetWhereInput
    some?: CampaignBudgetWhereInput
    none?: CampaignBudgetWhereInput
  }

  export type ChannelPlanListRelationFilter = {
    every?: ChannelPlanWhereInput
    some?: ChannelPlanWhereInput
    none?: ChannelPlanWhereInput
  }

  export type CampaignTimelineListRelationFilter = {
    every?: CampaignTimelineWhereInput
    some?: CampaignTimelineWhereInput
    none?: CampaignTimelineWhereInput
  }

  export type ComplianceChecklistListRelationFilter = {
    every?: ComplianceChecklistWhereInput
    some?: ComplianceChecklistWhereInput
    none?: ComplianceChecklistWhereInput
  }

  export type CreativeAssetListRelationFilter = {
    every?: CreativeAssetWhereInput
    some?: CreativeAssetWhereInput
    none?: CreativeAssetWhereInput
  }

  export type PromotionalMessageListRelationFilter = {
    every?: PromotionalMessageWhereInput
    some?: PromotionalMessageWhereInput
    none?: PromotionalMessageWhereInput
  }

  export type MediaAssetListRelationFilter = {
    every?: MediaAssetWhereInput
    some?: MediaAssetWhereInput
    none?: MediaAssetWhereInput
  }

  export type ContentCalendarListRelationFilter = {
    every?: ContentCalendarWhereInput
    some?: ContentCalendarWhereInput
    none?: ContentCalendarWhereInput
  }

  export type TeaserContentListRelationFilter = {
    every?: TeaserContentWhereInput
    some?: TeaserContentWhereInput
    none?: TeaserContentWhereInput
  }

  export type CustomerSegmentListListRelationFilter = {
    every?: CustomerSegmentListWhereInput
    some?: CustomerSegmentListWhereInput
    none?: CustomerSegmentListWhereInput
  }

  export type InfluencerPlanListRelationFilter = {
    every?: InfluencerPlanWhereInput
    some?: InfluencerPlanWhereInput
    none?: InfluencerPlanWhereInput
  }

  export type OperationalChecklistListRelationFilter = {
    every?: OperationalChecklistWhereInput
    some?: OperationalChecklistWhereInput
    none?: OperationalChecklistWhereInput
  }

  export type CampaignActivationListRelationFilter = {
    every?: CampaignActivationWhereInput
    some?: CampaignActivationWhereInput
    none?: CampaignActivationWhereInput
  }

  export type CustomerEngagementLogListRelationFilter = {
    every?: CustomerEngagementLogWhereInput
    some?: CustomerEngagementLogWhereInput
    none?: CustomerEngagementLogWhereInput
  }

  export type PerformanceReportListRelationFilter = {
    every?: PerformanceReportWhereInput
    some?: PerformanceReportWhereInput
    none?: PerformanceReportWhereInput
  }

  export type CustomerFeedbackListRelationFilter = {
    every?: CustomerFeedbackWhereInput
    some?: CustomerFeedbackWhereInput
    none?: CustomerFeedbackWhereInput
  }

  export type ThankYouMessageListRelationFilter = {
    every?: ThankYouMessageWhereInput
    some?: ThankYouMessageWhereInput
    none?: ThankYouMessageWhereInput
  }

  export type RetargetingPlanListRelationFilter = {
    every?: RetargetingPlanWhereInput
    some?: RetargetingPlanWhereInput
    none?: RetargetingPlanWhereInput
  }

  export type CampaignExtensionPlanListRelationFilter = {
    every?: CampaignExtensionPlanWhereInput
    some?: CampaignExtensionPlanWhereInput
    none?: CampaignExtensionPlanWhereInput
  }

  export type CampaignAnalysisReportListRelationFilter = {
    every?: CampaignAnalysisReportWhereInput
    some?: CampaignAnalysisReportWhereInput
    none?: CampaignAnalysisReportWhereInput
  }

  export type CampaignLearningsListRelationFilter = {
    every?: CampaignLearningsWhereInput
    some?: CampaignLearningsWhereInput
    none?: CampaignLearningsWhereInput
  }

  export type InternalCampaignReportListRelationFilter = {
    every?: InternalCampaignReportWhereInput
    some?: InternalCampaignReportWhereInput
    none?: InternalCampaignReportWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EnterpriseContextOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudienceSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreativeDesignPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TargetAudienceSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompetitorStrategyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignBudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignTimelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplianceChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreativeAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionalMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentCalendarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeaserContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerSegmentListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InfluencerPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationalChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignActivationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerEngagementLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThankYouMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RetargetingPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignExtensionPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignAnalysisReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignLearningsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InternalCampaignReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CampaignObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    goal?: SortOrder
  }

  export type CampaignObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    goal?: SortOrder
  }

  export type CampaignObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    goal?: SortOrder
  }

  export type TargetAudienceSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
  }

  export type TargetAudienceSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
  }

  export type TargetAudienceSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
  }

  export type PromotionTypeCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
  }

  export type PromotionTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
  }

  export type PromotionTypeMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CampaignOfferCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    description?: SortOrder
    offerLimit?: SortOrder
    offerType?: SortOrder
    successCriteria?: SortOrder
    backupOffer?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignOfferAvgOrderByAggregateInput = {
    offerLimit?: SortOrder
  }

  export type CampaignOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    description?: SortOrder
    offerLimit?: SortOrder
    offerType?: SortOrder
    successCriteria?: SortOrder
    backupOffer?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignOfferMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    description?: SortOrder
    offerLimit?: SortOrder
    offerType?: SortOrder
    successCriteria?: SortOrder
    backupOffer?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignOfferSumOrderByAggregateInput = {
    offerLimit?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CampaignBudgetCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mediaSpend?: SortOrder
    creativeSpend?: SortOrder
    incentiveSpend?: SortOrder
    logisticsSpend?: SortOrder
    totalBudget?: SortOrder
    costPerCustomer?: SortOrder
    expectedROI?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignBudgetAvgOrderByAggregateInput = {
    mediaSpend?: SortOrder
    creativeSpend?: SortOrder
    incentiveSpend?: SortOrder
    logisticsSpend?: SortOrder
    totalBudget?: SortOrder
    costPerCustomer?: SortOrder
    expectedROI?: SortOrder
  }

  export type CampaignBudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mediaSpend?: SortOrder
    creativeSpend?: SortOrder
    incentiveSpend?: SortOrder
    logisticsSpend?: SortOrder
    totalBudget?: SortOrder
    costPerCustomer?: SortOrder
    expectedROI?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignBudgetMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mediaSpend?: SortOrder
    creativeSpend?: SortOrder
    incentiveSpend?: SortOrder
    logisticsSpend?: SortOrder
    totalBudget?: SortOrder
    costPerCustomer?: SortOrder
    expectedROI?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignBudgetSumOrderByAggregateInput = {
    mediaSpend?: SortOrder
    creativeSpend?: SortOrder
    incentiveSpend?: SortOrder
    logisticsSpend?: SortOrder
    totalBudget?: SortOrder
    costPerCustomer?: SortOrder
    expectedROI?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ChannelPlanCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    channels?: SortOrder
    primary?: SortOrder
    primaryReason?: SortOrder
    messageStyles?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    primary?: SortOrder
    primaryReason?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelPlanMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    primary?: SortOrder
    primaryReason?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignTimelineCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    milestoneName?: SortOrder
    milestoneType?: SortOrder
    plannedDate?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignTimelineMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    milestoneName?: SortOrder
    milestoneType?: SortOrder
    plannedDate?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignTimelineMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    milestoneName?: SortOrder
    milestoneType?: SortOrder
    plannedDate?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplianceChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    item?: SortOrder
    severity?: SortOrder
    responsibleDepartment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplianceChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    item?: SortOrder
    severity?: SortOrder
    responsibleDepartment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplianceChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    item?: SortOrder
    severity?: SortOrder
    responsibleDepartment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionalMessageCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    tone?: SortOrder
    message?: SortOrder
    callToAction?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionalMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    tone?: SortOrder
    message?: SortOrder
    callToAction?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionalMessageMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    tone?: SortOrder
    message?: SortOrder
    callToAction?: SortOrder
    createdAt?: SortOrder
  }

  export type CreativeDesignPlanCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    creativeTitle?: SortOrder
    headline?: SortOrder
    visualTheme?: SortOrder
    cta?: SortOrder
    mobileOptimizationTip?: SortOrder
    createdAt?: SortOrder
  }

  export type CreativeDesignPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    creativeTitle?: SortOrder
    headline?: SortOrder
    visualTheme?: SortOrder
    cta?: SortOrder
    mobileOptimizationTip?: SortOrder
    createdAt?: SortOrder
  }

  export type CreativeDesignPlanMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    creativeTitle?: SortOrder
    headline?: SortOrder
    visualTheme?: SortOrder
    cta?: SortOrder
    mobileOptimizationTip?: SortOrder
    createdAt?: SortOrder
  }

  export type CreativeAssetCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    assetUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CreativeAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    assetUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CreativeAssetMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    assetUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaAssetCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    concept?: SortOrder
    engagementTip?: SortOrder
    mobileOptimizationTip?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    concept?: SortOrder
    engagementTip?: SortOrder
    mobileOptimizationTip?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaAssetMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    concept?: SortOrder
    engagementTip?: SortOrder
    mobileOptimizationTip?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentCalendarCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contentType?: SortOrder
    platform?: SortOrder
    contentRef?: SortOrder
    scheduledFor?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentCalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contentType?: SortOrder
    platform?: SortOrder
    contentRef?: SortOrder
    scheduledFor?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentCalendarMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    contentType?: SortOrder
    platform?: SortOrder
    contentRef?: SortOrder
    scheduledFor?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type TeaserContentCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    message?: SortOrder
    platform?: SortOrder
    teaserTheme?: SortOrder
    tone?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TeaserContentMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    message?: SortOrder
    platform?: SortOrder
    teaserTheme?: SortOrder
    tone?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TeaserContentMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    message?: SortOrder
    platform?: SortOrder
    teaserTheme?: SortOrder
    tone?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CustomerSegmentListCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
    criteria?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerSegmentListAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type CustomerSegmentListMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
    criteria?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerSegmentListMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    segment?: SortOrder
    criteria?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerSegmentListSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type InfluencerPlanCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    influencerName?: SortOrder
    platform?: SortOrder
    postType?: SortOrder
    expectedImpact?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InfluencerPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    influencerName?: SortOrder
    platform?: SortOrder
    postType?: SortOrder
    expectedImpact?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InfluencerPlanMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    influencerName?: SortOrder
    platform?: SortOrder
    postType?: SortOrder
    expectedImpact?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationalChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    system?: SortOrder
    checklistItem?: SortOrder
    expectedOutcome?: SortOrder
    responsibility?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationalChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    system?: SortOrder
    checklistItem?: SortOrder
    expectedOutcome?: SortOrder
    responsibility?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationalChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    system?: SortOrder
    checklistItem?: SortOrder
    expectedOutcome?: SortOrder
    responsibility?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignActivationCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    assetType?: SortOrder
    assetReference?: SortOrder
    activationTime?: SortOrder
    status?: SortOrder
    activationResult?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignActivationMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    assetType?: SortOrder
    assetReference?: SortOrder
    activationTime?: SortOrder
    status?: SortOrder
    activationResult?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignActivationMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    platform?: SortOrder
    assetType?: SortOrder
    assetReference?: SortOrder
    activationTime?: SortOrder
    status?: SortOrder
    activationResult?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerEngagementLogCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    message?: SortOrder
    resolutionStatus?: SortOrder
    responseTime?: SortOrder
    csatScore?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerEngagementLogAvgOrderByAggregateInput = {
    responseTime?: SortOrder
    csatScore?: SortOrder
  }

  export type CustomerEngagementLogMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    message?: SortOrder
    resolutionStatus?: SortOrder
    responseTime?: SortOrder
    csatScore?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerEngagementLogMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    message?: SortOrder
    resolutionStatus?: SortOrder
    responseTime?: SortOrder
    csatScore?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerEngagementLogSumOrderByAggregateInput = {
    responseTime?: SortOrder
    csatScore?: SortOrder
  }

  export type PerformanceReportCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    qrScans?: SortOrder
    conversions?: SortOrder
    chatbotSessions?: SortOrder
    escalations?: SortOrder
    escalationRate?: SortOrder
    avgBotResponseTime?: SortOrder
    avgHumanResponseTime?: SortOrder
    csatScoreAverage?: SortOrder
    anomalies?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceReportAvgOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
    qrScans?: SortOrder
    conversions?: SortOrder
    chatbotSessions?: SortOrder
    escalations?: SortOrder
    escalationRate?: SortOrder
    avgBotResponseTime?: SortOrder
    avgHumanResponseTime?: SortOrder
    csatScoreAverage?: SortOrder
  }

  export type PerformanceReportMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    qrScans?: SortOrder
    conversions?: SortOrder
    chatbotSessions?: SortOrder
    escalations?: SortOrder
    escalationRate?: SortOrder
    avgBotResponseTime?: SortOrder
    avgHumanResponseTime?: SortOrder
    csatScoreAverage?: SortOrder
    anomalies?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceReportMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    qrScans?: SortOrder
    conversions?: SortOrder
    chatbotSessions?: SortOrder
    escalations?: SortOrder
    escalationRate?: SortOrder
    avgBotResponseTime?: SortOrder
    avgHumanResponseTime?: SortOrder
    csatScoreAverage?: SortOrder
    anomalies?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceReportSumOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
    qrScans?: SortOrder
    conversions?: SortOrder
    chatbotSessions?: SortOrder
    escalations?: SortOrder
    escalationRate?: SortOrder
    avgBotResponseTime?: SortOrder
    avgHumanResponseTime?: SortOrder
    csatScoreAverage?: SortOrder
  }

  export type CustomerFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    interactionId?: SortOrder
    feedbackText?: SortOrder
    rating?: SortOrder
    collectedVia?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerFeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type CustomerFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    interactionId?: SortOrder
    feedbackText?: SortOrder
    rating?: SortOrder
    collectedVia?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    interactionId?: SortOrder
    feedbackText?: SortOrder
    rating?: SortOrder
    collectedVia?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerFeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ThankYouMessageCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    messageBody?: SortOrder
    sentVia?: SortOrder
    segment?: SortOrder
    sentAt?: SortOrder
  }

  export type ThankYouMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    messageBody?: SortOrder
    sentVia?: SortOrder
    segment?: SortOrder
    sentAt?: SortOrder
  }

  export type ThankYouMessageMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    messageBody?: SortOrder
    sentVia?: SortOrder
    segment?: SortOrder
    sentAt?: SortOrder
  }

  export type RetargetingPlanCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    audienceSegment?: SortOrder
    retargetingChannel?: SortOrder
    offerMessage?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RetargetingPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    audienceSegment?: SortOrder
    retargetingChannel?: SortOrder
    offerMessage?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RetargetingPlanMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    audienceSegment?: SortOrder
    retargetingChannel?: SortOrder
    offerMessage?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignExtensionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reason?: SortOrder
    extendedTo?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignExtensionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reason?: SortOrder
    extendedTo?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignExtensionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reason?: SortOrder
    extendedTo?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignAnalysisReportCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    totalQrScans?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    revenueGenerated?: SortOrder
    campaignSpend?: SortOrder
    roi?: SortOrder
    engagementRate?: SortOrder
    csatAverage?: SortOrder
    escalationRate?: SortOrder
    learningsSummary?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignAnalysisReportAvgOrderByAggregateInput = {
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    totalQrScans?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    revenueGenerated?: SortOrder
    campaignSpend?: SortOrder
    roi?: SortOrder
    engagementRate?: SortOrder
    csatAverage?: SortOrder
    escalationRate?: SortOrder
  }

  export type CampaignAnalysisReportMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    totalQrScans?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    revenueGenerated?: SortOrder
    campaignSpend?: SortOrder
    roi?: SortOrder
    engagementRate?: SortOrder
    csatAverage?: SortOrder
    escalationRate?: SortOrder
    learningsSummary?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignAnalysisReportMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    totalQrScans?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    revenueGenerated?: SortOrder
    campaignSpend?: SortOrder
    roi?: SortOrder
    engagementRate?: SortOrder
    csatAverage?: SortOrder
    escalationRate?: SortOrder
    learningsSummary?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignAnalysisReportSumOrderByAggregateInput = {
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    totalQrScans?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    revenueGenerated?: SortOrder
    campaignSpend?: SortOrder
    roi?: SortOrder
    engagementRate?: SortOrder
    csatAverage?: SortOrder
    escalationRate?: SortOrder
  }

  export type CampaignLearningsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    whatWorked?: SortOrder
    whatDidNotWork?: SortOrder
    bestPractices?: SortOrder
    improvementAreas?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignLearningsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    whatWorked?: SortOrder
    whatDidNotWork?: SortOrder
    bestPractices?: SortOrder
    improvementAreas?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignLearningsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    whatWorked?: SortOrder
    whatDidNotWork?: SortOrder
    bestPractices?: SortOrder
    improvementAreas?: SortOrder
    createdAt?: SortOrder
  }

  export type InternalCampaignReportCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reportTitle?: SortOrder
    executiveSummary?: SortOrder
    kpiHighlights?: SortOrder
    learningHighlights?: SortOrder
    improvementAreas?: SortOrder
    graphsReference?: SortOrder
    createdAt?: SortOrder
  }

  export type InternalCampaignReportMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reportTitle?: SortOrder
    executiveSummary?: SortOrder
    kpiHighlights?: SortOrder
    learningHighlights?: SortOrder
    improvementAreas?: SortOrder
    graphsReference?: SortOrder
    createdAt?: SortOrder
  }

  export type InternalCampaignReportMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    reportTitle?: SortOrder
    executiveSummary?: SortOrder
    kpiHighlights?: SortOrder
    learningHighlights?: SortOrder
    improvementAreas?: SortOrder
    graphsReference?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignCreateNestedOneWithoutCompetitorsInput = {
    create?: XOR<CampaignCreateWithoutCompetitorsInput, CampaignUncheckedCreateWithoutCompetitorsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCompetitorsInput
    connect?: CampaignWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CampaignUpdateOneRequiredWithoutCompetitorsNestedInput = {
    create?: XOR<CampaignCreateWithoutCompetitorsInput, CampaignUncheckedCreateWithoutCompetitorsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCompetitorsInput
    upsert?: CampaignUpsertWithoutCompetitorsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCompetitorsInput, CampaignUpdateWithoutCompetitorsInput>, CampaignUncheckedUpdateWithoutCompetitorsInput>
  }

  export type CampaignCreateNestedOneWithoutEnterpriseContextsInput = {
    create?: XOR<CampaignCreateWithoutEnterpriseContextsInput, CampaignUncheckedCreateWithoutEnterpriseContextsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEnterpriseContextsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutEnterpriseContextsNestedInput = {
    create?: XOR<CampaignCreateWithoutEnterpriseContextsInput, CampaignUncheckedCreateWithoutEnterpriseContextsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEnterpriseContextsInput
    upsert?: CampaignUpsertWithoutEnterpriseContextsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutEnterpriseContextsInput, CampaignUpdateWithoutEnterpriseContextsInput>, CampaignUncheckedUpdateWithoutEnterpriseContextsInput>
  }

  export type CampaignCreateNestedOneWithoutAudienceSegmentsInput = {
    create?: XOR<CampaignCreateWithoutAudienceSegmentsInput, CampaignUncheckedCreateWithoutAudienceSegmentsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAudienceSegmentsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutAudienceSegmentsNestedInput = {
    create?: XOR<CampaignCreateWithoutAudienceSegmentsInput, CampaignUncheckedCreateWithoutAudienceSegmentsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAudienceSegmentsInput
    upsert?: CampaignUpsertWithoutAudienceSegmentsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutAudienceSegmentsInput, CampaignUpdateWithoutAudienceSegmentsInput>, CampaignUncheckedUpdateWithoutAudienceSegmentsInput>
  }

  export type EnterpriseContextCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EnterpriseContextCreateWithoutCampaignInput, EnterpriseContextUncheckedCreateWithoutCampaignInput> | EnterpriseContextCreateWithoutCampaignInput[] | EnterpriseContextUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EnterpriseContextCreateOrConnectWithoutCampaignInput | EnterpriseContextCreateOrConnectWithoutCampaignInput[]
    createMany?: EnterpriseContextCreateManyCampaignInputEnvelope
    connect?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
  }

  export type AudienceSegmentCreateNestedManyWithoutCampaignInput = {
    create?: XOR<AudienceSegmentCreateWithoutCampaignInput, AudienceSegmentUncheckedCreateWithoutCampaignInput> | AudienceSegmentCreateWithoutCampaignInput[] | AudienceSegmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AudienceSegmentCreateOrConnectWithoutCampaignInput | AudienceSegmentCreateOrConnectWithoutCampaignInput[]
    createMany?: AudienceSegmentCreateManyCampaignInputEnvelope
    connect?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
  }

  export type CreativeDesignPlanCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CreativeDesignPlanCreateWithoutCampaignInput, CreativeDesignPlanUncheckedCreateWithoutCampaignInput> | CreativeDesignPlanCreateWithoutCampaignInput[] | CreativeDesignPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CreativeDesignPlanCreateOrConnectWithoutCampaignInput | CreativeDesignPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: CreativeDesignPlanCreateManyCampaignInputEnvelope
    connect?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
  }

  export type CampaignObjectiveCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignObjectiveCreateWithoutCampaignInput, CampaignObjectiveUncheckedCreateWithoutCampaignInput> | CampaignObjectiveCreateWithoutCampaignInput[] | CampaignObjectiveUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignObjectiveCreateOrConnectWithoutCampaignInput | CampaignObjectiveCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignObjectiveCreateManyCampaignInputEnvelope
    connect?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
  }

  export type TargetAudienceSegmentCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TargetAudienceSegmentCreateWithoutCampaignInput, TargetAudienceSegmentUncheckedCreateWithoutCampaignInput> | TargetAudienceSegmentCreateWithoutCampaignInput[] | TargetAudienceSegmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TargetAudienceSegmentCreateOrConnectWithoutCampaignInput | TargetAudienceSegmentCreateOrConnectWithoutCampaignInput[]
    createMany?: TargetAudienceSegmentCreateManyCampaignInputEnvelope
    connect?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
  }

  export type CompetitorStrategyCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CompetitorStrategyCreateWithoutCampaignInput, CompetitorStrategyUncheckedCreateWithoutCampaignInput> | CompetitorStrategyCreateWithoutCampaignInput[] | CompetitorStrategyUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CompetitorStrategyCreateOrConnectWithoutCampaignInput | CompetitorStrategyCreateOrConnectWithoutCampaignInput[]
    createMany?: CompetitorStrategyCreateManyCampaignInputEnvelope
    connect?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
  }

  export type PromotionTypeCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PromotionTypeCreateWithoutCampaignInput, PromotionTypeUncheckedCreateWithoutCampaignInput> | PromotionTypeCreateWithoutCampaignInput[] | PromotionTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PromotionTypeCreateOrConnectWithoutCampaignInput | PromotionTypeCreateOrConnectWithoutCampaignInput[]
    createMany?: PromotionTypeCreateManyCampaignInputEnvelope
    connect?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
  }

  export type CampaignOfferCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignOfferCreateWithoutCampaignInput, CampaignOfferUncheckedCreateWithoutCampaignInput> | CampaignOfferCreateWithoutCampaignInput[] | CampaignOfferUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignOfferCreateOrConnectWithoutCampaignInput | CampaignOfferCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignOfferCreateManyCampaignInputEnvelope
    connect?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
  }

  export type CampaignBudgetCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignBudgetCreateWithoutCampaignInput, CampaignBudgetUncheckedCreateWithoutCampaignInput> | CampaignBudgetCreateWithoutCampaignInput[] | CampaignBudgetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignBudgetCreateOrConnectWithoutCampaignInput | CampaignBudgetCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignBudgetCreateManyCampaignInputEnvelope
    connect?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
  }

  export type ChannelPlanCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ChannelPlanCreateWithoutCampaignInput, ChannelPlanUncheckedCreateWithoutCampaignInput> | ChannelPlanCreateWithoutCampaignInput[] | ChannelPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ChannelPlanCreateOrConnectWithoutCampaignInput | ChannelPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: ChannelPlanCreateManyCampaignInputEnvelope
    connect?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
  }

  export type CampaignTimelineCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignTimelineCreateWithoutCampaignInput, CampaignTimelineUncheckedCreateWithoutCampaignInput> | CampaignTimelineCreateWithoutCampaignInput[] | CampaignTimelineUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTimelineCreateOrConnectWithoutCampaignInput | CampaignTimelineCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignTimelineCreateManyCampaignInputEnvelope
    connect?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
  }

  export type ComplianceChecklistCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ComplianceChecklistCreateWithoutCampaignInput, ComplianceChecklistUncheckedCreateWithoutCampaignInput> | ComplianceChecklistCreateWithoutCampaignInput[] | ComplianceChecklistUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ComplianceChecklistCreateOrConnectWithoutCampaignInput | ComplianceChecklistCreateOrConnectWithoutCampaignInput[]
    createMany?: ComplianceChecklistCreateManyCampaignInputEnvelope
    connect?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
  }

  export type CreativeAssetCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CreativeAssetCreateWithoutCampaignInput, CreativeAssetUncheckedCreateWithoutCampaignInput> | CreativeAssetCreateWithoutCampaignInput[] | CreativeAssetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CreativeAssetCreateOrConnectWithoutCampaignInput | CreativeAssetCreateOrConnectWithoutCampaignInput[]
    createMany?: CreativeAssetCreateManyCampaignInputEnvelope
    connect?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
  }

  export type PromotionalMessageCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PromotionalMessageCreateWithoutCampaignInput, PromotionalMessageUncheckedCreateWithoutCampaignInput> | PromotionalMessageCreateWithoutCampaignInput[] | PromotionalMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PromotionalMessageCreateOrConnectWithoutCampaignInput | PromotionalMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: PromotionalMessageCreateManyCampaignInputEnvelope
    connect?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
  }

  export type MediaAssetCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MediaAssetCreateWithoutCampaignInput, MediaAssetUncheckedCreateWithoutCampaignInput> | MediaAssetCreateWithoutCampaignInput[] | MediaAssetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MediaAssetCreateOrConnectWithoutCampaignInput | MediaAssetCreateOrConnectWithoutCampaignInput[]
    createMany?: MediaAssetCreateManyCampaignInputEnvelope
    connect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
  }

  export type ContentCalendarCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ContentCalendarCreateWithoutCampaignInput, ContentCalendarUncheckedCreateWithoutCampaignInput> | ContentCalendarCreateWithoutCampaignInput[] | ContentCalendarUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ContentCalendarCreateOrConnectWithoutCampaignInput | ContentCalendarCreateOrConnectWithoutCampaignInput[]
    createMany?: ContentCalendarCreateManyCampaignInputEnvelope
    connect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
  }

  export type TeaserContentCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TeaserContentCreateWithoutCampaignInput, TeaserContentUncheckedCreateWithoutCampaignInput> | TeaserContentCreateWithoutCampaignInput[] | TeaserContentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TeaserContentCreateOrConnectWithoutCampaignInput | TeaserContentCreateOrConnectWithoutCampaignInput[]
    createMany?: TeaserContentCreateManyCampaignInputEnvelope
    connect?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
  }

  export type CustomerSegmentListCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomerSegmentListCreateWithoutCampaignInput, CustomerSegmentListUncheckedCreateWithoutCampaignInput> | CustomerSegmentListCreateWithoutCampaignInput[] | CustomerSegmentListUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerSegmentListCreateOrConnectWithoutCampaignInput | CustomerSegmentListCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomerSegmentListCreateManyCampaignInputEnvelope
    connect?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
  }

  export type InfluencerPlanCreateNestedManyWithoutCampaignInput = {
    create?: XOR<InfluencerPlanCreateWithoutCampaignInput, InfluencerPlanUncheckedCreateWithoutCampaignInput> | InfluencerPlanCreateWithoutCampaignInput[] | InfluencerPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InfluencerPlanCreateOrConnectWithoutCampaignInput | InfluencerPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: InfluencerPlanCreateManyCampaignInputEnvelope
    connect?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
  }

  export type OperationalChecklistCreateNestedManyWithoutCampaignInput = {
    create?: XOR<OperationalChecklistCreateWithoutCampaignInput, OperationalChecklistUncheckedCreateWithoutCampaignInput> | OperationalChecklistCreateWithoutCampaignInput[] | OperationalChecklistUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: OperationalChecklistCreateOrConnectWithoutCampaignInput | OperationalChecklistCreateOrConnectWithoutCampaignInput[]
    createMany?: OperationalChecklistCreateManyCampaignInputEnvelope
    connect?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
  }

  export type CampaignActivationCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignActivationCreateWithoutCampaignInput, CampaignActivationUncheckedCreateWithoutCampaignInput> | CampaignActivationCreateWithoutCampaignInput[] | CampaignActivationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignActivationCreateOrConnectWithoutCampaignInput | CampaignActivationCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignActivationCreateManyCampaignInputEnvelope
    connect?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
  }

  export type CustomerEngagementLogCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomerEngagementLogCreateWithoutCampaignInput, CustomerEngagementLogUncheckedCreateWithoutCampaignInput> | CustomerEngagementLogCreateWithoutCampaignInput[] | CustomerEngagementLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerEngagementLogCreateOrConnectWithoutCampaignInput | CustomerEngagementLogCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomerEngagementLogCreateManyCampaignInputEnvelope
    connect?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
  }

  export type PerformanceReportCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PerformanceReportCreateWithoutCampaignInput, PerformanceReportUncheckedCreateWithoutCampaignInput> | PerformanceReportCreateWithoutCampaignInput[] | PerformanceReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PerformanceReportCreateOrConnectWithoutCampaignInput | PerformanceReportCreateOrConnectWithoutCampaignInput[]
    createMany?: PerformanceReportCreateManyCampaignInputEnvelope
    connect?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
  }

  export type CustomerFeedbackCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomerFeedbackCreateWithoutCampaignInput, CustomerFeedbackUncheckedCreateWithoutCampaignInput> | CustomerFeedbackCreateWithoutCampaignInput[] | CustomerFeedbackUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerFeedbackCreateOrConnectWithoutCampaignInput | CustomerFeedbackCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomerFeedbackCreateManyCampaignInputEnvelope
    connect?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
  }

  export type ThankYouMessageCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ThankYouMessageCreateWithoutCampaignInput, ThankYouMessageUncheckedCreateWithoutCampaignInput> | ThankYouMessageCreateWithoutCampaignInput[] | ThankYouMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ThankYouMessageCreateOrConnectWithoutCampaignInput | ThankYouMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: ThankYouMessageCreateManyCampaignInputEnvelope
    connect?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
  }

  export type RetargetingPlanCreateNestedManyWithoutCampaignInput = {
    create?: XOR<RetargetingPlanCreateWithoutCampaignInput, RetargetingPlanUncheckedCreateWithoutCampaignInput> | RetargetingPlanCreateWithoutCampaignInput[] | RetargetingPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RetargetingPlanCreateOrConnectWithoutCampaignInput | RetargetingPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: RetargetingPlanCreateManyCampaignInputEnvelope
    connect?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
  }

  export type CampaignExtensionPlanCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignExtensionPlanCreateWithoutCampaignInput, CampaignExtensionPlanUncheckedCreateWithoutCampaignInput> | CampaignExtensionPlanCreateWithoutCampaignInput[] | CampaignExtensionPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignExtensionPlanCreateOrConnectWithoutCampaignInput | CampaignExtensionPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignExtensionPlanCreateManyCampaignInputEnvelope
    connect?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
  }

  export type CampaignAnalysisReportCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignAnalysisReportCreateWithoutCampaignInput, CampaignAnalysisReportUncheckedCreateWithoutCampaignInput> | CampaignAnalysisReportCreateWithoutCampaignInput[] | CampaignAnalysisReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAnalysisReportCreateOrConnectWithoutCampaignInput | CampaignAnalysisReportCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignAnalysisReportCreateManyCampaignInputEnvelope
    connect?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
  }

  export type CampaignLearningsCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLearningsCreateWithoutCampaignInput, CampaignLearningsUncheckedCreateWithoutCampaignInput> | CampaignLearningsCreateWithoutCampaignInput[] | CampaignLearningsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLearningsCreateOrConnectWithoutCampaignInput | CampaignLearningsCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLearningsCreateManyCampaignInputEnvelope
    connect?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
  }

  export type InternalCampaignReportCreateNestedManyWithoutCampaignInput = {
    create?: XOR<InternalCampaignReportCreateWithoutCampaignInput, InternalCampaignReportUncheckedCreateWithoutCampaignInput> | InternalCampaignReportCreateWithoutCampaignInput[] | InternalCampaignReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InternalCampaignReportCreateOrConnectWithoutCampaignInput | InternalCampaignReportCreateOrConnectWithoutCampaignInput[]
    createMany?: InternalCampaignReportCreateManyCampaignInputEnvelope
    connect?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
  }

  export type EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EnterpriseContextCreateWithoutCampaignInput, EnterpriseContextUncheckedCreateWithoutCampaignInput> | EnterpriseContextCreateWithoutCampaignInput[] | EnterpriseContextUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EnterpriseContextCreateOrConnectWithoutCampaignInput | EnterpriseContextCreateOrConnectWithoutCampaignInput[]
    createMany?: EnterpriseContextCreateManyCampaignInputEnvelope
    connect?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
  }

  export type AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<AudienceSegmentCreateWithoutCampaignInput, AudienceSegmentUncheckedCreateWithoutCampaignInput> | AudienceSegmentCreateWithoutCampaignInput[] | AudienceSegmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AudienceSegmentCreateOrConnectWithoutCampaignInput | AudienceSegmentCreateOrConnectWithoutCampaignInput[]
    createMany?: AudienceSegmentCreateManyCampaignInputEnvelope
    connect?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
  }

  export type CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CreativeDesignPlanCreateWithoutCampaignInput, CreativeDesignPlanUncheckedCreateWithoutCampaignInput> | CreativeDesignPlanCreateWithoutCampaignInput[] | CreativeDesignPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CreativeDesignPlanCreateOrConnectWithoutCampaignInput | CreativeDesignPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: CreativeDesignPlanCreateManyCampaignInputEnvelope
    connect?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
  }

  export type CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignObjectiveCreateWithoutCampaignInput, CampaignObjectiveUncheckedCreateWithoutCampaignInput> | CampaignObjectiveCreateWithoutCampaignInput[] | CampaignObjectiveUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignObjectiveCreateOrConnectWithoutCampaignInput | CampaignObjectiveCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignObjectiveCreateManyCampaignInputEnvelope
    connect?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
  }

  export type TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TargetAudienceSegmentCreateWithoutCampaignInput, TargetAudienceSegmentUncheckedCreateWithoutCampaignInput> | TargetAudienceSegmentCreateWithoutCampaignInput[] | TargetAudienceSegmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TargetAudienceSegmentCreateOrConnectWithoutCampaignInput | TargetAudienceSegmentCreateOrConnectWithoutCampaignInput[]
    createMany?: TargetAudienceSegmentCreateManyCampaignInputEnvelope
    connect?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
  }

  export type CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CompetitorStrategyCreateWithoutCampaignInput, CompetitorStrategyUncheckedCreateWithoutCampaignInput> | CompetitorStrategyCreateWithoutCampaignInput[] | CompetitorStrategyUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CompetitorStrategyCreateOrConnectWithoutCampaignInput | CompetitorStrategyCreateOrConnectWithoutCampaignInput[]
    createMany?: CompetitorStrategyCreateManyCampaignInputEnvelope
    connect?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
  }

  export type PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PromotionTypeCreateWithoutCampaignInput, PromotionTypeUncheckedCreateWithoutCampaignInput> | PromotionTypeCreateWithoutCampaignInput[] | PromotionTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PromotionTypeCreateOrConnectWithoutCampaignInput | PromotionTypeCreateOrConnectWithoutCampaignInput[]
    createMany?: PromotionTypeCreateManyCampaignInputEnvelope
    connect?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
  }

  export type CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignOfferCreateWithoutCampaignInput, CampaignOfferUncheckedCreateWithoutCampaignInput> | CampaignOfferCreateWithoutCampaignInput[] | CampaignOfferUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignOfferCreateOrConnectWithoutCampaignInput | CampaignOfferCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignOfferCreateManyCampaignInputEnvelope
    connect?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
  }

  export type CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignBudgetCreateWithoutCampaignInput, CampaignBudgetUncheckedCreateWithoutCampaignInput> | CampaignBudgetCreateWithoutCampaignInput[] | CampaignBudgetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignBudgetCreateOrConnectWithoutCampaignInput | CampaignBudgetCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignBudgetCreateManyCampaignInputEnvelope
    connect?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
  }

  export type ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ChannelPlanCreateWithoutCampaignInput, ChannelPlanUncheckedCreateWithoutCampaignInput> | ChannelPlanCreateWithoutCampaignInput[] | ChannelPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ChannelPlanCreateOrConnectWithoutCampaignInput | ChannelPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: ChannelPlanCreateManyCampaignInputEnvelope
    connect?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
  }

  export type CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignTimelineCreateWithoutCampaignInput, CampaignTimelineUncheckedCreateWithoutCampaignInput> | CampaignTimelineCreateWithoutCampaignInput[] | CampaignTimelineUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTimelineCreateOrConnectWithoutCampaignInput | CampaignTimelineCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignTimelineCreateManyCampaignInputEnvelope
    connect?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
  }

  export type ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ComplianceChecklistCreateWithoutCampaignInput, ComplianceChecklistUncheckedCreateWithoutCampaignInput> | ComplianceChecklistCreateWithoutCampaignInput[] | ComplianceChecklistUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ComplianceChecklistCreateOrConnectWithoutCampaignInput | ComplianceChecklistCreateOrConnectWithoutCampaignInput[]
    createMany?: ComplianceChecklistCreateManyCampaignInputEnvelope
    connect?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
  }

  export type CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CreativeAssetCreateWithoutCampaignInput, CreativeAssetUncheckedCreateWithoutCampaignInput> | CreativeAssetCreateWithoutCampaignInput[] | CreativeAssetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CreativeAssetCreateOrConnectWithoutCampaignInput | CreativeAssetCreateOrConnectWithoutCampaignInput[]
    createMany?: CreativeAssetCreateManyCampaignInputEnvelope
    connect?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
  }

  export type PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PromotionalMessageCreateWithoutCampaignInput, PromotionalMessageUncheckedCreateWithoutCampaignInput> | PromotionalMessageCreateWithoutCampaignInput[] | PromotionalMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PromotionalMessageCreateOrConnectWithoutCampaignInput | PromotionalMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: PromotionalMessageCreateManyCampaignInputEnvelope
    connect?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
  }

  export type MediaAssetUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MediaAssetCreateWithoutCampaignInput, MediaAssetUncheckedCreateWithoutCampaignInput> | MediaAssetCreateWithoutCampaignInput[] | MediaAssetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MediaAssetCreateOrConnectWithoutCampaignInput | MediaAssetCreateOrConnectWithoutCampaignInput[]
    createMany?: MediaAssetCreateManyCampaignInputEnvelope
    connect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
  }

  export type ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ContentCalendarCreateWithoutCampaignInput, ContentCalendarUncheckedCreateWithoutCampaignInput> | ContentCalendarCreateWithoutCampaignInput[] | ContentCalendarUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ContentCalendarCreateOrConnectWithoutCampaignInput | ContentCalendarCreateOrConnectWithoutCampaignInput[]
    createMany?: ContentCalendarCreateManyCampaignInputEnvelope
    connect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
  }

  export type TeaserContentUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TeaserContentCreateWithoutCampaignInput, TeaserContentUncheckedCreateWithoutCampaignInput> | TeaserContentCreateWithoutCampaignInput[] | TeaserContentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TeaserContentCreateOrConnectWithoutCampaignInput | TeaserContentCreateOrConnectWithoutCampaignInput[]
    createMany?: TeaserContentCreateManyCampaignInputEnvelope
    connect?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
  }

  export type CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomerSegmentListCreateWithoutCampaignInput, CustomerSegmentListUncheckedCreateWithoutCampaignInput> | CustomerSegmentListCreateWithoutCampaignInput[] | CustomerSegmentListUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerSegmentListCreateOrConnectWithoutCampaignInput | CustomerSegmentListCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomerSegmentListCreateManyCampaignInputEnvelope
    connect?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
  }

  export type InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<InfluencerPlanCreateWithoutCampaignInput, InfluencerPlanUncheckedCreateWithoutCampaignInput> | InfluencerPlanCreateWithoutCampaignInput[] | InfluencerPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InfluencerPlanCreateOrConnectWithoutCampaignInput | InfluencerPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: InfluencerPlanCreateManyCampaignInputEnvelope
    connect?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
  }

  export type OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<OperationalChecklistCreateWithoutCampaignInput, OperationalChecklistUncheckedCreateWithoutCampaignInput> | OperationalChecklistCreateWithoutCampaignInput[] | OperationalChecklistUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: OperationalChecklistCreateOrConnectWithoutCampaignInput | OperationalChecklistCreateOrConnectWithoutCampaignInput[]
    createMany?: OperationalChecklistCreateManyCampaignInputEnvelope
    connect?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
  }

  export type CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignActivationCreateWithoutCampaignInput, CampaignActivationUncheckedCreateWithoutCampaignInput> | CampaignActivationCreateWithoutCampaignInput[] | CampaignActivationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignActivationCreateOrConnectWithoutCampaignInput | CampaignActivationCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignActivationCreateManyCampaignInputEnvelope
    connect?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
  }

  export type CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomerEngagementLogCreateWithoutCampaignInput, CustomerEngagementLogUncheckedCreateWithoutCampaignInput> | CustomerEngagementLogCreateWithoutCampaignInput[] | CustomerEngagementLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerEngagementLogCreateOrConnectWithoutCampaignInput | CustomerEngagementLogCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomerEngagementLogCreateManyCampaignInputEnvelope
    connect?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
  }

  export type PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PerformanceReportCreateWithoutCampaignInput, PerformanceReportUncheckedCreateWithoutCampaignInput> | PerformanceReportCreateWithoutCampaignInput[] | PerformanceReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PerformanceReportCreateOrConnectWithoutCampaignInput | PerformanceReportCreateOrConnectWithoutCampaignInput[]
    createMany?: PerformanceReportCreateManyCampaignInputEnvelope
    connect?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
  }

  export type CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomerFeedbackCreateWithoutCampaignInput, CustomerFeedbackUncheckedCreateWithoutCampaignInput> | CustomerFeedbackCreateWithoutCampaignInput[] | CustomerFeedbackUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerFeedbackCreateOrConnectWithoutCampaignInput | CustomerFeedbackCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomerFeedbackCreateManyCampaignInputEnvelope
    connect?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
  }

  export type ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ThankYouMessageCreateWithoutCampaignInput, ThankYouMessageUncheckedCreateWithoutCampaignInput> | ThankYouMessageCreateWithoutCampaignInput[] | ThankYouMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ThankYouMessageCreateOrConnectWithoutCampaignInput | ThankYouMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: ThankYouMessageCreateManyCampaignInputEnvelope
    connect?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
  }

  export type RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<RetargetingPlanCreateWithoutCampaignInput, RetargetingPlanUncheckedCreateWithoutCampaignInput> | RetargetingPlanCreateWithoutCampaignInput[] | RetargetingPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RetargetingPlanCreateOrConnectWithoutCampaignInput | RetargetingPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: RetargetingPlanCreateManyCampaignInputEnvelope
    connect?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
  }

  export type CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignExtensionPlanCreateWithoutCampaignInput, CampaignExtensionPlanUncheckedCreateWithoutCampaignInput> | CampaignExtensionPlanCreateWithoutCampaignInput[] | CampaignExtensionPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignExtensionPlanCreateOrConnectWithoutCampaignInput | CampaignExtensionPlanCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignExtensionPlanCreateManyCampaignInputEnvelope
    connect?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
  }

  export type CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignAnalysisReportCreateWithoutCampaignInput, CampaignAnalysisReportUncheckedCreateWithoutCampaignInput> | CampaignAnalysisReportCreateWithoutCampaignInput[] | CampaignAnalysisReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAnalysisReportCreateOrConnectWithoutCampaignInput | CampaignAnalysisReportCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignAnalysisReportCreateManyCampaignInputEnvelope
    connect?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
  }

  export type CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLearningsCreateWithoutCampaignInput, CampaignLearningsUncheckedCreateWithoutCampaignInput> | CampaignLearningsCreateWithoutCampaignInput[] | CampaignLearningsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLearningsCreateOrConnectWithoutCampaignInput | CampaignLearningsCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLearningsCreateManyCampaignInputEnvelope
    connect?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
  }

  export type InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<InternalCampaignReportCreateWithoutCampaignInput, InternalCampaignReportUncheckedCreateWithoutCampaignInput> | InternalCampaignReportCreateWithoutCampaignInput[] | InternalCampaignReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InternalCampaignReportCreateOrConnectWithoutCampaignInput | InternalCampaignReportCreateOrConnectWithoutCampaignInput[]
    createMany?: InternalCampaignReportCreateManyCampaignInputEnvelope
    connect?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnterpriseContextUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EnterpriseContextCreateWithoutCampaignInput, EnterpriseContextUncheckedCreateWithoutCampaignInput> | EnterpriseContextCreateWithoutCampaignInput[] | EnterpriseContextUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EnterpriseContextCreateOrConnectWithoutCampaignInput | EnterpriseContextCreateOrConnectWithoutCampaignInput[]
    upsert?: EnterpriseContextUpsertWithWhereUniqueWithoutCampaignInput | EnterpriseContextUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EnterpriseContextCreateManyCampaignInputEnvelope
    set?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
    disconnect?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
    delete?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
    connect?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
    update?: EnterpriseContextUpdateWithWhereUniqueWithoutCampaignInput | EnterpriseContextUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EnterpriseContextUpdateManyWithWhereWithoutCampaignInput | EnterpriseContextUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EnterpriseContextScalarWhereInput | EnterpriseContextScalarWhereInput[]
  }

  export type AudienceSegmentUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<AudienceSegmentCreateWithoutCampaignInput, AudienceSegmentUncheckedCreateWithoutCampaignInput> | AudienceSegmentCreateWithoutCampaignInput[] | AudienceSegmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AudienceSegmentCreateOrConnectWithoutCampaignInput | AudienceSegmentCreateOrConnectWithoutCampaignInput[]
    upsert?: AudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput | AudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: AudienceSegmentCreateManyCampaignInputEnvelope
    set?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
    disconnect?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
    delete?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
    connect?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
    update?: AudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput | AudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: AudienceSegmentUpdateManyWithWhereWithoutCampaignInput | AudienceSegmentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: AudienceSegmentScalarWhereInput | AudienceSegmentScalarWhereInput[]
  }

  export type CreativeDesignPlanUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CreativeDesignPlanCreateWithoutCampaignInput, CreativeDesignPlanUncheckedCreateWithoutCampaignInput> | CreativeDesignPlanCreateWithoutCampaignInput[] | CreativeDesignPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CreativeDesignPlanCreateOrConnectWithoutCampaignInput | CreativeDesignPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: CreativeDesignPlanUpsertWithWhereUniqueWithoutCampaignInput | CreativeDesignPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CreativeDesignPlanCreateManyCampaignInputEnvelope
    set?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
    disconnect?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
    delete?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
    connect?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
    update?: CreativeDesignPlanUpdateWithWhereUniqueWithoutCampaignInput | CreativeDesignPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CreativeDesignPlanUpdateManyWithWhereWithoutCampaignInput | CreativeDesignPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CreativeDesignPlanScalarWhereInput | CreativeDesignPlanScalarWhereInput[]
  }

  export type CampaignObjectiveUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignObjectiveCreateWithoutCampaignInput, CampaignObjectiveUncheckedCreateWithoutCampaignInput> | CampaignObjectiveCreateWithoutCampaignInput[] | CampaignObjectiveUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignObjectiveCreateOrConnectWithoutCampaignInput | CampaignObjectiveCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignObjectiveUpsertWithWhereUniqueWithoutCampaignInput | CampaignObjectiveUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignObjectiveCreateManyCampaignInputEnvelope
    set?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
    disconnect?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
    delete?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
    connect?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
    update?: CampaignObjectiveUpdateWithWhereUniqueWithoutCampaignInput | CampaignObjectiveUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignObjectiveUpdateManyWithWhereWithoutCampaignInput | CampaignObjectiveUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignObjectiveScalarWhereInput | CampaignObjectiveScalarWhereInput[]
  }

  export type TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TargetAudienceSegmentCreateWithoutCampaignInput, TargetAudienceSegmentUncheckedCreateWithoutCampaignInput> | TargetAudienceSegmentCreateWithoutCampaignInput[] | TargetAudienceSegmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TargetAudienceSegmentCreateOrConnectWithoutCampaignInput | TargetAudienceSegmentCreateOrConnectWithoutCampaignInput[]
    upsert?: TargetAudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput | TargetAudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TargetAudienceSegmentCreateManyCampaignInputEnvelope
    set?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
    disconnect?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
    delete?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
    connect?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
    update?: TargetAudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput | TargetAudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TargetAudienceSegmentUpdateManyWithWhereWithoutCampaignInput | TargetAudienceSegmentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TargetAudienceSegmentScalarWhereInput | TargetAudienceSegmentScalarWhereInput[]
  }

  export type CompetitorStrategyUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CompetitorStrategyCreateWithoutCampaignInput, CompetitorStrategyUncheckedCreateWithoutCampaignInput> | CompetitorStrategyCreateWithoutCampaignInput[] | CompetitorStrategyUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CompetitorStrategyCreateOrConnectWithoutCampaignInput | CompetitorStrategyCreateOrConnectWithoutCampaignInput[]
    upsert?: CompetitorStrategyUpsertWithWhereUniqueWithoutCampaignInput | CompetitorStrategyUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CompetitorStrategyCreateManyCampaignInputEnvelope
    set?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
    disconnect?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
    delete?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
    connect?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
    update?: CompetitorStrategyUpdateWithWhereUniqueWithoutCampaignInput | CompetitorStrategyUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CompetitorStrategyUpdateManyWithWhereWithoutCampaignInput | CompetitorStrategyUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CompetitorStrategyScalarWhereInput | CompetitorStrategyScalarWhereInput[]
  }

  export type PromotionTypeUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PromotionTypeCreateWithoutCampaignInput, PromotionTypeUncheckedCreateWithoutCampaignInput> | PromotionTypeCreateWithoutCampaignInput[] | PromotionTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PromotionTypeCreateOrConnectWithoutCampaignInput | PromotionTypeCreateOrConnectWithoutCampaignInput[]
    upsert?: PromotionTypeUpsertWithWhereUniqueWithoutCampaignInput | PromotionTypeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PromotionTypeCreateManyCampaignInputEnvelope
    set?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
    disconnect?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
    delete?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
    connect?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
    update?: PromotionTypeUpdateWithWhereUniqueWithoutCampaignInput | PromotionTypeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PromotionTypeUpdateManyWithWhereWithoutCampaignInput | PromotionTypeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PromotionTypeScalarWhereInput | PromotionTypeScalarWhereInput[]
  }

  export type CampaignOfferUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignOfferCreateWithoutCampaignInput, CampaignOfferUncheckedCreateWithoutCampaignInput> | CampaignOfferCreateWithoutCampaignInput[] | CampaignOfferUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignOfferCreateOrConnectWithoutCampaignInput | CampaignOfferCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignOfferUpsertWithWhereUniqueWithoutCampaignInput | CampaignOfferUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignOfferCreateManyCampaignInputEnvelope
    set?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
    disconnect?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
    delete?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
    connect?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
    update?: CampaignOfferUpdateWithWhereUniqueWithoutCampaignInput | CampaignOfferUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignOfferUpdateManyWithWhereWithoutCampaignInput | CampaignOfferUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignOfferScalarWhereInput | CampaignOfferScalarWhereInput[]
  }

  export type CampaignBudgetUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignBudgetCreateWithoutCampaignInput, CampaignBudgetUncheckedCreateWithoutCampaignInput> | CampaignBudgetCreateWithoutCampaignInput[] | CampaignBudgetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignBudgetCreateOrConnectWithoutCampaignInput | CampaignBudgetCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignBudgetUpsertWithWhereUniqueWithoutCampaignInput | CampaignBudgetUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignBudgetCreateManyCampaignInputEnvelope
    set?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
    disconnect?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
    delete?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
    connect?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
    update?: CampaignBudgetUpdateWithWhereUniqueWithoutCampaignInput | CampaignBudgetUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignBudgetUpdateManyWithWhereWithoutCampaignInput | CampaignBudgetUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignBudgetScalarWhereInput | CampaignBudgetScalarWhereInput[]
  }

  export type ChannelPlanUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ChannelPlanCreateWithoutCampaignInput, ChannelPlanUncheckedCreateWithoutCampaignInput> | ChannelPlanCreateWithoutCampaignInput[] | ChannelPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ChannelPlanCreateOrConnectWithoutCampaignInput | ChannelPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: ChannelPlanUpsertWithWhereUniqueWithoutCampaignInput | ChannelPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ChannelPlanCreateManyCampaignInputEnvelope
    set?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
    disconnect?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
    delete?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
    connect?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
    update?: ChannelPlanUpdateWithWhereUniqueWithoutCampaignInput | ChannelPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ChannelPlanUpdateManyWithWhereWithoutCampaignInput | ChannelPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ChannelPlanScalarWhereInput | ChannelPlanScalarWhereInput[]
  }

  export type CampaignTimelineUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignTimelineCreateWithoutCampaignInput, CampaignTimelineUncheckedCreateWithoutCampaignInput> | CampaignTimelineCreateWithoutCampaignInput[] | CampaignTimelineUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTimelineCreateOrConnectWithoutCampaignInput | CampaignTimelineCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignTimelineUpsertWithWhereUniqueWithoutCampaignInput | CampaignTimelineUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignTimelineCreateManyCampaignInputEnvelope
    set?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
    disconnect?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
    delete?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
    connect?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
    update?: CampaignTimelineUpdateWithWhereUniqueWithoutCampaignInput | CampaignTimelineUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignTimelineUpdateManyWithWhereWithoutCampaignInput | CampaignTimelineUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignTimelineScalarWhereInput | CampaignTimelineScalarWhereInput[]
  }

  export type ComplianceChecklistUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ComplianceChecklistCreateWithoutCampaignInput, ComplianceChecklistUncheckedCreateWithoutCampaignInput> | ComplianceChecklistCreateWithoutCampaignInput[] | ComplianceChecklistUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ComplianceChecklistCreateOrConnectWithoutCampaignInput | ComplianceChecklistCreateOrConnectWithoutCampaignInput[]
    upsert?: ComplianceChecklistUpsertWithWhereUniqueWithoutCampaignInput | ComplianceChecklistUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ComplianceChecklistCreateManyCampaignInputEnvelope
    set?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
    disconnect?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
    delete?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
    connect?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
    update?: ComplianceChecklistUpdateWithWhereUniqueWithoutCampaignInput | ComplianceChecklistUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ComplianceChecklistUpdateManyWithWhereWithoutCampaignInput | ComplianceChecklistUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ComplianceChecklistScalarWhereInput | ComplianceChecklistScalarWhereInput[]
  }

  export type CreativeAssetUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CreativeAssetCreateWithoutCampaignInput, CreativeAssetUncheckedCreateWithoutCampaignInput> | CreativeAssetCreateWithoutCampaignInput[] | CreativeAssetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CreativeAssetCreateOrConnectWithoutCampaignInput | CreativeAssetCreateOrConnectWithoutCampaignInput[]
    upsert?: CreativeAssetUpsertWithWhereUniqueWithoutCampaignInput | CreativeAssetUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CreativeAssetCreateManyCampaignInputEnvelope
    set?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
    disconnect?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
    delete?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
    connect?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
    update?: CreativeAssetUpdateWithWhereUniqueWithoutCampaignInput | CreativeAssetUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CreativeAssetUpdateManyWithWhereWithoutCampaignInput | CreativeAssetUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CreativeAssetScalarWhereInput | CreativeAssetScalarWhereInput[]
  }

  export type PromotionalMessageUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PromotionalMessageCreateWithoutCampaignInput, PromotionalMessageUncheckedCreateWithoutCampaignInput> | PromotionalMessageCreateWithoutCampaignInput[] | PromotionalMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PromotionalMessageCreateOrConnectWithoutCampaignInput | PromotionalMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: PromotionalMessageUpsertWithWhereUniqueWithoutCampaignInput | PromotionalMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PromotionalMessageCreateManyCampaignInputEnvelope
    set?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
    disconnect?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
    delete?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
    connect?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
    update?: PromotionalMessageUpdateWithWhereUniqueWithoutCampaignInput | PromotionalMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PromotionalMessageUpdateManyWithWhereWithoutCampaignInput | PromotionalMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PromotionalMessageScalarWhereInput | PromotionalMessageScalarWhereInput[]
  }

  export type MediaAssetUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MediaAssetCreateWithoutCampaignInput, MediaAssetUncheckedCreateWithoutCampaignInput> | MediaAssetCreateWithoutCampaignInput[] | MediaAssetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MediaAssetCreateOrConnectWithoutCampaignInput | MediaAssetCreateOrConnectWithoutCampaignInput[]
    upsert?: MediaAssetUpsertWithWhereUniqueWithoutCampaignInput | MediaAssetUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MediaAssetCreateManyCampaignInputEnvelope
    set?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    disconnect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    delete?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    connect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    update?: MediaAssetUpdateWithWhereUniqueWithoutCampaignInput | MediaAssetUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MediaAssetUpdateManyWithWhereWithoutCampaignInput | MediaAssetUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MediaAssetScalarWhereInput | MediaAssetScalarWhereInput[]
  }

  export type ContentCalendarUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ContentCalendarCreateWithoutCampaignInput, ContentCalendarUncheckedCreateWithoutCampaignInput> | ContentCalendarCreateWithoutCampaignInput[] | ContentCalendarUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ContentCalendarCreateOrConnectWithoutCampaignInput | ContentCalendarCreateOrConnectWithoutCampaignInput[]
    upsert?: ContentCalendarUpsertWithWhereUniqueWithoutCampaignInput | ContentCalendarUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ContentCalendarCreateManyCampaignInputEnvelope
    set?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    disconnect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    delete?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    connect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    update?: ContentCalendarUpdateWithWhereUniqueWithoutCampaignInput | ContentCalendarUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ContentCalendarUpdateManyWithWhereWithoutCampaignInput | ContentCalendarUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ContentCalendarScalarWhereInput | ContentCalendarScalarWhereInput[]
  }

  export type TeaserContentUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TeaserContentCreateWithoutCampaignInput, TeaserContentUncheckedCreateWithoutCampaignInput> | TeaserContentCreateWithoutCampaignInput[] | TeaserContentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TeaserContentCreateOrConnectWithoutCampaignInput | TeaserContentCreateOrConnectWithoutCampaignInput[]
    upsert?: TeaserContentUpsertWithWhereUniqueWithoutCampaignInput | TeaserContentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TeaserContentCreateManyCampaignInputEnvelope
    set?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
    disconnect?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
    delete?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
    connect?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
    update?: TeaserContentUpdateWithWhereUniqueWithoutCampaignInput | TeaserContentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TeaserContentUpdateManyWithWhereWithoutCampaignInput | TeaserContentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TeaserContentScalarWhereInput | TeaserContentScalarWhereInput[]
  }

  export type CustomerSegmentListUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomerSegmentListCreateWithoutCampaignInput, CustomerSegmentListUncheckedCreateWithoutCampaignInput> | CustomerSegmentListCreateWithoutCampaignInput[] | CustomerSegmentListUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerSegmentListCreateOrConnectWithoutCampaignInput | CustomerSegmentListCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomerSegmentListUpsertWithWhereUniqueWithoutCampaignInput | CustomerSegmentListUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomerSegmentListCreateManyCampaignInputEnvelope
    set?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
    disconnect?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
    delete?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
    connect?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
    update?: CustomerSegmentListUpdateWithWhereUniqueWithoutCampaignInput | CustomerSegmentListUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomerSegmentListUpdateManyWithWhereWithoutCampaignInput | CustomerSegmentListUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomerSegmentListScalarWhereInput | CustomerSegmentListScalarWhereInput[]
  }

  export type InfluencerPlanUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<InfluencerPlanCreateWithoutCampaignInput, InfluencerPlanUncheckedCreateWithoutCampaignInput> | InfluencerPlanCreateWithoutCampaignInput[] | InfluencerPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InfluencerPlanCreateOrConnectWithoutCampaignInput | InfluencerPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: InfluencerPlanUpsertWithWhereUniqueWithoutCampaignInput | InfluencerPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: InfluencerPlanCreateManyCampaignInputEnvelope
    set?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
    disconnect?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
    delete?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
    connect?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
    update?: InfluencerPlanUpdateWithWhereUniqueWithoutCampaignInput | InfluencerPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: InfluencerPlanUpdateManyWithWhereWithoutCampaignInput | InfluencerPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: InfluencerPlanScalarWhereInput | InfluencerPlanScalarWhereInput[]
  }

  export type OperationalChecklistUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<OperationalChecklistCreateWithoutCampaignInput, OperationalChecklistUncheckedCreateWithoutCampaignInput> | OperationalChecklistCreateWithoutCampaignInput[] | OperationalChecklistUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: OperationalChecklistCreateOrConnectWithoutCampaignInput | OperationalChecklistCreateOrConnectWithoutCampaignInput[]
    upsert?: OperationalChecklistUpsertWithWhereUniqueWithoutCampaignInput | OperationalChecklistUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: OperationalChecklistCreateManyCampaignInputEnvelope
    set?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
    disconnect?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
    delete?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
    connect?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
    update?: OperationalChecklistUpdateWithWhereUniqueWithoutCampaignInput | OperationalChecklistUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: OperationalChecklistUpdateManyWithWhereWithoutCampaignInput | OperationalChecklistUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: OperationalChecklistScalarWhereInput | OperationalChecklistScalarWhereInput[]
  }

  export type CampaignActivationUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignActivationCreateWithoutCampaignInput, CampaignActivationUncheckedCreateWithoutCampaignInput> | CampaignActivationCreateWithoutCampaignInput[] | CampaignActivationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignActivationCreateOrConnectWithoutCampaignInput | CampaignActivationCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignActivationUpsertWithWhereUniqueWithoutCampaignInput | CampaignActivationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignActivationCreateManyCampaignInputEnvelope
    set?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
    disconnect?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
    delete?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
    connect?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
    update?: CampaignActivationUpdateWithWhereUniqueWithoutCampaignInput | CampaignActivationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignActivationUpdateManyWithWhereWithoutCampaignInput | CampaignActivationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignActivationScalarWhereInput | CampaignActivationScalarWhereInput[]
  }

  export type CustomerEngagementLogUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomerEngagementLogCreateWithoutCampaignInput, CustomerEngagementLogUncheckedCreateWithoutCampaignInput> | CustomerEngagementLogCreateWithoutCampaignInput[] | CustomerEngagementLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerEngagementLogCreateOrConnectWithoutCampaignInput | CustomerEngagementLogCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomerEngagementLogUpsertWithWhereUniqueWithoutCampaignInput | CustomerEngagementLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomerEngagementLogCreateManyCampaignInputEnvelope
    set?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
    disconnect?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
    delete?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
    connect?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
    update?: CustomerEngagementLogUpdateWithWhereUniqueWithoutCampaignInput | CustomerEngagementLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomerEngagementLogUpdateManyWithWhereWithoutCampaignInput | CustomerEngagementLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomerEngagementLogScalarWhereInput | CustomerEngagementLogScalarWhereInput[]
  }

  export type PerformanceReportUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PerformanceReportCreateWithoutCampaignInput, PerformanceReportUncheckedCreateWithoutCampaignInput> | PerformanceReportCreateWithoutCampaignInput[] | PerformanceReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PerformanceReportCreateOrConnectWithoutCampaignInput | PerformanceReportCreateOrConnectWithoutCampaignInput[]
    upsert?: PerformanceReportUpsertWithWhereUniqueWithoutCampaignInput | PerformanceReportUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PerformanceReportCreateManyCampaignInputEnvelope
    set?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
    disconnect?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
    delete?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
    connect?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
    update?: PerformanceReportUpdateWithWhereUniqueWithoutCampaignInput | PerformanceReportUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PerformanceReportUpdateManyWithWhereWithoutCampaignInput | PerformanceReportUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PerformanceReportScalarWhereInput | PerformanceReportScalarWhereInput[]
  }

  export type CustomerFeedbackUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomerFeedbackCreateWithoutCampaignInput, CustomerFeedbackUncheckedCreateWithoutCampaignInput> | CustomerFeedbackCreateWithoutCampaignInput[] | CustomerFeedbackUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerFeedbackCreateOrConnectWithoutCampaignInput | CustomerFeedbackCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomerFeedbackUpsertWithWhereUniqueWithoutCampaignInput | CustomerFeedbackUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomerFeedbackCreateManyCampaignInputEnvelope
    set?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
    disconnect?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
    delete?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
    connect?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
    update?: CustomerFeedbackUpdateWithWhereUniqueWithoutCampaignInput | CustomerFeedbackUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomerFeedbackUpdateManyWithWhereWithoutCampaignInput | CustomerFeedbackUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomerFeedbackScalarWhereInput | CustomerFeedbackScalarWhereInput[]
  }

  export type ThankYouMessageUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ThankYouMessageCreateWithoutCampaignInput, ThankYouMessageUncheckedCreateWithoutCampaignInput> | ThankYouMessageCreateWithoutCampaignInput[] | ThankYouMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ThankYouMessageCreateOrConnectWithoutCampaignInput | ThankYouMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: ThankYouMessageUpsertWithWhereUniqueWithoutCampaignInput | ThankYouMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ThankYouMessageCreateManyCampaignInputEnvelope
    set?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
    disconnect?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
    delete?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
    connect?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
    update?: ThankYouMessageUpdateWithWhereUniqueWithoutCampaignInput | ThankYouMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ThankYouMessageUpdateManyWithWhereWithoutCampaignInput | ThankYouMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ThankYouMessageScalarWhereInput | ThankYouMessageScalarWhereInput[]
  }

  export type RetargetingPlanUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<RetargetingPlanCreateWithoutCampaignInput, RetargetingPlanUncheckedCreateWithoutCampaignInput> | RetargetingPlanCreateWithoutCampaignInput[] | RetargetingPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RetargetingPlanCreateOrConnectWithoutCampaignInput | RetargetingPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: RetargetingPlanUpsertWithWhereUniqueWithoutCampaignInput | RetargetingPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: RetargetingPlanCreateManyCampaignInputEnvelope
    set?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
    disconnect?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
    delete?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
    connect?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
    update?: RetargetingPlanUpdateWithWhereUniqueWithoutCampaignInput | RetargetingPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: RetargetingPlanUpdateManyWithWhereWithoutCampaignInput | RetargetingPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: RetargetingPlanScalarWhereInput | RetargetingPlanScalarWhereInput[]
  }

  export type CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignExtensionPlanCreateWithoutCampaignInput, CampaignExtensionPlanUncheckedCreateWithoutCampaignInput> | CampaignExtensionPlanCreateWithoutCampaignInput[] | CampaignExtensionPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignExtensionPlanCreateOrConnectWithoutCampaignInput | CampaignExtensionPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignExtensionPlanUpsertWithWhereUniqueWithoutCampaignInput | CampaignExtensionPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignExtensionPlanCreateManyCampaignInputEnvelope
    set?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
    disconnect?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
    delete?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
    connect?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
    update?: CampaignExtensionPlanUpdateWithWhereUniqueWithoutCampaignInput | CampaignExtensionPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignExtensionPlanUpdateManyWithWhereWithoutCampaignInput | CampaignExtensionPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignExtensionPlanScalarWhereInput | CampaignExtensionPlanScalarWhereInput[]
  }

  export type CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignAnalysisReportCreateWithoutCampaignInput, CampaignAnalysisReportUncheckedCreateWithoutCampaignInput> | CampaignAnalysisReportCreateWithoutCampaignInput[] | CampaignAnalysisReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAnalysisReportCreateOrConnectWithoutCampaignInput | CampaignAnalysisReportCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignAnalysisReportUpsertWithWhereUniqueWithoutCampaignInput | CampaignAnalysisReportUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignAnalysisReportCreateManyCampaignInputEnvelope
    set?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
    disconnect?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
    delete?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
    connect?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
    update?: CampaignAnalysisReportUpdateWithWhereUniqueWithoutCampaignInput | CampaignAnalysisReportUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignAnalysisReportUpdateManyWithWhereWithoutCampaignInput | CampaignAnalysisReportUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignAnalysisReportScalarWhereInput | CampaignAnalysisReportScalarWhereInput[]
  }

  export type CampaignLearningsUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLearningsCreateWithoutCampaignInput, CampaignLearningsUncheckedCreateWithoutCampaignInput> | CampaignLearningsCreateWithoutCampaignInput[] | CampaignLearningsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLearningsCreateOrConnectWithoutCampaignInput | CampaignLearningsCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLearningsUpsertWithWhereUniqueWithoutCampaignInput | CampaignLearningsUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLearningsCreateManyCampaignInputEnvelope
    set?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
    disconnect?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
    delete?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
    connect?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
    update?: CampaignLearningsUpdateWithWhereUniqueWithoutCampaignInput | CampaignLearningsUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLearningsUpdateManyWithWhereWithoutCampaignInput | CampaignLearningsUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLearningsScalarWhereInput | CampaignLearningsScalarWhereInput[]
  }

  export type InternalCampaignReportUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<InternalCampaignReportCreateWithoutCampaignInput, InternalCampaignReportUncheckedCreateWithoutCampaignInput> | InternalCampaignReportCreateWithoutCampaignInput[] | InternalCampaignReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InternalCampaignReportCreateOrConnectWithoutCampaignInput | InternalCampaignReportCreateOrConnectWithoutCampaignInput[]
    upsert?: InternalCampaignReportUpsertWithWhereUniqueWithoutCampaignInput | InternalCampaignReportUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: InternalCampaignReportCreateManyCampaignInputEnvelope
    set?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
    disconnect?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
    delete?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
    connect?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
    update?: InternalCampaignReportUpdateWithWhereUniqueWithoutCampaignInput | InternalCampaignReportUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: InternalCampaignReportUpdateManyWithWhereWithoutCampaignInput | InternalCampaignReportUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: InternalCampaignReportScalarWhereInput | InternalCampaignReportScalarWhereInput[]
  }

  export type EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EnterpriseContextCreateWithoutCampaignInput, EnterpriseContextUncheckedCreateWithoutCampaignInput> | EnterpriseContextCreateWithoutCampaignInput[] | EnterpriseContextUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EnterpriseContextCreateOrConnectWithoutCampaignInput | EnterpriseContextCreateOrConnectWithoutCampaignInput[]
    upsert?: EnterpriseContextUpsertWithWhereUniqueWithoutCampaignInput | EnterpriseContextUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EnterpriseContextCreateManyCampaignInputEnvelope
    set?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
    disconnect?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
    delete?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
    connect?: EnterpriseContextWhereUniqueInput | EnterpriseContextWhereUniqueInput[]
    update?: EnterpriseContextUpdateWithWhereUniqueWithoutCampaignInput | EnterpriseContextUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EnterpriseContextUpdateManyWithWhereWithoutCampaignInput | EnterpriseContextUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EnterpriseContextScalarWhereInput | EnterpriseContextScalarWhereInput[]
  }

  export type AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<AudienceSegmentCreateWithoutCampaignInput, AudienceSegmentUncheckedCreateWithoutCampaignInput> | AudienceSegmentCreateWithoutCampaignInput[] | AudienceSegmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AudienceSegmentCreateOrConnectWithoutCampaignInput | AudienceSegmentCreateOrConnectWithoutCampaignInput[]
    upsert?: AudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput | AudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: AudienceSegmentCreateManyCampaignInputEnvelope
    set?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
    disconnect?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
    delete?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
    connect?: AudienceSegmentWhereUniqueInput | AudienceSegmentWhereUniqueInput[]
    update?: AudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput | AudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: AudienceSegmentUpdateManyWithWhereWithoutCampaignInput | AudienceSegmentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: AudienceSegmentScalarWhereInput | AudienceSegmentScalarWhereInput[]
  }

  export type CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CreativeDesignPlanCreateWithoutCampaignInput, CreativeDesignPlanUncheckedCreateWithoutCampaignInput> | CreativeDesignPlanCreateWithoutCampaignInput[] | CreativeDesignPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CreativeDesignPlanCreateOrConnectWithoutCampaignInput | CreativeDesignPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: CreativeDesignPlanUpsertWithWhereUniqueWithoutCampaignInput | CreativeDesignPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CreativeDesignPlanCreateManyCampaignInputEnvelope
    set?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
    disconnect?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
    delete?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
    connect?: CreativeDesignPlanWhereUniqueInput | CreativeDesignPlanWhereUniqueInput[]
    update?: CreativeDesignPlanUpdateWithWhereUniqueWithoutCampaignInput | CreativeDesignPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CreativeDesignPlanUpdateManyWithWhereWithoutCampaignInput | CreativeDesignPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CreativeDesignPlanScalarWhereInput | CreativeDesignPlanScalarWhereInput[]
  }

  export type CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignObjectiveCreateWithoutCampaignInput, CampaignObjectiveUncheckedCreateWithoutCampaignInput> | CampaignObjectiveCreateWithoutCampaignInput[] | CampaignObjectiveUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignObjectiveCreateOrConnectWithoutCampaignInput | CampaignObjectiveCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignObjectiveUpsertWithWhereUniqueWithoutCampaignInput | CampaignObjectiveUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignObjectiveCreateManyCampaignInputEnvelope
    set?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
    disconnect?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
    delete?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
    connect?: CampaignObjectiveWhereUniqueInput | CampaignObjectiveWhereUniqueInput[]
    update?: CampaignObjectiveUpdateWithWhereUniqueWithoutCampaignInput | CampaignObjectiveUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignObjectiveUpdateManyWithWhereWithoutCampaignInput | CampaignObjectiveUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignObjectiveScalarWhereInput | CampaignObjectiveScalarWhereInput[]
  }

  export type TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TargetAudienceSegmentCreateWithoutCampaignInput, TargetAudienceSegmentUncheckedCreateWithoutCampaignInput> | TargetAudienceSegmentCreateWithoutCampaignInput[] | TargetAudienceSegmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TargetAudienceSegmentCreateOrConnectWithoutCampaignInput | TargetAudienceSegmentCreateOrConnectWithoutCampaignInput[]
    upsert?: TargetAudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput | TargetAudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TargetAudienceSegmentCreateManyCampaignInputEnvelope
    set?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
    disconnect?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
    delete?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
    connect?: TargetAudienceSegmentWhereUniqueInput | TargetAudienceSegmentWhereUniqueInput[]
    update?: TargetAudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput | TargetAudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TargetAudienceSegmentUpdateManyWithWhereWithoutCampaignInput | TargetAudienceSegmentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TargetAudienceSegmentScalarWhereInput | TargetAudienceSegmentScalarWhereInput[]
  }

  export type CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CompetitorStrategyCreateWithoutCampaignInput, CompetitorStrategyUncheckedCreateWithoutCampaignInput> | CompetitorStrategyCreateWithoutCampaignInput[] | CompetitorStrategyUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CompetitorStrategyCreateOrConnectWithoutCampaignInput | CompetitorStrategyCreateOrConnectWithoutCampaignInput[]
    upsert?: CompetitorStrategyUpsertWithWhereUniqueWithoutCampaignInput | CompetitorStrategyUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CompetitorStrategyCreateManyCampaignInputEnvelope
    set?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
    disconnect?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
    delete?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
    connect?: CompetitorStrategyWhereUniqueInput | CompetitorStrategyWhereUniqueInput[]
    update?: CompetitorStrategyUpdateWithWhereUniqueWithoutCampaignInput | CompetitorStrategyUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CompetitorStrategyUpdateManyWithWhereWithoutCampaignInput | CompetitorStrategyUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CompetitorStrategyScalarWhereInput | CompetitorStrategyScalarWhereInput[]
  }

  export type PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PromotionTypeCreateWithoutCampaignInput, PromotionTypeUncheckedCreateWithoutCampaignInput> | PromotionTypeCreateWithoutCampaignInput[] | PromotionTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PromotionTypeCreateOrConnectWithoutCampaignInput | PromotionTypeCreateOrConnectWithoutCampaignInput[]
    upsert?: PromotionTypeUpsertWithWhereUniqueWithoutCampaignInput | PromotionTypeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PromotionTypeCreateManyCampaignInputEnvelope
    set?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
    disconnect?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
    delete?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
    connect?: PromotionTypeWhereUniqueInput | PromotionTypeWhereUniqueInput[]
    update?: PromotionTypeUpdateWithWhereUniqueWithoutCampaignInput | PromotionTypeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PromotionTypeUpdateManyWithWhereWithoutCampaignInput | PromotionTypeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PromotionTypeScalarWhereInput | PromotionTypeScalarWhereInput[]
  }

  export type CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignOfferCreateWithoutCampaignInput, CampaignOfferUncheckedCreateWithoutCampaignInput> | CampaignOfferCreateWithoutCampaignInput[] | CampaignOfferUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignOfferCreateOrConnectWithoutCampaignInput | CampaignOfferCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignOfferUpsertWithWhereUniqueWithoutCampaignInput | CampaignOfferUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignOfferCreateManyCampaignInputEnvelope
    set?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
    disconnect?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
    delete?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
    connect?: CampaignOfferWhereUniqueInput | CampaignOfferWhereUniqueInput[]
    update?: CampaignOfferUpdateWithWhereUniqueWithoutCampaignInput | CampaignOfferUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignOfferUpdateManyWithWhereWithoutCampaignInput | CampaignOfferUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignOfferScalarWhereInput | CampaignOfferScalarWhereInput[]
  }

  export type CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignBudgetCreateWithoutCampaignInput, CampaignBudgetUncheckedCreateWithoutCampaignInput> | CampaignBudgetCreateWithoutCampaignInput[] | CampaignBudgetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignBudgetCreateOrConnectWithoutCampaignInput | CampaignBudgetCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignBudgetUpsertWithWhereUniqueWithoutCampaignInput | CampaignBudgetUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignBudgetCreateManyCampaignInputEnvelope
    set?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
    disconnect?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
    delete?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
    connect?: CampaignBudgetWhereUniqueInput | CampaignBudgetWhereUniqueInput[]
    update?: CampaignBudgetUpdateWithWhereUniqueWithoutCampaignInput | CampaignBudgetUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignBudgetUpdateManyWithWhereWithoutCampaignInput | CampaignBudgetUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignBudgetScalarWhereInput | CampaignBudgetScalarWhereInput[]
  }

  export type ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ChannelPlanCreateWithoutCampaignInput, ChannelPlanUncheckedCreateWithoutCampaignInput> | ChannelPlanCreateWithoutCampaignInput[] | ChannelPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ChannelPlanCreateOrConnectWithoutCampaignInput | ChannelPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: ChannelPlanUpsertWithWhereUniqueWithoutCampaignInput | ChannelPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ChannelPlanCreateManyCampaignInputEnvelope
    set?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
    disconnect?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
    delete?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
    connect?: ChannelPlanWhereUniqueInput | ChannelPlanWhereUniqueInput[]
    update?: ChannelPlanUpdateWithWhereUniqueWithoutCampaignInput | ChannelPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ChannelPlanUpdateManyWithWhereWithoutCampaignInput | ChannelPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ChannelPlanScalarWhereInput | ChannelPlanScalarWhereInput[]
  }

  export type CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignTimelineCreateWithoutCampaignInput, CampaignTimelineUncheckedCreateWithoutCampaignInput> | CampaignTimelineCreateWithoutCampaignInput[] | CampaignTimelineUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTimelineCreateOrConnectWithoutCampaignInput | CampaignTimelineCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignTimelineUpsertWithWhereUniqueWithoutCampaignInput | CampaignTimelineUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignTimelineCreateManyCampaignInputEnvelope
    set?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
    disconnect?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
    delete?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
    connect?: CampaignTimelineWhereUniqueInput | CampaignTimelineWhereUniqueInput[]
    update?: CampaignTimelineUpdateWithWhereUniqueWithoutCampaignInput | CampaignTimelineUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignTimelineUpdateManyWithWhereWithoutCampaignInput | CampaignTimelineUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignTimelineScalarWhereInput | CampaignTimelineScalarWhereInput[]
  }

  export type ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ComplianceChecklistCreateWithoutCampaignInput, ComplianceChecklistUncheckedCreateWithoutCampaignInput> | ComplianceChecklistCreateWithoutCampaignInput[] | ComplianceChecklistUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ComplianceChecklistCreateOrConnectWithoutCampaignInput | ComplianceChecklistCreateOrConnectWithoutCampaignInput[]
    upsert?: ComplianceChecklistUpsertWithWhereUniqueWithoutCampaignInput | ComplianceChecklistUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ComplianceChecklistCreateManyCampaignInputEnvelope
    set?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
    disconnect?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
    delete?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
    connect?: ComplianceChecklistWhereUniqueInput | ComplianceChecklistWhereUniqueInput[]
    update?: ComplianceChecklistUpdateWithWhereUniqueWithoutCampaignInput | ComplianceChecklistUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ComplianceChecklistUpdateManyWithWhereWithoutCampaignInput | ComplianceChecklistUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ComplianceChecklistScalarWhereInput | ComplianceChecklistScalarWhereInput[]
  }

  export type CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CreativeAssetCreateWithoutCampaignInput, CreativeAssetUncheckedCreateWithoutCampaignInput> | CreativeAssetCreateWithoutCampaignInput[] | CreativeAssetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CreativeAssetCreateOrConnectWithoutCampaignInput | CreativeAssetCreateOrConnectWithoutCampaignInput[]
    upsert?: CreativeAssetUpsertWithWhereUniqueWithoutCampaignInput | CreativeAssetUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CreativeAssetCreateManyCampaignInputEnvelope
    set?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
    disconnect?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
    delete?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
    connect?: CreativeAssetWhereUniqueInput | CreativeAssetWhereUniqueInput[]
    update?: CreativeAssetUpdateWithWhereUniqueWithoutCampaignInput | CreativeAssetUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CreativeAssetUpdateManyWithWhereWithoutCampaignInput | CreativeAssetUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CreativeAssetScalarWhereInput | CreativeAssetScalarWhereInput[]
  }

  export type PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PromotionalMessageCreateWithoutCampaignInput, PromotionalMessageUncheckedCreateWithoutCampaignInput> | PromotionalMessageCreateWithoutCampaignInput[] | PromotionalMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PromotionalMessageCreateOrConnectWithoutCampaignInput | PromotionalMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: PromotionalMessageUpsertWithWhereUniqueWithoutCampaignInput | PromotionalMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PromotionalMessageCreateManyCampaignInputEnvelope
    set?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
    disconnect?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
    delete?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
    connect?: PromotionalMessageWhereUniqueInput | PromotionalMessageWhereUniqueInput[]
    update?: PromotionalMessageUpdateWithWhereUniqueWithoutCampaignInput | PromotionalMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PromotionalMessageUpdateManyWithWhereWithoutCampaignInput | PromotionalMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PromotionalMessageScalarWhereInput | PromotionalMessageScalarWhereInput[]
  }

  export type MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MediaAssetCreateWithoutCampaignInput, MediaAssetUncheckedCreateWithoutCampaignInput> | MediaAssetCreateWithoutCampaignInput[] | MediaAssetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MediaAssetCreateOrConnectWithoutCampaignInput | MediaAssetCreateOrConnectWithoutCampaignInput[]
    upsert?: MediaAssetUpsertWithWhereUniqueWithoutCampaignInput | MediaAssetUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MediaAssetCreateManyCampaignInputEnvelope
    set?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    disconnect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    delete?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    connect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    update?: MediaAssetUpdateWithWhereUniqueWithoutCampaignInput | MediaAssetUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MediaAssetUpdateManyWithWhereWithoutCampaignInput | MediaAssetUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MediaAssetScalarWhereInput | MediaAssetScalarWhereInput[]
  }

  export type ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ContentCalendarCreateWithoutCampaignInput, ContentCalendarUncheckedCreateWithoutCampaignInput> | ContentCalendarCreateWithoutCampaignInput[] | ContentCalendarUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ContentCalendarCreateOrConnectWithoutCampaignInput | ContentCalendarCreateOrConnectWithoutCampaignInput[]
    upsert?: ContentCalendarUpsertWithWhereUniqueWithoutCampaignInput | ContentCalendarUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ContentCalendarCreateManyCampaignInputEnvelope
    set?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    disconnect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    delete?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    connect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    update?: ContentCalendarUpdateWithWhereUniqueWithoutCampaignInput | ContentCalendarUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ContentCalendarUpdateManyWithWhereWithoutCampaignInput | ContentCalendarUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ContentCalendarScalarWhereInput | ContentCalendarScalarWhereInput[]
  }

  export type TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TeaserContentCreateWithoutCampaignInput, TeaserContentUncheckedCreateWithoutCampaignInput> | TeaserContentCreateWithoutCampaignInput[] | TeaserContentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TeaserContentCreateOrConnectWithoutCampaignInput | TeaserContentCreateOrConnectWithoutCampaignInput[]
    upsert?: TeaserContentUpsertWithWhereUniqueWithoutCampaignInput | TeaserContentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TeaserContentCreateManyCampaignInputEnvelope
    set?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
    disconnect?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
    delete?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
    connect?: TeaserContentWhereUniqueInput | TeaserContentWhereUniqueInput[]
    update?: TeaserContentUpdateWithWhereUniqueWithoutCampaignInput | TeaserContentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TeaserContentUpdateManyWithWhereWithoutCampaignInput | TeaserContentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TeaserContentScalarWhereInput | TeaserContentScalarWhereInput[]
  }

  export type CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomerSegmentListCreateWithoutCampaignInput, CustomerSegmentListUncheckedCreateWithoutCampaignInput> | CustomerSegmentListCreateWithoutCampaignInput[] | CustomerSegmentListUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerSegmentListCreateOrConnectWithoutCampaignInput | CustomerSegmentListCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomerSegmentListUpsertWithWhereUniqueWithoutCampaignInput | CustomerSegmentListUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomerSegmentListCreateManyCampaignInputEnvelope
    set?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
    disconnect?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
    delete?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
    connect?: CustomerSegmentListWhereUniqueInput | CustomerSegmentListWhereUniqueInput[]
    update?: CustomerSegmentListUpdateWithWhereUniqueWithoutCampaignInput | CustomerSegmentListUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomerSegmentListUpdateManyWithWhereWithoutCampaignInput | CustomerSegmentListUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomerSegmentListScalarWhereInput | CustomerSegmentListScalarWhereInput[]
  }

  export type InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<InfluencerPlanCreateWithoutCampaignInput, InfluencerPlanUncheckedCreateWithoutCampaignInput> | InfluencerPlanCreateWithoutCampaignInput[] | InfluencerPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InfluencerPlanCreateOrConnectWithoutCampaignInput | InfluencerPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: InfluencerPlanUpsertWithWhereUniqueWithoutCampaignInput | InfluencerPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: InfluencerPlanCreateManyCampaignInputEnvelope
    set?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
    disconnect?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
    delete?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
    connect?: InfluencerPlanWhereUniqueInput | InfluencerPlanWhereUniqueInput[]
    update?: InfluencerPlanUpdateWithWhereUniqueWithoutCampaignInput | InfluencerPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: InfluencerPlanUpdateManyWithWhereWithoutCampaignInput | InfluencerPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: InfluencerPlanScalarWhereInput | InfluencerPlanScalarWhereInput[]
  }

  export type OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<OperationalChecklistCreateWithoutCampaignInput, OperationalChecklistUncheckedCreateWithoutCampaignInput> | OperationalChecklistCreateWithoutCampaignInput[] | OperationalChecklistUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: OperationalChecklistCreateOrConnectWithoutCampaignInput | OperationalChecklistCreateOrConnectWithoutCampaignInput[]
    upsert?: OperationalChecklistUpsertWithWhereUniqueWithoutCampaignInput | OperationalChecklistUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: OperationalChecklistCreateManyCampaignInputEnvelope
    set?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
    disconnect?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
    delete?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
    connect?: OperationalChecklistWhereUniqueInput | OperationalChecklistWhereUniqueInput[]
    update?: OperationalChecklistUpdateWithWhereUniqueWithoutCampaignInput | OperationalChecklistUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: OperationalChecklistUpdateManyWithWhereWithoutCampaignInput | OperationalChecklistUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: OperationalChecklistScalarWhereInput | OperationalChecklistScalarWhereInput[]
  }

  export type CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignActivationCreateWithoutCampaignInput, CampaignActivationUncheckedCreateWithoutCampaignInput> | CampaignActivationCreateWithoutCampaignInput[] | CampaignActivationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignActivationCreateOrConnectWithoutCampaignInput | CampaignActivationCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignActivationUpsertWithWhereUniqueWithoutCampaignInput | CampaignActivationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignActivationCreateManyCampaignInputEnvelope
    set?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
    disconnect?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
    delete?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
    connect?: CampaignActivationWhereUniqueInput | CampaignActivationWhereUniqueInput[]
    update?: CampaignActivationUpdateWithWhereUniqueWithoutCampaignInput | CampaignActivationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignActivationUpdateManyWithWhereWithoutCampaignInput | CampaignActivationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignActivationScalarWhereInput | CampaignActivationScalarWhereInput[]
  }

  export type CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomerEngagementLogCreateWithoutCampaignInput, CustomerEngagementLogUncheckedCreateWithoutCampaignInput> | CustomerEngagementLogCreateWithoutCampaignInput[] | CustomerEngagementLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerEngagementLogCreateOrConnectWithoutCampaignInput | CustomerEngagementLogCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomerEngagementLogUpsertWithWhereUniqueWithoutCampaignInput | CustomerEngagementLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomerEngagementLogCreateManyCampaignInputEnvelope
    set?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
    disconnect?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
    delete?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
    connect?: CustomerEngagementLogWhereUniqueInput | CustomerEngagementLogWhereUniqueInput[]
    update?: CustomerEngagementLogUpdateWithWhereUniqueWithoutCampaignInput | CustomerEngagementLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomerEngagementLogUpdateManyWithWhereWithoutCampaignInput | CustomerEngagementLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomerEngagementLogScalarWhereInput | CustomerEngagementLogScalarWhereInput[]
  }

  export type PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PerformanceReportCreateWithoutCampaignInput, PerformanceReportUncheckedCreateWithoutCampaignInput> | PerformanceReportCreateWithoutCampaignInput[] | PerformanceReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PerformanceReportCreateOrConnectWithoutCampaignInput | PerformanceReportCreateOrConnectWithoutCampaignInput[]
    upsert?: PerformanceReportUpsertWithWhereUniqueWithoutCampaignInput | PerformanceReportUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PerformanceReportCreateManyCampaignInputEnvelope
    set?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
    disconnect?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
    delete?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
    connect?: PerformanceReportWhereUniqueInput | PerformanceReportWhereUniqueInput[]
    update?: PerformanceReportUpdateWithWhereUniqueWithoutCampaignInput | PerformanceReportUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PerformanceReportUpdateManyWithWhereWithoutCampaignInput | PerformanceReportUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PerformanceReportScalarWhereInput | PerformanceReportScalarWhereInput[]
  }

  export type CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomerFeedbackCreateWithoutCampaignInput, CustomerFeedbackUncheckedCreateWithoutCampaignInput> | CustomerFeedbackCreateWithoutCampaignInput[] | CustomerFeedbackUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomerFeedbackCreateOrConnectWithoutCampaignInput | CustomerFeedbackCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomerFeedbackUpsertWithWhereUniqueWithoutCampaignInput | CustomerFeedbackUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomerFeedbackCreateManyCampaignInputEnvelope
    set?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
    disconnect?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
    delete?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
    connect?: CustomerFeedbackWhereUniqueInput | CustomerFeedbackWhereUniqueInput[]
    update?: CustomerFeedbackUpdateWithWhereUniqueWithoutCampaignInput | CustomerFeedbackUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomerFeedbackUpdateManyWithWhereWithoutCampaignInput | CustomerFeedbackUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomerFeedbackScalarWhereInput | CustomerFeedbackScalarWhereInput[]
  }

  export type ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ThankYouMessageCreateWithoutCampaignInput, ThankYouMessageUncheckedCreateWithoutCampaignInput> | ThankYouMessageCreateWithoutCampaignInput[] | ThankYouMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ThankYouMessageCreateOrConnectWithoutCampaignInput | ThankYouMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: ThankYouMessageUpsertWithWhereUniqueWithoutCampaignInput | ThankYouMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ThankYouMessageCreateManyCampaignInputEnvelope
    set?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
    disconnect?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
    delete?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
    connect?: ThankYouMessageWhereUniqueInput | ThankYouMessageWhereUniqueInput[]
    update?: ThankYouMessageUpdateWithWhereUniqueWithoutCampaignInput | ThankYouMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ThankYouMessageUpdateManyWithWhereWithoutCampaignInput | ThankYouMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ThankYouMessageScalarWhereInput | ThankYouMessageScalarWhereInput[]
  }

  export type RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<RetargetingPlanCreateWithoutCampaignInput, RetargetingPlanUncheckedCreateWithoutCampaignInput> | RetargetingPlanCreateWithoutCampaignInput[] | RetargetingPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: RetargetingPlanCreateOrConnectWithoutCampaignInput | RetargetingPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: RetargetingPlanUpsertWithWhereUniqueWithoutCampaignInput | RetargetingPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: RetargetingPlanCreateManyCampaignInputEnvelope
    set?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
    disconnect?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
    delete?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
    connect?: RetargetingPlanWhereUniqueInput | RetargetingPlanWhereUniqueInput[]
    update?: RetargetingPlanUpdateWithWhereUniqueWithoutCampaignInput | RetargetingPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: RetargetingPlanUpdateManyWithWhereWithoutCampaignInput | RetargetingPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: RetargetingPlanScalarWhereInput | RetargetingPlanScalarWhereInput[]
  }

  export type CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignExtensionPlanCreateWithoutCampaignInput, CampaignExtensionPlanUncheckedCreateWithoutCampaignInput> | CampaignExtensionPlanCreateWithoutCampaignInput[] | CampaignExtensionPlanUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignExtensionPlanCreateOrConnectWithoutCampaignInput | CampaignExtensionPlanCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignExtensionPlanUpsertWithWhereUniqueWithoutCampaignInput | CampaignExtensionPlanUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignExtensionPlanCreateManyCampaignInputEnvelope
    set?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
    disconnect?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
    delete?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
    connect?: CampaignExtensionPlanWhereUniqueInput | CampaignExtensionPlanWhereUniqueInput[]
    update?: CampaignExtensionPlanUpdateWithWhereUniqueWithoutCampaignInput | CampaignExtensionPlanUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignExtensionPlanUpdateManyWithWhereWithoutCampaignInput | CampaignExtensionPlanUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignExtensionPlanScalarWhereInput | CampaignExtensionPlanScalarWhereInput[]
  }

  export type CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignAnalysisReportCreateWithoutCampaignInput, CampaignAnalysisReportUncheckedCreateWithoutCampaignInput> | CampaignAnalysisReportCreateWithoutCampaignInput[] | CampaignAnalysisReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAnalysisReportCreateOrConnectWithoutCampaignInput | CampaignAnalysisReportCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignAnalysisReportUpsertWithWhereUniqueWithoutCampaignInput | CampaignAnalysisReportUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignAnalysisReportCreateManyCampaignInputEnvelope
    set?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
    disconnect?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
    delete?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
    connect?: CampaignAnalysisReportWhereUniqueInput | CampaignAnalysisReportWhereUniqueInput[]
    update?: CampaignAnalysisReportUpdateWithWhereUniqueWithoutCampaignInput | CampaignAnalysisReportUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignAnalysisReportUpdateManyWithWhereWithoutCampaignInput | CampaignAnalysisReportUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignAnalysisReportScalarWhereInput | CampaignAnalysisReportScalarWhereInput[]
  }

  export type CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLearningsCreateWithoutCampaignInput, CampaignLearningsUncheckedCreateWithoutCampaignInput> | CampaignLearningsCreateWithoutCampaignInput[] | CampaignLearningsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLearningsCreateOrConnectWithoutCampaignInput | CampaignLearningsCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLearningsUpsertWithWhereUniqueWithoutCampaignInput | CampaignLearningsUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLearningsCreateManyCampaignInputEnvelope
    set?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
    disconnect?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
    delete?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
    connect?: CampaignLearningsWhereUniqueInput | CampaignLearningsWhereUniqueInput[]
    update?: CampaignLearningsUpdateWithWhereUniqueWithoutCampaignInput | CampaignLearningsUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLearningsUpdateManyWithWhereWithoutCampaignInput | CampaignLearningsUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLearningsScalarWhereInput | CampaignLearningsScalarWhereInput[]
  }

  export type InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<InternalCampaignReportCreateWithoutCampaignInput, InternalCampaignReportUncheckedCreateWithoutCampaignInput> | InternalCampaignReportCreateWithoutCampaignInput[] | InternalCampaignReportUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InternalCampaignReportCreateOrConnectWithoutCampaignInput | InternalCampaignReportCreateOrConnectWithoutCampaignInput[]
    upsert?: InternalCampaignReportUpsertWithWhereUniqueWithoutCampaignInput | InternalCampaignReportUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: InternalCampaignReportCreateManyCampaignInputEnvelope
    set?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
    disconnect?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
    delete?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
    connect?: InternalCampaignReportWhereUniqueInput | InternalCampaignReportWhereUniqueInput[]
    update?: InternalCampaignReportUpdateWithWhereUniqueWithoutCampaignInput | InternalCampaignReportUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: InternalCampaignReportUpdateManyWithWhereWithoutCampaignInput | InternalCampaignReportUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: InternalCampaignReportScalarWhereInput | InternalCampaignReportScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<CampaignCreateWithoutObjectivesInput, CampaignUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutObjectivesInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutObjectivesNestedInput = {
    create?: XOR<CampaignCreateWithoutObjectivesInput, CampaignUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutObjectivesInput
    upsert?: CampaignUpsertWithoutObjectivesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutObjectivesInput, CampaignUpdateWithoutObjectivesInput>, CampaignUncheckedUpdateWithoutObjectivesInput>
  }

  export type CampaignCreateNestedOneWithoutAudiencesInput = {
    create?: XOR<CampaignCreateWithoutAudiencesInput, CampaignUncheckedCreateWithoutAudiencesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAudiencesInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutAudiencesNestedInput = {
    create?: XOR<CampaignCreateWithoutAudiencesInput, CampaignUncheckedCreateWithoutAudiencesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAudiencesInput
    upsert?: CampaignUpsertWithoutAudiencesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutAudiencesInput, CampaignUpdateWithoutAudiencesInput>, CampaignUncheckedUpdateWithoutAudiencesInput>
  }

  export type CampaignCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<CampaignCreateWithoutPromotionsInput, CampaignUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutPromotionsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutPromotionsNestedInput = {
    create?: XOR<CampaignCreateWithoutPromotionsInput, CampaignUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutPromotionsInput
    upsert?: CampaignUpsertWithoutPromotionsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutPromotionsInput, CampaignUpdateWithoutPromotionsInput>, CampaignUncheckedUpdateWithoutPromotionsInput>
  }

  export type CampaignCreateNestedOneWithoutOffersInput = {
    create?: XOR<CampaignCreateWithoutOffersInput, CampaignUncheckedCreateWithoutOffersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOffersInput
    connect?: CampaignWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<CampaignCreateWithoutOffersInput, CampaignUncheckedCreateWithoutOffersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOffersInput
    upsert?: CampaignUpsertWithoutOffersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutOffersInput, CampaignUpdateWithoutOffersInput>, CampaignUncheckedUpdateWithoutOffersInput>
  }

  export type CampaignCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<CampaignCreateWithoutBudgetsInput, CampaignUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutBudgetsInput
    connect?: CampaignWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<CampaignCreateWithoutBudgetsInput, CampaignUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutBudgetsInput
    upsert?: CampaignUpsertWithoutBudgetsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutBudgetsInput, CampaignUpdateWithoutBudgetsInput>, CampaignUncheckedUpdateWithoutBudgetsInput>
  }

  export type ChannelPlanCreatechannelsInput = {
    set: string[]
  }

  export type ChannelPlanCreatemessageStylesInput = {
    set: string[]
  }

  export type CampaignCreateNestedOneWithoutChannelsInput = {
    create?: XOR<CampaignCreateWithoutChannelsInput, CampaignUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChannelsInput
    connect?: CampaignWhereUniqueInput
  }

  export type ChannelPlanUpdatechannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChannelPlanUpdatemessageStylesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CampaignUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<CampaignCreateWithoutChannelsInput, CampaignUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChannelsInput
    upsert?: CampaignUpsertWithoutChannelsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutChannelsInput, CampaignUpdateWithoutChannelsInput>, CampaignUncheckedUpdateWithoutChannelsInput>
  }

  export type CampaignCreateNestedOneWithoutTimelinesInput = {
    create?: XOR<CampaignCreateWithoutTimelinesInput, CampaignUncheckedCreateWithoutTimelinesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTimelinesInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutTimelinesNestedInput = {
    create?: XOR<CampaignCreateWithoutTimelinesInput, CampaignUncheckedCreateWithoutTimelinesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTimelinesInput
    upsert?: CampaignUpsertWithoutTimelinesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTimelinesInput, CampaignUpdateWithoutTimelinesInput>, CampaignUncheckedUpdateWithoutTimelinesInput>
  }

  export type CampaignCreateNestedOneWithoutCompliancesInput = {
    create?: XOR<CampaignCreateWithoutCompliancesInput, CampaignUncheckedCreateWithoutCompliancesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCompliancesInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCompliancesNestedInput = {
    create?: XOR<CampaignCreateWithoutCompliancesInput, CampaignUncheckedCreateWithoutCompliancesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCompliancesInput
    upsert?: CampaignUpsertWithoutCompliancesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCompliancesInput, CampaignUpdateWithoutCompliancesInput>, CampaignUncheckedUpdateWithoutCompliancesInput>
  }

  export type CampaignCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessagesInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessagesInput
    upsert?: CampaignUpsertWithoutMessagesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMessagesInput, CampaignUpdateWithoutMessagesInput>, CampaignUncheckedUpdateWithoutMessagesInput>
  }

  export type CampaignCreateNestedOneWithoutCreativePlansInput = {
    create?: XOR<CampaignCreateWithoutCreativePlansInput, CampaignUncheckedCreateWithoutCreativePlansInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCreativePlansInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCreativePlansNestedInput = {
    create?: XOR<CampaignCreateWithoutCreativePlansInput, CampaignUncheckedCreateWithoutCreativePlansInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCreativePlansInput
    upsert?: CampaignUpsertWithoutCreativePlansInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCreativePlansInput, CampaignUpdateWithoutCreativePlansInput>, CampaignUncheckedUpdateWithoutCreativePlansInput>
  }

  export type CampaignCreateNestedOneWithoutCreativesInput = {
    create?: XOR<CampaignCreateWithoutCreativesInput, CampaignUncheckedCreateWithoutCreativesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCreativesInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCreativesNestedInput = {
    create?: XOR<CampaignCreateWithoutCreativesInput, CampaignUncheckedCreateWithoutCreativesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCreativesInput
    upsert?: CampaignUpsertWithoutCreativesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCreativesInput, CampaignUpdateWithoutCreativesInput>, CampaignUncheckedUpdateWithoutCreativesInput>
  }

  export type CampaignCreateNestedOneWithoutMediaAssetsInput = {
    create?: XOR<CampaignCreateWithoutMediaAssetsInput, CampaignUncheckedCreateWithoutMediaAssetsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMediaAssetsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutMediaAssetsNestedInput = {
    create?: XOR<CampaignCreateWithoutMediaAssetsInput, CampaignUncheckedCreateWithoutMediaAssetsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMediaAssetsInput
    upsert?: CampaignUpsertWithoutMediaAssetsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMediaAssetsInput, CampaignUpdateWithoutMediaAssetsInput>, CampaignUncheckedUpdateWithoutMediaAssetsInput>
  }

  export type CampaignCreateNestedOneWithoutCalendarsInput = {
    create?: XOR<CampaignCreateWithoutCalendarsInput, CampaignUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCalendarsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCalendarsNestedInput = {
    create?: XOR<CampaignCreateWithoutCalendarsInput, CampaignUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCalendarsInput
    upsert?: CampaignUpsertWithoutCalendarsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCalendarsInput, CampaignUpdateWithoutCalendarsInput>, CampaignUncheckedUpdateWithoutCalendarsInput>
  }

  export type CampaignCreateNestedOneWithoutTeasersInput = {
    create?: XOR<CampaignCreateWithoutTeasersInput, CampaignUncheckedCreateWithoutTeasersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTeasersInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutTeasersNestedInput = {
    create?: XOR<CampaignCreateWithoutTeasersInput, CampaignUncheckedCreateWithoutTeasersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTeasersInput
    upsert?: CampaignUpsertWithoutTeasersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTeasersInput, CampaignUpdateWithoutTeasersInput>, CampaignUncheckedUpdateWithoutTeasersInput>
  }

  export type CampaignCreateNestedOneWithoutCustomersInput = {
    create?: XOR<CampaignCreateWithoutCustomersInput, CampaignUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCustomersInput
    connect?: CampaignWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<CampaignCreateWithoutCustomersInput, CampaignUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCustomersInput
    upsert?: CampaignUpsertWithoutCustomersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCustomersInput, CampaignUpdateWithoutCustomersInput>, CampaignUncheckedUpdateWithoutCustomersInput>
  }

  export type CampaignCreateNestedOneWithoutInfluencersInput = {
    create?: XOR<CampaignCreateWithoutInfluencersInput, CampaignUncheckedCreateWithoutInfluencersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutInfluencersInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutInfluencersNestedInput = {
    create?: XOR<CampaignCreateWithoutInfluencersInput, CampaignUncheckedCreateWithoutInfluencersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutInfluencersInput
    upsert?: CampaignUpsertWithoutInfluencersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutInfluencersInput, CampaignUpdateWithoutInfluencersInput>, CampaignUncheckedUpdateWithoutInfluencersInput>
  }

  export type CampaignCreateNestedOneWithoutChecklistsInput = {
    create?: XOR<CampaignCreateWithoutChecklistsInput, CampaignUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChecklistsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutChecklistsNestedInput = {
    create?: XOR<CampaignCreateWithoutChecklistsInput, CampaignUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChecklistsInput
    upsert?: CampaignUpsertWithoutChecklistsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutChecklistsInput, CampaignUpdateWithoutChecklistsInput>, CampaignUncheckedUpdateWithoutChecklistsInput>
  }

  export type CampaignCreateNestedOneWithoutActivationsInput = {
    create?: XOR<CampaignCreateWithoutActivationsInput, CampaignUncheckedCreateWithoutActivationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutActivationsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutActivationsNestedInput = {
    create?: XOR<CampaignCreateWithoutActivationsInput, CampaignUncheckedCreateWithoutActivationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutActivationsInput
    upsert?: CampaignUpsertWithoutActivationsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutActivationsInput, CampaignUpdateWithoutActivationsInput>, CampaignUncheckedUpdateWithoutActivationsInput>
  }

  export type CampaignCreateNestedOneWithoutEngagementsInput = {
    create?: XOR<CampaignCreateWithoutEngagementsInput, CampaignUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEngagementsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutEngagementsNestedInput = {
    create?: XOR<CampaignCreateWithoutEngagementsInput, CampaignUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEngagementsInput
    upsert?: CampaignUpsertWithoutEngagementsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutEngagementsInput, CampaignUpdateWithoutEngagementsInput>, CampaignUncheckedUpdateWithoutEngagementsInput>
  }

  export type CampaignCreateNestedOneWithoutReportsInput = {
    create?: XOR<CampaignCreateWithoutReportsInput, CampaignUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutReportsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<CampaignCreateWithoutReportsInput, CampaignUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutReportsInput
    upsert?: CampaignUpsertWithoutReportsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutReportsInput, CampaignUpdateWithoutReportsInput>, CampaignUncheckedUpdateWithoutReportsInput>
  }

  export type CampaignCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<CampaignCreateWithoutFeedbacksInput, CampaignUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutFeedbacksInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<CampaignCreateWithoutFeedbacksInput, CampaignUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutFeedbacksInput
    upsert?: CampaignUpsertWithoutFeedbacksInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutFeedbacksInput, CampaignUpdateWithoutFeedbacksInput>, CampaignUncheckedUpdateWithoutFeedbacksInput>
  }

  export type CampaignCreateNestedOneWithoutThanksInput = {
    create?: XOR<CampaignCreateWithoutThanksInput, CampaignUncheckedCreateWithoutThanksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutThanksInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutThanksNestedInput = {
    create?: XOR<CampaignCreateWithoutThanksInput, CampaignUncheckedCreateWithoutThanksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutThanksInput
    upsert?: CampaignUpsertWithoutThanksInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutThanksInput, CampaignUpdateWithoutThanksInput>, CampaignUncheckedUpdateWithoutThanksInput>
  }

  export type CampaignCreateNestedOneWithoutRetargetingsInput = {
    create?: XOR<CampaignCreateWithoutRetargetingsInput, CampaignUncheckedCreateWithoutRetargetingsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRetargetingsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutRetargetingsNestedInput = {
    create?: XOR<CampaignCreateWithoutRetargetingsInput, CampaignUncheckedCreateWithoutRetargetingsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRetargetingsInput
    upsert?: CampaignUpsertWithoutRetargetingsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutRetargetingsInput, CampaignUpdateWithoutRetargetingsInput>, CampaignUncheckedUpdateWithoutRetargetingsInput>
  }

  export type CampaignCreateNestedOneWithoutExtensionsInput = {
    create?: XOR<CampaignCreateWithoutExtensionsInput, CampaignUncheckedCreateWithoutExtensionsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutExtensionsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutExtensionsNestedInput = {
    create?: XOR<CampaignCreateWithoutExtensionsInput, CampaignUncheckedCreateWithoutExtensionsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutExtensionsInput
    upsert?: CampaignUpsertWithoutExtensionsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutExtensionsInput, CampaignUpdateWithoutExtensionsInput>, CampaignUncheckedUpdateWithoutExtensionsInput>
  }

  export type CampaignCreateNestedOneWithoutAnalysisReportsInput = {
    create?: XOR<CampaignCreateWithoutAnalysisReportsInput, CampaignUncheckedCreateWithoutAnalysisReportsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAnalysisReportsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutAnalysisReportsNestedInput = {
    create?: XOR<CampaignCreateWithoutAnalysisReportsInput, CampaignUncheckedCreateWithoutAnalysisReportsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAnalysisReportsInput
    upsert?: CampaignUpsertWithoutAnalysisReportsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutAnalysisReportsInput, CampaignUpdateWithoutAnalysisReportsInput>, CampaignUncheckedUpdateWithoutAnalysisReportsInput>
  }

  export type CampaignCreateNestedOneWithoutLearningsInput = {
    create?: XOR<CampaignCreateWithoutLearningsInput, CampaignUncheckedCreateWithoutLearningsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLearningsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutLearningsNestedInput = {
    create?: XOR<CampaignCreateWithoutLearningsInput, CampaignUncheckedCreateWithoutLearningsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLearningsInput
    upsert?: CampaignUpsertWithoutLearningsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutLearningsInput, CampaignUpdateWithoutLearningsInput>, CampaignUncheckedUpdateWithoutLearningsInput>
  }

  export type CampaignCreateNestedOneWithoutInternalReportsInput = {
    create?: XOR<CampaignCreateWithoutInternalReportsInput, CampaignUncheckedCreateWithoutInternalReportsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutInternalReportsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutInternalReportsNestedInput = {
    create?: XOR<CampaignCreateWithoutInternalReportsInput, CampaignUncheckedCreateWithoutInternalReportsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutInternalReportsInput
    upsert?: CampaignUpsertWithoutInternalReportsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutInternalReportsInput, CampaignUpdateWithoutInternalReportsInput>, CampaignUncheckedUpdateWithoutInternalReportsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CampaignCreateWithoutCompetitorsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCompetitorsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCompetitorsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCompetitorsInput, CampaignUncheckedCreateWithoutCompetitorsInput>
  }

  export type CampaignUpsertWithoutCompetitorsInput = {
    update: XOR<CampaignUpdateWithoutCompetitorsInput, CampaignUncheckedUpdateWithoutCompetitorsInput>
    create: XOR<CampaignCreateWithoutCompetitorsInput, CampaignUncheckedCreateWithoutCompetitorsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCompetitorsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCompetitorsInput, CampaignUncheckedUpdateWithoutCompetitorsInput>
  }

  export type CampaignUpdateWithoutCompetitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCompetitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutEnterpriseContextsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutEnterpriseContextsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutEnterpriseContextsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEnterpriseContextsInput, CampaignUncheckedCreateWithoutEnterpriseContextsInput>
  }

  export type CampaignUpsertWithoutEnterpriseContextsInput = {
    update: XOR<CampaignUpdateWithoutEnterpriseContextsInput, CampaignUncheckedUpdateWithoutEnterpriseContextsInput>
    create: XOR<CampaignCreateWithoutEnterpriseContextsInput, CampaignUncheckedCreateWithoutEnterpriseContextsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutEnterpriseContextsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutEnterpriseContextsInput, CampaignUncheckedUpdateWithoutEnterpriseContextsInput>
  }

  export type CampaignUpdateWithoutEnterpriseContextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutEnterpriseContextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutAudienceSegmentsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAudienceSegmentsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAudienceSegmentsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAudienceSegmentsInput, CampaignUncheckedCreateWithoutAudienceSegmentsInput>
  }

  export type CampaignUpsertWithoutAudienceSegmentsInput = {
    update: XOR<CampaignUpdateWithoutAudienceSegmentsInput, CampaignUncheckedUpdateWithoutAudienceSegmentsInput>
    create: XOR<CampaignCreateWithoutAudienceSegmentsInput, CampaignUncheckedCreateWithoutAudienceSegmentsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutAudienceSegmentsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutAudienceSegmentsInput, CampaignUncheckedUpdateWithoutAudienceSegmentsInput>
  }

  export type CampaignUpdateWithoutAudienceSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAudienceSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EnterpriseContextCreateWithoutCampaignInput = {
    id?: string
    companyName: string
    domain: string
    businessModel: string
    background: string
    currentPain: string
    goals: string
    createdAt?: Date | string
  }

  export type EnterpriseContextUncheckedCreateWithoutCampaignInput = {
    id?: string
    companyName: string
    domain: string
    businessModel: string
    background: string
    currentPain: string
    goals: string
    createdAt?: Date | string
  }

  export type EnterpriseContextCreateOrConnectWithoutCampaignInput = {
    where: EnterpriseContextWhereUniqueInput
    create: XOR<EnterpriseContextCreateWithoutCampaignInput, EnterpriseContextUncheckedCreateWithoutCampaignInput>
  }

  export type EnterpriseContextCreateManyCampaignInputEnvelope = {
    data: EnterpriseContextCreateManyCampaignInput | EnterpriseContextCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type AudienceSegmentCreateWithoutCampaignInput = {
    id?: string
    label: string
    demographics: string
    behavior: string
    painPoints: string
    createdAt?: Date | string
  }

  export type AudienceSegmentUncheckedCreateWithoutCampaignInput = {
    id?: string
    label: string
    demographics: string
    behavior: string
    painPoints: string
    createdAt?: Date | string
  }

  export type AudienceSegmentCreateOrConnectWithoutCampaignInput = {
    where: AudienceSegmentWhereUniqueInput
    create: XOR<AudienceSegmentCreateWithoutCampaignInput, AudienceSegmentUncheckedCreateWithoutCampaignInput>
  }

  export type AudienceSegmentCreateManyCampaignInputEnvelope = {
    data: AudienceSegmentCreateManyCampaignInput | AudienceSegmentCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CreativeDesignPlanCreateWithoutCampaignInput = {
    id?: string
    platform: string
    creativeTitle: string
    headline: string
    visualTheme: string
    cta: string
    mobileOptimizationTip: string
    createdAt?: Date | string
  }

  export type CreativeDesignPlanUncheckedCreateWithoutCampaignInput = {
    id?: string
    platform: string
    creativeTitle: string
    headline: string
    visualTheme: string
    cta: string
    mobileOptimizationTip: string
    createdAt?: Date | string
  }

  export type CreativeDesignPlanCreateOrConnectWithoutCampaignInput = {
    where: CreativeDesignPlanWhereUniqueInput
    create: XOR<CreativeDesignPlanCreateWithoutCampaignInput, CreativeDesignPlanUncheckedCreateWithoutCampaignInput>
  }

  export type CreativeDesignPlanCreateManyCampaignInputEnvelope = {
    data: CreativeDesignPlanCreateManyCampaignInput | CreativeDesignPlanCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignObjectiveCreateWithoutCampaignInput = {
    id?: string
    goal: string
  }

  export type CampaignObjectiveUncheckedCreateWithoutCampaignInput = {
    id?: string
    goal: string
  }

  export type CampaignObjectiveCreateOrConnectWithoutCampaignInput = {
    where: CampaignObjectiveWhereUniqueInput
    create: XOR<CampaignObjectiveCreateWithoutCampaignInput, CampaignObjectiveUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignObjectiveCreateManyCampaignInputEnvelope = {
    data: CampaignObjectiveCreateManyCampaignInput | CampaignObjectiveCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type TargetAudienceSegmentCreateWithoutCampaignInput = {
    id?: string
    segment: string
  }

  export type TargetAudienceSegmentUncheckedCreateWithoutCampaignInput = {
    id?: string
    segment: string
  }

  export type TargetAudienceSegmentCreateOrConnectWithoutCampaignInput = {
    where: TargetAudienceSegmentWhereUniqueInput
    create: XOR<TargetAudienceSegmentCreateWithoutCampaignInput, TargetAudienceSegmentUncheckedCreateWithoutCampaignInput>
  }

  export type TargetAudienceSegmentCreateManyCampaignInputEnvelope = {
    data: TargetAudienceSegmentCreateManyCampaignInput | TargetAudienceSegmentCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CompetitorStrategyCreateWithoutCampaignInput = {
    id?: string
    competitor: string
    promotionType: string
    channels: string
    strength: string
    weakness: string
    createdAt?: Date | string
  }

  export type CompetitorStrategyUncheckedCreateWithoutCampaignInput = {
    id?: string
    competitor: string
    promotionType: string
    channels: string
    strength: string
    weakness: string
    createdAt?: Date | string
  }

  export type CompetitorStrategyCreateOrConnectWithoutCampaignInput = {
    where: CompetitorStrategyWhereUniqueInput
    create: XOR<CompetitorStrategyCreateWithoutCampaignInput, CompetitorStrategyUncheckedCreateWithoutCampaignInput>
  }

  export type CompetitorStrategyCreateManyCampaignInputEnvelope = {
    data: CompetitorStrategyCreateManyCampaignInput | CompetitorStrategyCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type PromotionTypeCreateWithoutCampaignInput = {
    id?: string
    type: string
  }

  export type PromotionTypeUncheckedCreateWithoutCampaignInput = {
    id?: string
    type: string
  }

  export type PromotionTypeCreateOrConnectWithoutCampaignInput = {
    where: PromotionTypeWhereUniqueInput
    create: XOR<PromotionTypeCreateWithoutCampaignInput, PromotionTypeUncheckedCreateWithoutCampaignInput>
  }

  export type PromotionTypeCreateManyCampaignInputEnvelope = {
    data: PromotionTypeCreateManyCampaignInput | PromotionTypeCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignOfferCreateWithoutCampaignInput = {
    id?: string
    description: string
    offerLimit?: number | null
    offerType?: string | null
    successCriteria?: string | null
    backupOffer?: string | null
    createdAt?: Date | string
  }

  export type CampaignOfferUncheckedCreateWithoutCampaignInput = {
    id?: string
    description: string
    offerLimit?: number | null
    offerType?: string | null
    successCriteria?: string | null
    backupOffer?: string | null
    createdAt?: Date | string
  }

  export type CampaignOfferCreateOrConnectWithoutCampaignInput = {
    where: CampaignOfferWhereUniqueInput
    create: XOR<CampaignOfferCreateWithoutCampaignInput, CampaignOfferUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignOfferCreateManyCampaignInputEnvelope = {
    data: CampaignOfferCreateManyCampaignInput | CampaignOfferCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignBudgetCreateWithoutCampaignInput = {
    id?: string
    mediaSpend: number
    creativeSpend: number
    incentiveSpend: number
    logisticsSpend: number
    totalBudget: number
    costPerCustomer: number
    expectedROI?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CampaignBudgetUncheckedCreateWithoutCampaignInput = {
    id?: string
    mediaSpend: number
    creativeSpend: number
    incentiveSpend: number
    logisticsSpend: number
    totalBudget: number
    costPerCustomer: number
    expectedROI?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type CampaignBudgetCreateOrConnectWithoutCampaignInput = {
    where: CampaignBudgetWhereUniqueInput
    create: XOR<CampaignBudgetCreateWithoutCampaignInput, CampaignBudgetUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignBudgetCreateManyCampaignInputEnvelope = {
    data: CampaignBudgetCreateManyCampaignInput | CampaignBudgetCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ChannelPlanCreateWithoutCampaignInput = {
    id?: string
    channels?: ChannelPlanCreatechannelsInput | string[]
    primary: string
    primaryReason: string
    messageStyles?: ChannelPlanCreatemessageStylesInput | string[]
    createdAt?: Date | string
  }

  export type ChannelPlanUncheckedCreateWithoutCampaignInput = {
    id?: string
    channels?: ChannelPlanCreatechannelsInput | string[]
    primary: string
    primaryReason: string
    messageStyles?: ChannelPlanCreatemessageStylesInput | string[]
    createdAt?: Date | string
  }

  export type ChannelPlanCreateOrConnectWithoutCampaignInput = {
    where: ChannelPlanWhereUniqueInput
    create: XOR<ChannelPlanCreateWithoutCampaignInput, ChannelPlanUncheckedCreateWithoutCampaignInput>
  }

  export type ChannelPlanCreateManyCampaignInputEnvelope = {
    data: ChannelPlanCreateManyCampaignInput | ChannelPlanCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignTimelineCreateWithoutCampaignInput = {
    id?: string
    milestoneName: string
    milestoneType: string
    plannedDate: Date | string
    createdAt?: Date | string
  }

  export type CampaignTimelineUncheckedCreateWithoutCampaignInput = {
    id?: string
    milestoneName: string
    milestoneType: string
    plannedDate: Date | string
    createdAt?: Date | string
  }

  export type CampaignTimelineCreateOrConnectWithoutCampaignInput = {
    where: CampaignTimelineWhereUniqueInput
    create: XOR<CampaignTimelineCreateWithoutCampaignInput, CampaignTimelineUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTimelineCreateManyCampaignInputEnvelope = {
    data: CampaignTimelineCreateManyCampaignInput | CampaignTimelineCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ComplianceChecklistCreateWithoutCampaignInput = {
    id?: string
    item: string
    severity: string
    responsibleDepartment: string
    status?: string
    createdAt?: Date | string
  }

  export type ComplianceChecklistUncheckedCreateWithoutCampaignInput = {
    id?: string
    item: string
    severity: string
    responsibleDepartment: string
    status?: string
    createdAt?: Date | string
  }

  export type ComplianceChecklistCreateOrConnectWithoutCampaignInput = {
    where: ComplianceChecklistWhereUniqueInput
    create: XOR<ComplianceChecklistCreateWithoutCampaignInput, ComplianceChecklistUncheckedCreateWithoutCampaignInput>
  }

  export type ComplianceChecklistCreateManyCampaignInputEnvelope = {
    data: ComplianceChecklistCreateManyCampaignInput | ComplianceChecklistCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CreativeAssetCreateWithoutCampaignInput = {
    id?: string
    type: string
    assetUrl: string
    createdAt?: Date | string
  }

  export type CreativeAssetUncheckedCreateWithoutCampaignInput = {
    id?: string
    type: string
    assetUrl: string
    createdAt?: Date | string
  }

  export type CreativeAssetCreateOrConnectWithoutCampaignInput = {
    where: CreativeAssetWhereUniqueInput
    create: XOR<CreativeAssetCreateWithoutCampaignInput, CreativeAssetUncheckedCreateWithoutCampaignInput>
  }

  export type CreativeAssetCreateManyCampaignInputEnvelope = {
    data: CreativeAssetCreateManyCampaignInput | CreativeAssetCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type PromotionalMessageCreateWithoutCampaignInput = {
    id?: string
    platform: string
    tone: string
    message: string
    callToAction: string
    createdAt?: Date | string
  }

  export type PromotionalMessageUncheckedCreateWithoutCampaignInput = {
    id?: string
    platform: string
    tone: string
    message: string
    callToAction: string
    createdAt?: Date | string
  }

  export type PromotionalMessageCreateOrConnectWithoutCampaignInput = {
    where: PromotionalMessageWhereUniqueInput
    create: XOR<PromotionalMessageCreateWithoutCampaignInput, PromotionalMessageUncheckedCreateWithoutCampaignInput>
  }

  export type PromotionalMessageCreateManyCampaignInputEnvelope = {
    data: PromotionalMessageCreateManyCampaignInput | PromotionalMessageCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type MediaAssetCreateWithoutCampaignInput = {
    id?: string
    type: string
    title: string
    concept: string
    engagementTip: string
    mobileOptimizationTip: string
    url?: string | null
    createdAt?: Date | string
  }

  export type MediaAssetUncheckedCreateWithoutCampaignInput = {
    id?: string
    type: string
    title: string
    concept: string
    engagementTip: string
    mobileOptimizationTip: string
    url?: string | null
    createdAt?: Date | string
  }

  export type MediaAssetCreateOrConnectWithoutCampaignInput = {
    where: MediaAssetWhereUniqueInput
    create: XOR<MediaAssetCreateWithoutCampaignInput, MediaAssetUncheckedCreateWithoutCampaignInput>
  }

  export type MediaAssetCreateManyCampaignInputEnvelope = {
    data: MediaAssetCreateManyCampaignInput | MediaAssetCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ContentCalendarCreateWithoutCampaignInput = {
    id?: string
    contentType: string
    platform: string
    contentRef: string
    scheduledFor: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ContentCalendarUncheckedCreateWithoutCampaignInput = {
    id?: string
    contentType: string
    platform: string
    contentRef: string
    scheduledFor: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ContentCalendarCreateOrConnectWithoutCampaignInput = {
    where: ContentCalendarWhereUniqueInput
    create: XOR<ContentCalendarCreateWithoutCampaignInput, ContentCalendarUncheckedCreateWithoutCampaignInput>
  }

  export type ContentCalendarCreateManyCampaignInputEnvelope = {
    data: ContentCalendarCreateManyCampaignInput | ContentCalendarCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type TeaserContentCreateWithoutCampaignInput = {
    id?: string
    message: string
    platform: string
    teaserTheme?: string | null
    tone: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type TeaserContentUncheckedCreateWithoutCampaignInput = {
    id?: string
    message: string
    platform: string
    teaserTheme?: string | null
    tone: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type TeaserContentCreateOrConnectWithoutCampaignInput = {
    where: TeaserContentWhereUniqueInput
    create: XOR<TeaserContentCreateWithoutCampaignInput, TeaserContentUncheckedCreateWithoutCampaignInput>
  }

  export type TeaserContentCreateManyCampaignInputEnvelope = {
    data: TeaserContentCreateManyCampaignInput | TeaserContentCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CustomerSegmentListCreateWithoutCampaignInput = {
    id?: string
    segment: string
    criteria: string
    count: number
    createdAt?: Date | string
  }

  export type CustomerSegmentListUncheckedCreateWithoutCampaignInput = {
    id?: string
    segment: string
    criteria: string
    count: number
    createdAt?: Date | string
  }

  export type CustomerSegmentListCreateOrConnectWithoutCampaignInput = {
    where: CustomerSegmentListWhereUniqueInput
    create: XOR<CustomerSegmentListCreateWithoutCampaignInput, CustomerSegmentListUncheckedCreateWithoutCampaignInput>
  }

  export type CustomerSegmentListCreateManyCampaignInputEnvelope = {
    data: CustomerSegmentListCreateManyCampaignInput | CustomerSegmentListCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type InfluencerPlanCreateWithoutCampaignInput = {
    id?: string
    influencerName: string
    platform: string
    postType: string
    expectedImpact?: string | null
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type InfluencerPlanUncheckedCreateWithoutCampaignInput = {
    id?: string
    influencerName: string
    platform: string
    postType: string
    expectedImpact?: string | null
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type InfluencerPlanCreateOrConnectWithoutCampaignInput = {
    where: InfluencerPlanWhereUniqueInput
    create: XOR<InfluencerPlanCreateWithoutCampaignInput, InfluencerPlanUncheckedCreateWithoutCampaignInput>
  }

  export type InfluencerPlanCreateManyCampaignInputEnvelope = {
    data: InfluencerPlanCreateManyCampaignInput | InfluencerPlanCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type OperationalChecklistCreateWithoutCampaignInput = {
    id?: string
    system: string
    checklistItem: string
    expectedOutcome: string
    responsibility: string
    status: string
    createdAt?: Date | string
  }

  export type OperationalChecklistUncheckedCreateWithoutCampaignInput = {
    id?: string
    system: string
    checklistItem: string
    expectedOutcome: string
    responsibility: string
    status: string
    createdAt?: Date | string
  }

  export type OperationalChecklistCreateOrConnectWithoutCampaignInput = {
    where: OperationalChecklistWhereUniqueInput
    create: XOR<OperationalChecklistCreateWithoutCampaignInput, OperationalChecklistUncheckedCreateWithoutCampaignInput>
  }

  export type OperationalChecklistCreateManyCampaignInputEnvelope = {
    data: OperationalChecklistCreateManyCampaignInput | OperationalChecklistCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignActivationCreateWithoutCampaignInput = {
    id?: string
    platform: string
    assetType: string
    assetReference: string
    activationTime: Date | string
    status: string
    activationResult: string
    createdAt?: Date | string
  }

  export type CampaignActivationUncheckedCreateWithoutCampaignInput = {
    id?: string
    platform: string
    assetType: string
    assetReference: string
    activationTime: Date | string
    status: string
    activationResult: string
    createdAt?: Date | string
  }

  export type CampaignActivationCreateOrConnectWithoutCampaignInput = {
    where: CampaignActivationWhereUniqueInput
    create: XOR<CampaignActivationCreateWithoutCampaignInput, CampaignActivationUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignActivationCreateManyCampaignInputEnvelope = {
    data: CampaignActivationCreateManyCampaignInput | CampaignActivationCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CustomerEngagementLogCreateWithoutCampaignInput = {
    id?: string
    userId: string
    sessionId: string
    interactionType: string
    message: string
    resolutionStatus: string
    responseTime: number
    csatScore?: number | null
    createdAt?: Date | string
  }

  export type CustomerEngagementLogUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    sessionId: string
    interactionType: string
    message: string
    resolutionStatus: string
    responseTime: number
    csatScore?: number | null
    createdAt?: Date | string
  }

  export type CustomerEngagementLogCreateOrConnectWithoutCampaignInput = {
    where: CustomerEngagementLogWhereUniqueInput
    create: XOR<CustomerEngagementLogCreateWithoutCampaignInput, CustomerEngagementLogUncheckedCreateWithoutCampaignInput>
  }

  export type CustomerEngagementLogCreateManyCampaignInputEnvelope = {
    data: CustomerEngagementLogCreateManyCampaignInput | CustomerEngagementLogCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceReportCreateWithoutCampaignInput = {
    id?: string
    date: Date | string
    impressions: number
    clicks: number
    qrScans: number
    conversions: number
    chatbotSessions: number
    escalations: number
    escalationRate: number
    avgBotResponseTime: number
    avgHumanResponseTime: number
    csatScoreAverage: number
    anomalies?: string | null
    createdAt?: Date | string
  }

  export type PerformanceReportUncheckedCreateWithoutCampaignInput = {
    id?: string
    date: Date | string
    impressions: number
    clicks: number
    qrScans: number
    conversions: number
    chatbotSessions: number
    escalations: number
    escalationRate: number
    avgBotResponseTime: number
    avgHumanResponseTime: number
    csatScoreAverage: number
    anomalies?: string | null
    createdAt?: Date | string
  }

  export type PerformanceReportCreateOrConnectWithoutCampaignInput = {
    where: PerformanceReportWhereUniqueInput
    create: XOR<PerformanceReportCreateWithoutCampaignInput, PerformanceReportUncheckedCreateWithoutCampaignInput>
  }

  export type PerformanceReportCreateManyCampaignInputEnvelope = {
    data: PerformanceReportCreateManyCampaignInput | PerformanceReportCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CustomerFeedbackCreateWithoutCampaignInput = {
    id?: string
    userId: string
    interactionId?: string | null
    feedbackText: string
    rating: number
    collectedVia: string
    createdAt?: Date | string
  }

  export type CustomerFeedbackUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    interactionId?: string | null
    feedbackText: string
    rating: number
    collectedVia: string
    createdAt?: Date | string
  }

  export type CustomerFeedbackCreateOrConnectWithoutCampaignInput = {
    where: CustomerFeedbackWhereUniqueInput
    create: XOR<CustomerFeedbackCreateWithoutCampaignInput, CustomerFeedbackUncheckedCreateWithoutCampaignInput>
  }

  export type CustomerFeedbackCreateManyCampaignInputEnvelope = {
    data: CustomerFeedbackCreateManyCampaignInput | CustomerFeedbackCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ThankYouMessageCreateWithoutCampaignInput = {
    id?: string
    userId: string
    messageBody: string
    sentVia: string
    segment: string
    sentAt?: Date | string
  }

  export type ThankYouMessageUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    messageBody: string
    sentVia: string
    segment: string
    sentAt?: Date | string
  }

  export type ThankYouMessageCreateOrConnectWithoutCampaignInput = {
    where: ThankYouMessageWhereUniqueInput
    create: XOR<ThankYouMessageCreateWithoutCampaignInput, ThankYouMessageUncheckedCreateWithoutCampaignInput>
  }

  export type ThankYouMessageCreateManyCampaignInputEnvelope = {
    data: ThankYouMessageCreateManyCampaignInput | ThankYouMessageCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type RetargetingPlanCreateWithoutCampaignInput = {
    id?: string
    audienceSegment: string
    retargetingChannel: string
    offerMessage: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type RetargetingPlanUncheckedCreateWithoutCampaignInput = {
    id?: string
    audienceSegment: string
    retargetingChannel: string
    offerMessage: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type RetargetingPlanCreateOrConnectWithoutCampaignInput = {
    where: RetargetingPlanWhereUniqueInput
    create: XOR<RetargetingPlanCreateWithoutCampaignInput, RetargetingPlanUncheckedCreateWithoutCampaignInput>
  }

  export type RetargetingPlanCreateManyCampaignInputEnvelope = {
    data: RetargetingPlanCreateManyCampaignInput | RetargetingPlanCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignExtensionPlanCreateWithoutCampaignInput = {
    id?: string
    reason: string
    extendedTo: Date | string
    details: string
    createdAt?: Date | string
  }

  export type CampaignExtensionPlanUncheckedCreateWithoutCampaignInput = {
    id?: string
    reason: string
    extendedTo: Date | string
    details: string
    createdAt?: Date | string
  }

  export type CampaignExtensionPlanCreateOrConnectWithoutCampaignInput = {
    where: CampaignExtensionPlanWhereUniqueInput
    create: XOR<CampaignExtensionPlanCreateWithoutCampaignInput, CampaignExtensionPlanUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignExtensionPlanCreateManyCampaignInputEnvelope = {
    data: CampaignExtensionPlanCreateManyCampaignInput | CampaignExtensionPlanCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignAnalysisReportCreateWithoutCampaignInput = {
    id?: string
    totalImpressions: number
    totalClicks: number
    totalQrScans: number
    totalConversions: number
    conversionRate: number
    revenueGenerated: number
    campaignSpend: number
    roi: number
    engagementRate: number
    csatAverage: number
    escalationRate: number
    learningsSummary?: string | null
    createdAt?: Date | string
  }

  export type CampaignAnalysisReportUncheckedCreateWithoutCampaignInput = {
    id?: string
    totalImpressions: number
    totalClicks: number
    totalQrScans: number
    totalConversions: number
    conversionRate: number
    revenueGenerated: number
    campaignSpend: number
    roi: number
    engagementRate: number
    csatAverage: number
    escalationRate: number
    learningsSummary?: string | null
    createdAt?: Date | string
  }

  export type CampaignAnalysisReportCreateOrConnectWithoutCampaignInput = {
    where: CampaignAnalysisReportWhereUniqueInput
    create: XOR<CampaignAnalysisReportCreateWithoutCampaignInput, CampaignAnalysisReportUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignAnalysisReportCreateManyCampaignInputEnvelope = {
    data: CampaignAnalysisReportCreateManyCampaignInput | CampaignAnalysisReportCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignLearningsCreateWithoutCampaignInput = {
    id?: string
    whatWorked: string
    whatDidNotWork: string
    bestPractices: string
    improvementAreas: string
    createdAt?: Date | string
  }

  export type CampaignLearningsUncheckedCreateWithoutCampaignInput = {
    id?: string
    whatWorked: string
    whatDidNotWork: string
    bestPractices: string
    improvementAreas: string
    createdAt?: Date | string
  }

  export type CampaignLearningsCreateOrConnectWithoutCampaignInput = {
    where: CampaignLearningsWhereUniqueInput
    create: XOR<CampaignLearningsCreateWithoutCampaignInput, CampaignLearningsUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLearningsCreateManyCampaignInputEnvelope = {
    data: CampaignLearningsCreateManyCampaignInput | CampaignLearningsCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type InternalCampaignReportCreateWithoutCampaignInput = {
    id?: string
    reportTitle: string
    executiveSummary: string
    kpiHighlights: string
    learningHighlights: string
    improvementAreas: string
    graphsReference?: string | null
    createdAt?: Date | string
  }

  export type InternalCampaignReportUncheckedCreateWithoutCampaignInput = {
    id?: string
    reportTitle: string
    executiveSummary: string
    kpiHighlights: string
    learningHighlights: string
    improvementAreas: string
    graphsReference?: string | null
    createdAt?: Date | string
  }

  export type InternalCampaignReportCreateOrConnectWithoutCampaignInput = {
    where: InternalCampaignReportWhereUniqueInput
    create: XOR<InternalCampaignReportCreateWithoutCampaignInput, InternalCampaignReportUncheckedCreateWithoutCampaignInput>
  }

  export type InternalCampaignReportCreateManyCampaignInputEnvelope = {
    data: InternalCampaignReportCreateManyCampaignInput | InternalCampaignReportCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type EnterpriseContextUpsertWithWhereUniqueWithoutCampaignInput = {
    where: EnterpriseContextWhereUniqueInput
    update: XOR<EnterpriseContextUpdateWithoutCampaignInput, EnterpriseContextUncheckedUpdateWithoutCampaignInput>
    create: XOR<EnterpriseContextCreateWithoutCampaignInput, EnterpriseContextUncheckedCreateWithoutCampaignInput>
  }

  export type EnterpriseContextUpdateWithWhereUniqueWithoutCampaignInput = {
    where: EnterpriseContextWhereUniqueInput
    data: XOR<EnterpriseContextUpdateWithoutCampaignInput, EnterpriseContextUncheckedUpdateWithoutCampaignInput>
  }

  export type EnterpriseContextUpdateManyWithWhereWithoutCampaignInput = {
    where: EnterpriseContextScalarWhereInput
    data: XOR<EnterpriseContextUpdateManyMutationInput, EnterpriseContextUncheckedUpdateManyWithoutCampaignInput>
  }

  export type EnterpriseContextScalarWhereInput = {
    AND?: EnterpriseContextScalarWhereInput | EnterpriseContextScalarWhereInput[]
    OR?: EnterpriseContextScalarWhereInput[]
    NOT?: EnterpriseContextScalarWhereInput | EnterpriseContextScalarWhereInput[]
    id?: StringFilter<"EnterpriseContext"> | string
    campaignId?: StringFilter<"EnterpriseContext"> | string
    companyName?: StringFilter<"EnterpriseContext"> | string
    domain?: StringFilter<"EnterpriseContext"> | string
    businessModel?: StringFilter<"EnterpriseContext"> | string
    background?: StringFilter<"EnterpriseContext"> | string
    currentPain?: StringFilter<"EnterpriseContext"> | string
    goals?: StringFilter<"EnterpriseContext"> | string
    createdAt?: DateTimeFilter<"EnterpriseContext"> | Date | string
  }

  export type AudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput = {
    where: AudienceSegmentWhereUniqueInput
    update: XOR<AudienceSegmentUpdateWithoutCampaignInput, AudienceSegmentUncheckedUpdateWithoutCampaignInput>
    create: XOR<AudienceSegmentCreateWithoutCampaignInput, AudienceSegmentUncheckedCreateWithoutCampaignInput>
  }

  export type AudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput = {
    where: AudienceSegmentWhereUniqueInput
    data: XOR<AudienceSegmentUpdateWithoutCampaignInput, AudienceSegmentUncheckedUpdateWithoutCampaignInput>
  }

  export type AudienceSegmentUpdateManyWithWhereWithoutCampaignInput = {
    where: AudienceSegmentScalarWhereInput
    data: XOR<AudienceSegmentUpdateManyMutationInput, AudienceSegmentUncheckedUpdateManyWithoutCampaignInput>
  }

  export type AudienceSegmentScalarWhereInput = {
    AND?: AudienceSegmentScalarWhereInput | AudienceSegmentScalarWhereInput[]
    OR?: AudienceSegmentScalarWhereInput[]
    NOT?: AudienceSegmentScalarWhereInput | AudienceSegmentScalarWhereInput[]
    id?: StringFilter<"AudienceSegment"> | string
    campaignId?: StringFilter<"AudienceSegment"> | string
    label?: StringFilter<"AudienceSegment"> | string
    demographics?: StringFilter<"AudienceSegment"> | string
    behavior?: StringFilter<"AudienceSegment"> | string
    painPoints?: StringFilter<"AudienceSegment"> | string
    createdAt?: DateTimeFilter<"AudienceSegment"> | Date | string
  }

  export type CreativeDesignPlanUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CreativeDesignPlanWhereUniqueInput
    update: XOR<CreativeDesignPlanUpdateWithoutCampaignInput, CreativeDesignPlanUncheckedUpdateWithoutCampaignInput>
    create: XOR<CreativeDesignPlanCreateWithoutCampaignInput, CreativeDesignPlanUncheckedCreateWithoutCampaignInput>
  }

  export type CreativeDesignPlanUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CreativeDesignPlanWhereUniqueInput
    data: XOR<CreativeDesignPlanUpdateWithoutCampaignInput, CreativeDesignPlanUncheckedUpdateWithoutCampaignInput>
  }

  export type CreativeDesignPlanUpdateManyWithWhereWithoutCampaignInput = {
    where: CreativeDesignPlanScalarWhereInput
    data: XOR<CreativeDesignPlanUpdateManyMutationInput, CreativeDesignPlanUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CreativeDesignPlanScalarWhereInput = {
    AND?: CreativeDesignPlanScalarWhereInput | CreativeDesignPlanScalarWhereInput[]
    OR?: CreativeDesignPlanScalarWhereInput[]
    NOT?: CreativeDesignPlanScalarWhereInput | CreativeDesignPlanScalarWhereInput[]
    id?: StringFilter<"CreativeDesignPlan"> | string
    campaignId?: StringFilter<"CreativeDesignPlan"> | string
    platform?: StringFilter<"CreativeDesignPlan"> | string
    creativeTitle?: StringFilter<"CreativeDesignPlan"> | string
    headline?: StringFilter<"CreativeDesignPlan"> | string
    visualTheme?: StringFilter<"CreativeDesignPlan"> | string
    cta?: StringFilter<"CreativeDesignPlan"> | string
    mobileOptimizationTip?: StringFilter<"CreativeDesignPlan"> | string
    createdAt?: DateTimeFilter<"CreativeDesignPlan"> | Date | string
  }

  export type CampaignObjectiveUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignObjectiveWhereUniqueInput
    update: XOR<CampaignObjectiveUpdateWithoutCampaignInput, CampaignObjectiveUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignObjectiveCreateWithoutCampaignInput, CampaignObjectiveUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignObjectiveUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignObjectiveWhereUniqueInput
    data: XOR<CampaignObjectiveUpdateWithoutCampaignInput, CampaignObjectiveUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignObjectiveUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignObjectiveScalarWhereInput
    data: XOR<CampaignObjectiveUpdateManyMutationInput, CampaignObjectiveUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignObjectiveScalarWhereInput = {
    AND?: CampaignObjectiveScalarWhereInput | CampaignObjectiveScalarWhereInput[]
    OR?: CampaignObjectiveScalarWhereInput[]
    NOT?: CampaignObjectiveScalarWhereInput | CampaignObjectiveScalarWhereInput[]
    id?: StringFilter<"CampaignObjective"> | string
    campaignId?: StringFilter<"CampaignObjective"> | string
    goal?: StringFilter<"CampaignObjective"> | string
  }

  export type TargetAudienceSegmentUpsertWithWhereUniqueWithoutCampaignInput = {
    where: TargetAudienceSegmentWhereUniqueInput
    update: XOR<TargetAudienceSegmentUpdateWithoutCampaignInput, TargetAudienceSegmentUncheckedUpdateWithoutCampaignInput>
    create: XOR<TargetAudienceSegmentCreateWithoutCampaignInput, TargetAudienceSegmentUncheckedCreateWithoutCampaignInput>
  }

  export type TargetAudienceSegmentUpdateWithWhereUniqueWithoutCampaignInput = {
    where: TargetAudienceSegmentWhereUniqueInput
    data: XOR<TargetAudienceSegmentUpdateWithoutCampaignInput, TargetAudienceSegmentUncheckedUpdateWithoutCampaignInput>
  }

  export type TargetAudienceSegmentUpdateManyWithWhereWithoutCampaignInput = {
    where: TargetAudienceSegmentScalarWhereInput
    data: XOR<TargetAudienceSegmentUpdateManyMutationInput, TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignInput>
  }

  export type TargetAudienceSegmentScalarWhereInput = {
    AND?: TargetAudienceSegmentScalarWhereInput | TargetAudienceSegmentScalarWhereInput[]
    OR?: TargetAudienceSegmentScalarWhereInput[]
    NOT?: TargetAudienceSegmentScalarWhereInput | TargetAudienceSegmentScalarWhereInput[]
    id?: StringFilter<"TargetAudienceSegment"> | string
    campaignId?: StringFilter<"TargetAudienceSegment"> | string
    segment?: StringFilter<"TargetAudienceSegment"> | string
  }

  export type CompetitorStrategyUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CompetitorStrategyWhereUniqueInput
    update: XOR<CompetitorStrategyUpdateWithoutCampaignInput, CompetitorStrategyUncheckedUpdateWithoutCampaignInput>
    create: XOR<CompetitorStrategyCreateWithoutCampaignInput, CompetitorStrategyUncheckedCreateWithoutCampaignInput>
  }

  export type CompetitorStrategyUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CompetitorStrategyWhereUniqueInput
    data: XOR<CompetitorStrategyUpdateWithoutCampaignInput, CompetitorStrategyUncheckedUpdateWithoutCampaignInput>
  }

  export type CompetitorStrategyUpdateManyWithWhereWithoutCampaignInput = {
    where: CompetitorStrategyScalarWhereInput
    data: XOR<CompetitorStrategyUpdateManyMutationInput, CompetitorStrategyUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CompetitorStrategyScalarWhereInput = {
    AND?: CompetitorStrategyScalarWhereInput | CompetitorStrategyScalarWhereInput[]
    OR?: CompetitorStrategyScalarWhereInput[]
    NOT?: CompetitorStrategyScalarWhereInput | CompetitorStrategyScalarWhereInput[]
    id?: StringFilter<"CompetitorStrategy"> | string
    campaignId?: StringFilter<"CompetitorStrategy"> | string
    competitor?: StringFilter<"CompetitorStrategy"> | string
    promotionType?: StringFilter<"CompetitorStrategy"> | string
    channels?: StringFilter<"CompetitorStrategy"> | string
    strength?: StringFilter<"CompetitorStrategy"> | string
    weakness?: StringFilter<"CompetitorStrategy"> | string
    createdAt?: DateTimeFilter<"CompetitorStrategy"> | Date | string
  }

  export type PromotionTypeUpsertWithWhereUniqueWithoutCampaignInput = {
    where: PromotionTypeWhereUniqueInput
    update: XOR<PromotionTypeUpdateWithoutCampaignInput, PromotionTypeUncheckedUpdateWithoutCampaignInput>
    create: XOR<PromotionTypeCreateWithoutCampaignInput, PromotionTypeUncheckedCreateWithoutCampaignInput>
  }

  export type PromotionTypeUpdateWithWhereUniqueWithoutCampaignInput = {
    where: PromotionTypeWhereUniqueInput
    data: XOR<PromotionTypeUpdateWithoutCampaignInput, PromotionTypeUncheckedUpdateWithoutCampaignInput>
  }

  export type PromotionTypeUpdateManyWithWhereWithoutCampaignInput = {
    where: PromotionTypeScalarWhereInput
    data: XOR<PromotionTypeUpdateManyMutationInput, PromotionTypeUncheckedUpdateManyWithoutCampaignInput>
  }

  export type PromotionTypeScalarWhereInput = {
    AND?: PromotionTypeScalarWhereInput | PromotionTypeScalarWhereInput[]
    OR?: PromotionTypeScalarWhereInput[]
    NOT?: PromotionTypeScalarWhereInput | PromotionTypeScalarWhereInput[]
    id?: StringFilter<"PromotionType"> | string
    campaignId?: StringFilter<"PromotionType"> | string
    type?: StringFilter<"PromotionType"> | string
  }

  export type CampaignOfferUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignOfferWhereUniqueInput
    update: XOR<CampaignOfferUpdateWithoutCampaignInput, CampaignOfferUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignOfferCreateWithoutCampaignInput, CampaignOfferUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignOfferUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignOfferWhereUniqueInput
    data: XOR<CampaignOfferUpdateWithoutCampaignInput, CampaignOfferUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignOfferUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignOfferScalarWhereInput
    data: XOR<CampaignOfferUpdateManyMutationInput, CampaignOfferUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignOfferScalarWhereInput = {
    AND?: CampaignOfferScalarWhereInput | CampaignOfferScalarWhereInput[]
    OR?: CampaignOfferScalarWhereInput[]
    NOT?: CampaignOfferScalarWhereInput | CampaignOfferScalarWhereInput[]
    id?: StringFilter<"CampaignOffer"> | string
    campaignId?: StringFilter<"CampaignOffer"> | string
    description?: StringFilter<"CampaignOffer"> | string
    offerLimit?: IntNullableFilter<"CampaignOffer"> | number | null
    offerType?: StringNullableFilter<"CampaignOffer"> | string | null
    successCriteria?: StringNullableFilter<"CampaignOffer"> | string | null
    backupOffer?: StringNullableFilter<"CampaignOffer"> | string | null
    createdAt?: DateTimeFilter<"CampaignOffer"> | Date | string
  }

  export type CampaignBudgetUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignBudgetWhereUniqueInput
    update: XOR<CampaignBudgetUpdateWithoutCampaignInput, CampaignBudgetUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignBudgetCreateWithoutCampaignInput, CampaignBudgetUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignBudgetUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignBudgetWhereUniqueInput
    data: XOR<CampaignBudgetUpdateWithoutCampaignInput, CampaignBudgetUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignBudgetUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignBudgetScalarWhereInput
    data: XOR<CampaignBudgetUpdateManyMutationInput, CampaignBudgetUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignBudgetScalarWhereInput = {
    AND?: CampaignBudgetScalarWhereInput | CampaignBudgetScalarWhereInput[]
    OR?: CampaignBudgetScalarWhereInput[]
    NOT?: CampaignBudgetScalarWhereInput | CampaignBudgetScalarWhereInput[]
    id?: StringFilter<"CampaignBudget"> | string
    campaignId?: StringFilter<"CampaignBudget"> | string
    mediaSpend?: FloatFilter<"CampaignBudget"> | number
    creativeSpend?: FloatFilter<"CampaignBudget"> | number
    incentiveSpend?: FloatFilter<"CampaignBudget"> | number
    logisticsSpend?: FloatFilter<"CampaignBudget"> | number
    totalBudget?: FloatFilter<"CampaignBudget"> | number
    costPerCustomer?: FloatFilter<"CampaignBudget"> | number
    expectedROI?: FloatNullableFilter<"CampaignBudget"> | number | null
    notes?: StringNullableFilter<"CampaignBudget"> | string | null
    createdAt?: DateTimeFilter<"CampaignBudget"> | Date | string
  }

  export type ChannelPlanUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ChannelPlanWhereUniqueInput
    update: XOR<ChannelPlanUpdateWithoutCampaignInput, ChannelPlanUncheckedUpdateWithoutCampaignInput>
    create: XOR<ChannelPlanCreateWithoutCampaignInput, ChannelPlanUncheckedCreateWithoutCampaignInput>
  }

  export type ChannelPlanUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ChannelPlanWhereUniqueInput
    data: XOR<ChannelPlanUpdateWithoutCampaignInput, ChannelPlanUncheckedUpdateWithoutCampaignInput>
  }

  export type ChannelPlanUpdateManyWithWhereWithoutCampaignInput = {
    where: ChannelPlanScalarWhereInput
    data: XOR<ChannelPlanUpdateManyMutationInput, ChannelPlanUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ChannelPlanScalarWhereInput = {
    AND?: ChannelPlanScalarWhereInput | ChannelPlanScalarWhereInput[]
    OR?: ChannelPlanScalarWhereInput[]
    NOT?: ChannelPlanScalarWhereInput | ChannelPlanScalarWhereInput[]
    id?: StringFilter<"ChannelPlan"> | string
    campaignId?: StringFilter<"ChannelPlan"> | string
    channels?: StringNullableListFilter<"ChannelPlan">
    primary?: StringFilter<"ChannelPlan"> | string
    primaryReason?: StringFilter<"ChannelPlan"> | string
    messageStyles?: StringNullableListFilter<"ChannelPlan">
    createdAt?: DateTimeFilter<"ChannelPlan"> | Date | string
  }

  export type CampaignTimelineUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignTimelineWhereUniqueInput
    update: XOR<CampaignTimelineUpdateWithoutCampaignInput, CampaignTimelineUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignTimelineCreateWithoutCampaignInput, CampaignTimelineUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTimelineUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignTimelineWhereUniqueInput
    data: XOR<CampaignTimelineUpdateWithoutCampaignInput, CampaignTimelineUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignTimelineUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignTimelineScalarWhereInput
    data: XOR<CampaignTimelineUpdateManyMutationInput, CampaignTimelineUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignTimelineScalarWhereInput = {
    AND?: CampaignTimelineScalarWhereInput | CampaignTimelineScalarWhereInput[]
    OR?: CampaignTimelineScalarWhereInput[]
    NOT?: CampaignTimelineScalarWhereInput | CampaignTimelineScalarWhereInput[]
    id?: StringFilter<"CampaignTimeline"> | string
    campaignId?: StringFilter<"CampaignTimeline"> | string
    milestoneName?: StringFilter<"CampaignTimeline"> | string
    milestoneType?: StringFilter<"CampaignTimeline"> | string
    plannedDate?: DateTimeFilter<"CampaignTimeline"> | Date | string
    createdAt?: DateTimeFilter<"CampaignTimeline"> | Date | string
  }

  export type ComplianceChecklistUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ComplianceChecklistWhereUniqueInput
    update: XOR<ComplianceChecklistUpdateWithoutCampaignInput, ComplianceChecklistUncheckedUpdateWithoutCampaignInput>
    create: XOR<ComplianceChecklistCreateWithoutCampaignInput, ComplianceChecklistUncheckedCreateWithoutCampaignInput>
  }

  export type ComplianceChecklistUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ComplianceChecklistWhereUniqueInput
    data: XOR<ComplianceChecklistUpdateWithoutCampaignInput, ComplianceChecklistUncheckedUpdateWithoutCampaignInput>
  }

  export type ComplianceChecklistUpdateManyWithWhereWithoutCampaignInput = {
    where: ComplianceChecklistScalarWhereInput
    data: XOR<ComplianceChecklistUpdateManyMutationInput, ComplianceChecklistUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ComplianceChecklistScalarWhereInput = {
    AND?: ComplianceChecklistScalarWhereInput | ComplianceChecklistScalarWhereInput[]
    OR?: ComplianceChecklistScalarWhereInput[]
    NOT?: ComplianceChecklistScalarWhereInput | ComplianceChecklistScalarWhereInput[]
    id?: StringFilter<"ComplianceChecklist"> | string
    campaignId?: StringFilter<"ComplianceChecklist"> | string
    item?: StringFilter<"ComplianceChecklist"> | string
    severity?: StringFilter<"ComplianceChecklist"> | string
    responsibleDepartment?: StringFilter<"ComplianceChecklist"> | string
    status?: StringFilter<"ComplianceChecklist"> | string
    createdAt?: DateTimeFilter<"ComplianceChecklist"> | Date | string
  }

  export type CreativeAssetUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CreativeAssetWhereUniqueInput
    update: XOR<CreativeAssetUpdateWithoutCampaignInput, CreativeAssetUncheckedUpdateWithoutCampaignInput>
    create: XOR<CreativeAssetCreateWithoutCampaignInput, CreativeAssetUncheckedCreateWithoutCampaignInput>
  }

  export type CreativeAssetUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CreativeAssetWhereUniqueInput
    data: XOR<CreativeAssetUpdateWithoutCampaignInput, CreativeAssetUncheckedUpdateWithoutCampaignInput>
  }

  export type CreativeAssetUpdateManyWithWhereWithoutCampaignInput = {
    where: CreativeAssetScalarWhereInput
    data: XOR<CreativeAssetUpdateManyMutationInput, CreativeAssetUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CreativeAssetScalarWhereInput = {
    AND?: CreativeAssetScalarWhereInput | CreativeAssetScalarWhereInput[]
    OR?: CreativeAssetScalarWhereInput[]
    NOT?: CreativeAssetScalarWhereInput | CreativeAssetScalarWhereInput[]
    id?: StringFilter<"CreativeAsset"> | string
    campaignId?: StringFilter<"CreativeAsset"> | string
    type?: StringFilter<"CreativeAsset"> | string
    assetUrl?: StringFilter<"CreativeAsset"> | string
    createdAt?: DateTimeFilter<"CreativeAsset"> | Date | string
  }

  export type PromotionalMessageUpsertWithWhereUniqueWithoutCampaignInput = {
    where: PromotionalMessageWhereUniqueInput
    update: XOR<PromotionalMessageUpdateWithoutCampaignInput, PromotionalMessageUncheckedUpdateWithoutCampaignInput>
    create: XOR<PromotionalMessageCreateWithoutCampaignInput, PromotionalMessageUncheckedCreateWithoutCampaignInput>
  }

  export type PromotionalMessageUpdateWithWhereUniqueWithoutCampaignInput = {
    where: PromotionalMessageWhereUniqueInput
    data: XOR<PromotionalMessageUpdateWithoutCampaignInput, PromotionalMessageUncheckedUpdateWithoutCampaignInput>
  }

  export type PromotionalMessageUpdateManyWithWhereWithoutCampaignInput = {
    where: PromotionalMessageScalarWhereInput
    data: XOR<PromotionalMessageUpdateManyMutationInput, PromotionalMessageUncheckedUpdateManyWithoutCampaignInput>
  }

  export type PromotionalMessageScalarWhereInput = {
    AND?: PromotionalMessageScalarWhereInput | PromotionalMessageScalarWhereInput[]
    OR?: PromotionalMessageScalarWhereInput[]
    NOT?: PromotionalMessageScalarWhereInput | PromotionalMessageScalarWhereInput[]
    id?: StringFilter<"PromotionalMessage"> | string
    campaignId?: StringFilter<"PromotionalMessage"> | string
    platform?: StringFilter<"PromotionalMessage"> | string
    tone?: StringFilter<"PromotionalMessage"> | string
    message?: StringFilter<"PromotionalMessage"> | string
    callToAction?: StringFilter<"PromotionalMessage"> | string
    createdAt?: DateTimeFilter<"PromotionalMessage"> | Date | string
  }

  export type MediaAssetUpsertWithWhereUniqueWithoutCampaignInput = {
    where: MediaAssetWhereUniqueInput
    update: XOR<MediaAssetUpdateWithoutCampaignInput, MediaAssetUncheckedUpdateWithoutCampaignInput>
    create: XOR<MediaAssetCreateWithoutCampaignInput, MediaAssetUncheckedCreateWithoutCampaignInput>
  }

  export type MediaAssetUpdateWithWhereUniqueWithoutCampaignInput = {
    where: MediaAssetWhereUniqueInput
    data: XOR<MediaAssetUpdateWithoutCampaignInput, MediaAssetUncheckedUpdateWithoutCampaignInput>
  }

  export type MediaAssetUpdateManyWithWhereWithoutCampaignInput = {
    where: MediaAssetScalarWhereInput
    data: XOR<MediaAssetUpdateManyMutationInput, MediaAssetUncheckedUpdateManyWithoutCampaignInput>
  }

  export type MediaAssetScalarWhereInput = {
    AND?: MediaAssetScalarWhereInput | MediaAssetScalarWhereInput[]
    OR?: MediaAssetScalarWhereInput[]
    NOT?: MediaAssetScalarWhereInput | MediaAssetScalarWhereInput[]
    id?: StringFilter<"MediaAsset"> | string
    campaignId?: StringFilter<"MediaAsset"> | string
    type?: StringFilter<"MediaAsset"> | string
    title?: StringFilter<"MediaAsset"> | string
    concept?: StringFilter<"MediaAsset"> | string
    engagementTip?: StringFilter<"MediaAsset"> | string
    mobileOptimizationTip?: StringFilter<"MediaAsset"> | string
    url?: StringNullableFilter<"MediaAsset"> | string | null
    createdAt?: DateTimeFilter<"MediaAsset"> | Date | string
  }

  export type ContentCalendarUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ContentCalendarWhereUniqueInput
    update: XOR<ContentCalendarUpdateWithoutCampaignInput, ContentCalendarUncheckedUpdateWithoutCampaignInput>
    create: XOR<ContentCalendarCreateWithoutCampaignInput, ContentCalendarUncheckedCreateWithoutCampaignInput>
  }

  export type ContentCalendarUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ContentCalendarWhereUniqueInput
    data: XOR<ContentCalendarUpdateWithoutCampaignInput, ContentCalendarUncheckedUpdateWithoutCampaignInput>
  }

  export type ContentCalendarUpdateManyWithWhereWithoutCampaignInput = {
    where: ContentCalendarScalarWhereInput
    data: XOR<ContentCalendarUpdateManyMutationInput, ContentCalendarUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ContentCalendarScalarWhereInput = {
    AND?: ContentCalendarScalarWhereInput | ContentCalendarScalarWhereInput[]
    OR?: ContentCalendarScalarWhereInput[]
    NOT?: ContentCalendarScalarWhereInput | ContentCalendarScalarWhereInput[]
    id?: StringFilter<"ContentCalendar"> | string
    campaignId?: StringFilter<"ContentCalendar"> | string
    contentType?: StringFilter<"ContentCalendar"> | string
    platform?: StringFilter<"ContentCalendar"> | string
    contentRef?: StringFilter<"ContentCalendar"> | string
    scheduledFor?: DateTimeFilter<"ContentCalendar"> | Date | string
    notes?: StringNullableFilter<"ContentCalendar"> | string | null
    createdAt?: DateTimeFilter<"ContentCalendar"> | Date | string
  }

  export type TeaserContentUpsertWithWhereUniqueWithoutCampaignInput = {
    where: TeaserContentWhereUniqueInput
    update: XOR<TeaserContentUpdateWithoutCampaignInput, TeaserContentUncheckedUpdateWithoutCampaignInput>
    create: XOR<TeaserContentCreateWithoutCampaignInput, TeaserContentUncheckedCreateWithoutCampaignInput>
  }

  export type TeaserContentUpdateWithWhereUniqueWithoutCampaignInput = {
    where: TeaserContentWhereUniqueInput
    data: XOR<TeaserContentUpdateWithoutCampaignInput, TeaserContentUncheckedUpdateWithoutCampaignInput>
  }

  export type TeaserContentUpdateManyWithWhereWithoutCampaignInput = {
    where: TeaserContentScalarWhereInput
    data: XOR<TeaserContentUpdateManyMutationInput, TeaserContentUncheckedUpdateManyWithoutCampaignInput>
  }

  export type TeaserContentScalarWhereInput = {
    AND?: TeaserContentScalarWhereInput | TeaserContentScalarWhereInput[]
    OR?: TeaserContentScalarWhereInput[]
    NOT?: TeaserContentScalarWhereInput | TeaserContentScalarWhereInput[]
    id?: StringFilter<"TeaserContent"> | string
    campaignId?: StringFilter<"TeaserContent"> | string
    message?: StringFilter<"TeaserContent"> | string
    platform?: StringFilter<"TeaserContent"> | string
    teaserTheme?: StringNullableFilter<"TeaserContent"> | string | null
    tone?: StringFilter<"TeaserContent"> | string
    scheduledAt?: DateTimeFilter<"TeaserContent"> | Date | string
    createdAt?: DateTimeFilter<"TeaserContent"> | Date | string
  }

  export type CustomerSegmentListUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CustomerSegmentListWhereUniqueInput
    update: XOR<CustomerSegmentListUpdateWithoutCampaignInput, CustomerSegmentListUncheckedUpdateWithoutCampaignInput>
    create: XOR<CustomerSegmentListCreateWithoutCampaignInput, CustomerSegmentListUncheckedCreateWithoutCampaignInput>
  }

  export type CustomerSegmentListUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CustomerSegmentListWhereUniqueInput
    data: XOR<CustomerSegmentListUpdateWithoutCampaignInput, CustomerSegmentListUncheckedUpdateWithoutCampaignInput>
  }

  export type CustomerSegmentListUpdateManyWithWhereWithoutCampaignInput = {
    where: CustomerSegmentListScalarWhereInput
    data: XOR<CustomerSegmentListUpdateManyMutationInput, CustomerSegmentListUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CustomerSegmentListScalarWhereInput = {
    AND?: CustomerSegmentListScalarWhereInput | CustomerSegmentListScalarWhereInput[]
    OR?: CustomerSegmentListScalarWhereInput[]
    NOT?: CustomerSegmentListScalarWhereInput | CustomerSegmentListScalarWhereInput[]
    id?: StringFilter<"CustomerSegmentList"> | string
    campaignId?: StringFilter<"CustomerSegmentList"> | string
    segment?: StringFilter<"CustomerSegmentList"> | string
    criteria?: StringFilter<"CustomerSegmentList"> | string
    count?: IntFilter<"CustomerSegmentList"> | number
    createdAt?: DateTimeFilter<"CustomerSegmentList"> | Date | string
  }

  export type InfluencerPlanUpsertWithWhereUniqueWithoutCampaignInput = {
    where: InfluencerPlanWhereUniqueInput
    update: XOR<InfluencerPlanUpdateWithoutCampaignInput, InfluencerPlanUncheckedUpdateWithoutCampaignInput>
    create: XOR<InfluencerPlanCreateWithoutCampaignInput, InfluencerPlanUncheckedCreateWithoutCampaignInput>
  }

  export type InfluencerPlanUpdateWithWhereUniqueWithoutCampaignInput = {
    where: InfluencerPlanWhereUniqueInput
    data: XOR<InfluencerPlanUpdateWithoutCampaignInput, InfluencerPlanUncheckedUpdateWithoutCampaignInput>
  }

  export type InfluencerPlanUpdateManyWithWhereWithoutCampaignInput = {
    where: InfluencerPlanScalarWhereInput
    data: XOR<InfluencerPlanUpdateManyMutationInput, InfluencerPlanUncheckedUpdateManyWithoutCampaignInput>
  }

  export type InfluencerPlanScalarWhereInput = {
    AND?: InfluencerPlanScalarWhereInput | InfluencerPlanScalarWhereInput[]
    OR?: InfluencerPlanScalarWhereInput[]
    NOT?: InfluencerPlanScalarWhereInput | InfluencerPlanScalarWhereInput[]
    id?: StringFilter<"InfluencerPlan"> | string
    campaignId?: StringFilter<"InfluencerPlan"> | string
    influencerName?: StringFilter<"InfluencerPlan"> | string
    platform?: StringFilter<"InfluencerPlan"> | string
    postType?: StringFilter<"InfluencerPlan"> | string
    expectedImpact?: StringNullableFilter<"InfluencerPlan"> | string | null
    scheduledAt?: DateTimeFilter<"InfluencerPlan"> | Date | string
    createdAt?: DateTimeFilter<"InfluencerPlan"> | Date | string
  }

  export type OperationalChecklistUpsertWithWhereUniqueWithoutCampaignInput = {
    where: OperationalChecklistWhereUniqueInput
    update: XOR<OperationalChecklistUpdateWithoutCampaignInput, OperationalChecklistUncheckedUpdateWithoutCampaignInput>
    create: XOR<OperationalChecklistCreateWithoutCampaignInput, OperationalChecklistUncheckedCreateWithoutCampaignInput>
  }

  export type OperationalChecklistUpdateWithWhereUniqueWithoutCampaignInput = {
    where: OperationalChecklistWhereUniqueInput
    data: XOR<OperationalChecklistUpdateWithoutCampaignInput, OperationalChecklistUncheckedUpdateWithoutCampaignInput>
  }

  export type OperationalChecklistUpdateManyWithWhereWithoutCampaignInput = {
    where: OperationalChecklistScalarWhereInput
    data: XOR<OperationalChecklistUpdateManyMutationInput, OperationalChecklistUncheckedUpdateManyWithoutCampaignInput>
  }

  export type OperationalChecklistScalarWhereInput = {
    AND?: OperationalChecklistScalarWhereInput | OperationalChecklistScalarWhereInput[]
    OR?: OperationalChecklistScalarWhereInput[]
    NOT?: OperationalChecklistScalarWhereInput | OperationalChecklistScalarWhereInput[]
    id?: StringFilter<"OperationalChecklist"> | string
    campaignId?: StringFilter<"OperationalChecklist"> | string
    system?: StringFilter<"OperationalChecklist"> | string
    checklistItem?: StringFilter<"OperationalChecklist"> | string
    expectedOutcome?: StringFilter<"OperationalChecklist"> | string
    responsibility?: StringFilter<"OperationalChecklist"> | string
    status?: StringFilter<"OperationalChecklist"> | string
    createdAt?: DateTimeFilter<"OperationalChecklist"> | Date | string
  }

  export type CampaignActivationUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignActivationWhereUniqueInput
    update: XOR<CampaignActivationUpdateWithoutCampaignInput, CampaignActivationUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignActivationCreateWithoutCampaignInput, CampaignActivationUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignActivationUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignActivationWhereUniqueInput
    data: XOR<CampaignActivationUpdateWithoutCampaignInput, CampaignActivationUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignActivationUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignActivationScalarWhereInput
    data: XOR<CampaignActivationUpdateManyMutationInput, CampaignActivationUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignActivationScalarWhereInput = {
    AND?: CampaignActivationScalarWhereInput | CampaignActivationScalarWhereInput[]
    OR?: CampaignActivationScalarWhereInput[]
    NOT?: CampaignActivationScalarWhereInput | CampaignActivationScalarWhereInput[]
    id?: StringFilter<"CampaignActivation"> | string
    campaignId?: StringFilter<"CampaignActivation"> | string
    platform?: StringFilter<"CampaignActivation"> | string
    assetType?: StringFilter<"CampaignActivation"> | string
    assetReference?: StringFilter<"CampaignActivation"> | string
    activationTime?: DateTimeFilter<"CampaignActivation"> | Date | string
    status?: StringFilter<"CampaignActivation"> | string
    activationResult?: StringFilter<"CampaignActivation"> | string
    createdAt?: DateTimeFilter<"CampaignActivation"> | Date | string
  }

  export type CustomerEngagementLogUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CustomerEngagementLogWhereUniqueInput
    update: XOR<CustomerEngagementLogUpdateWithoutCampaignInput, CustomerEngagementLogUncheckedUpdateWithoutCampaignInput>
    create: XOR<CustomerEngagementLogCreateWithoutCampaignInput, CustomerEngagementLogUncheckedCreateWithoutCampaignInput>
  }

  export type CustomerEngagementLogUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CustomerEngagementLogWhereUniqueInput
    data: XOR<CustomerEngagementLogUpdateWithoutCampaignInput, CustomerEngagementLogUncheckedUpdateWithoutCampaignInput>
  }

  export type CustomerEngagementLogUpdateManyWithWhereWithoutCampaignInput = {
    where: CustomerEngagementLogScalarWhereInput
    data: XOR<CustomerEngagementLogUpdateManyMutationInput, CustomerEngagementLogUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CustomerEngagementLogScalarWhereInput = {
    AND?: CustomerEngagementLogScalarWhereInput | CustomerEngagementLogScalarWhereInput[]
    OR?: CustomerEngagementLogScalarWhereInput[]
    NOT?: CustomerEngagementLogScalarWhereInput | CustomerEngagementLogScalarWhereInput[]
    id?: StringFilter<"CustomerEngagementLog"> | string
    campaignId?: StringFilter<"CustomerEngagementLog"> | string
    userId?: StringFilter<"CustomerEngagementLog"> | string
    sessionId?: StringFilter<"CustomerEngagementLog"> | string
    interactionType?: StringFilter<"CustomerEngagementLog"> | string
    message?: StringFilter<"CustomerEngagementLog"> | string
    resolutionStatus?: StringFilter<"CustomerEngagementLog"> | string
    responseTime?: IntFilter<"CustomerEngagementLog"> | number
    csatScore?: IntNullableFilter<"CustomerEngagementLog"> | number | null
    createdAt?: DateTimeFilter<"CustomerEngagementLog"> | Date | string
  }

  export type PerformanceReportUpsertWithWhereUniqueWithoutCampaignInput = {
    where: PerformanceReportWhereUniqueInput
    update: XOR<PerformanceReportUpdateWithoutCampaignInput, PerformanceReportUncheckedUpdateWithoutCampaignInput>
    create: XOR<PerformanceReportCreateWithoutCampaignInput, PerformanceReportUncheckedCreateWithoutCampaignInput>
  }

  export type PerformanceReportUpdateWithWhereUniqueWithoutCampaignInput = {
    where: PerformanceReportWhereUniqueInput
    data: XOR<PerformanceReportUpdateWithoutCampaignInput, PerformanceReportUncheckedUpdateWithoutCampaignInput>
  }

  export type PerformanceReportUpdateManyWithWhereWithoutCampaignInput = {
    where: PerformanceReportScalarWhereInput
    data: XOR<PerformanceReportUpdateManyMutationInput, PerformanceReportUncheckedUpdateManyWithoutCampaignInput>
  }

  export type PerformanceReportScalarWhereInput = {
    AND?: PerformanceReportScalarWhereInput | PerformanceReportScalarWhereInput[]
    OR?: PerformanceReportScalarWhereInput[]
    NOT?: PerformanceReportScalarWhereInput | PerformanceReportScalarWhereInput[]
    id?: StringFilter<"PerformanceReport"> | string
    campaignId?: StringFilter<"PerformanceReport"> | string
    date?: DateTimeFilter<"PerformanceReport"> | Date | string
    impressions?: IntFilter<"PerformanceReport"> | number
    clicks?: IntFilter<"PerformanceReport"> | number
    qrScans?: IntFilter<"PerformanceReport"> | number
    conversions?: IntFilter<"PerformanceReport"> | number
    chatbotSessions?: IntFilter<"PerformanceReport"> | number
    escalations?: IntFilter<"PerformanceReport"> | number
    escalationRate?: FloatFilter<"PerformanceReport"> | number
    avgBotResponseTime?: IntFilter<"PerformanceReport"> | number
    avgHumanResponseTime?: IntFilter<"PerformanceReport"> | number
    csatScoreAverage?: FloatFilter<"PerformanceReport"> | number
    anomalies?: StringNullableFilter<"PerformanceReport"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReport"> | Date | string
  }

  export type CustomerFeedbackUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CustomerFeedbackWhereUniqueInput
    update: XOR<CustomerFeedbackUpdateWithoutCampaignInput, CustomerFeedbackUncheckedUpdateWithoutCampaignInput>
    create: XOR<CustomerFeedbackCreateWithoutCampaignInput, CustomerFeedbackUncheckedCreateWithoutCampaignInput>
  }

  export type CustomerFeedbackUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CustomerFeedbackWhereUniqueInput
    data: XOR<CustomerFeedbackUpdateWithoutCampaignInput, CustomerFeedbackUncheckedUpdateWithoutCampaignInput>
  }

  export type CustomerFeedbackUpdateManyWithWhereWithoutCampaignInput = {
    where: CustomerFeedbackScalarWhereInput
    data: XOR<CustomerFeedbackUpdateManyMutationInput, CustomerFeedbackUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CustomerFeedbackScalarWhereInput = {
    AND?: CustomerFeedbackScalarWhereInput | CustomerFeedbackScalarWhereInput[]
    OR?: CustomerFeedbackScalarWhereInput[]
    NOT?: CustomerFeedbackScalarWhereInput | CustomerFeedbackScalarWhereInput[]
    id?: StringFilter<"CustomerFeedback"> | string
    campaignId?: StringFilter<"CustomerFeedback"> | string
    userId?: StringFilter<"CustomerFeedback"> | string
    interactionId?: StringNullableFilter<"CustomerFeedback"> | string | null
    feedbackText?: StringFilter<"CustomerFeedback"> | string
    rating?: IntFilter<"CustomerFeedback"> | number
    collectedVia?: StringFilter<"CustomerFeedback"> | string
    createdAt?: DateTimeFilter<"CustomerFeedback"> | Date | string
  }

  export type ThankYouMessageUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ThankYouMessageWhereUniqueInput
    update: XOR<ThankYouMessageUpdateWithoutCampaignInput, ThankYouMessageUncheckedUpdateWithoutCampaignInput>
    create: XOR<ThankYouMessageCreateWithoutCampaignInput, ThankYouMessageUncheckedCreateWithoutCampaignInput>
  }

  export type ThankYouMessageUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ThankYouMessageWhereUniqueInput
    data: XOR<ThankYouMessageUpdateWithoutCampaignInput, ThankYouMessageUncheckedUpdateWithoutCampaignInput>
  }

  export type ThankYouMessageUpdateManyWithWhereWithoutCampaignInput = {
    where: ThankYouMessageScalarWhereInput
    data: XOR<ThankYouMessageUpdateManyMutationInput, ThankYouMessageUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ThankYouMessageScalarWhereInput = {
    AND?: ThankYouMessageScalarWhereInput | ThankYouMessageScalarWhereInput[]
    OR?: ThankYouMessageScalarWhereInput[]
    NOT?: ThankYouMessageScalarWhereInput | ThankYouMessageScalarWhereInput[]
    id?: StringFilter<"ThankYouMessage"> | string
    campaignId?: StringFilter<"ThankYouMessage"> | string
    userId?: StringFilter<"ThankYouMessage"> | string
    messageBody?: StringFilter<"ThankYouMessage"> | string
    sentVia?: StringFilter<"ThankYouMessage"> | string
    segment?: StringFilter<"ThankYouMessage"> | string
    sentAt?: DateTimeFilter<"ThankYouMessage"> | Date | string
  }

  export type RetargetingPlanUpsertWithWhereUniqueWithoutCampaignInput = {
    where: RetargetingPlanWhereUniqueInput
    update: XOR<RetargetingPlanUpdateWithoutCampaignInput, RetargetingPlanUncheckedUpdateWithoutCampaignInput>
    create: XOR<RetargetingPlanCreateWithoutCampaignInput, RetargetingPlanUncheckedCreateWithoutCampaignInput>
  }

  export type RetargetingPlanUpdateWithWhereUniqueWithoutCampaignInput = {
    where: RetargetingPlanWhereUniqueInput
    data: XOR<RetargetingPlanUpdateWithoutCampaignInput, RetargetingPlanUncheckedUpdateWithoutCampaignInput>
  }

  export type RetargetingPlanUpdateManyWithWhereWithoutCampaignInput = {
    where: RetargetingPlanScalarWhereInput
    data: XOR<RetargetingPlanUpdateManyMutationInput, RetargetingPlanUncheckedUpdateManyWithoutCampaignInput>
  }

  export type RetargetingPlanScalarWhereInput = {
    AND?: RetargetingPlanScalarWhereInput | RetargetingPlanScalarWhereInput[]
    OR?: RetargetingPlanScalarWhereInput[]
    NOT?: RetargetingPlanScalarWhereInput | RetargetingPlanScalarWhereInput[]
    id?: StringFilter<"RetargetingPlan"> | string
    campaignId?: StringFilter<"RetargetingPlan"> | string
    audienceSegment?: StringFilter<"RetargetingPlan"> | string
    retargetingChannel?: StringFilter<"RetargetingPlan"> | string
    offerMessage?: StringFilter<"RetargetingPlan"> | string
    scheduledAt?: DateTimeFilter<"RetargetingPlan"> | Date | string
    createdAt?: DateTimeFilter<"RetargetingPlan"> | Date | string
  }

  export type CampaignExtensionPlanUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignExtensionPlanWhereUniqueInput
    update: XOR<CampaignExtensionPlanUpdateWithoutCampaignInput, CampaignExtensionPlanUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignExtensionPlanCreateWithoutCampaignInput, CampaignExtensionPlanUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignExtensionPlanUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignExtensionPlanWhereUniqueInput
    data: XOR<CampaignExtensionPlanUpdateWithoutCampaignInput, CampaignExtensionPlanUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignExtensionPlanUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignExtensionPlanScalarWhereInput
    data: XOR<CampaignExtensionPlanUpdateManyMutationInput, CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignExtensionPlanScalarWhereInput = {
    AND?: CampaignExtensionPlanScalarWhereInput | CampaignExtensionPlanScalarWhereInput[]
    OR?: CampaignExtensionPlanScalarWhereInput[]
    NOT?: CampaignExtensionPlanScalarWhereInput | CampaignExtensionPlanScalarWhereInput[]
    id?: StringFilter<"CampaignExtensionPlan"> | string
    campaignId?: StringFilter<"CampaignExtensionPlan"> | string
    reason?: StringFilter<"CampaignExtensionPlan"> | string
    extendedTo?: DateTimeFilter<"CampaignExtensionPlan"> | Date | string
    details?: StringFilter<"CampaignExtensionPlan"> | string
    createdAt?: DateTimeFilter<"CampaignExtensionPlan"> | Date | string
  }

  export type CampaignAnalysisReportUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignAnalysisReportWhereUniqueInput
    update: XOR<CampaignAnalysisReportUpdateWithoutCampaignInput, CampaignAnalysisReportUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignAnalysisReportCreateWithoutCampaignInput, CampaignAnalysisReportUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignAnalysisReportUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignAnalysisReportWhereUniqueInput
    data: XOR<CampaignAnalysisReportUpdateWithoutCampaignInput, CampaignAnalysisReportUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignAnalysisReportUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignAnalysisReportScalarWhereInput
    data: XOR<CampaignAnalysisReportUpdateManyMutationInput, CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignAnalysisReportScalarWhereInput = {
    AND?: CampaignAnalysisReportScalarWhereInput | CampaignAnalysisReportScalarWhereInput[]
    OR?: CampaignAnalysisReportScalarWhereInput[]
    NOT?: CampaignAnalysisReportScalarWhereInput | CampaignAnalysisReportScalarWhereInput[]
    id?: StringFilter<"CampaignAnalysisReport"> | string
    campaignId?: StringFilter<"CampaignAnalysisReport"> | string
    totalImpressions?: IntFilter<"CampaignAnalysisReport"> | number
    totalClicks?: IntFilter<"CampaignAnalysisReport"> | number
    totalQrScans?: IntFilter<"CampaignAnalysisReport"> | number
    totalConversions?: IntFilter<"CampaignAnalysisReport"> | number
    conversionRate?: FloatFilter<"CampaignAnalysisReport"> | number
    revenueGenerated?: FloatFilter<"CampaignAnalysisReport"> | number
    campaignSpend?: FloatFilter<"CampaignAnalysisReport"> | number
    roi?: FloatFilter<"CampaignAnalysisReport"> | number
    engagementRate?: FloatFilter<"CampaignAnalysisReport"> | number
    csatAverage?: FloatFilter<"CampaignAnalysisReport"> | number
    escalationRate?: FloatFilter<"CampaignAnalysisReport"> | number
    learningsSummary?: StringNullableFilter<"CampaignAnalysisReport"> | string | null
    createdAt?: DateTimeFilter<"CampaignAnalysisReport"> | Date | string
  }

  export type CampaignLearningsUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLearningsWhereUniqueInput
    update: XOR<CampaignLearningsUpdateWithoutCampaignInput, CampaignLearningsUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignLearningsCreateWithoutCampaignInput, CampaignLearningsUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLearningsUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLearningsWhereUniqueInput
    data: XOR<CampaignLearningsUpdateWithoutCampaignInput, CampaignLearningsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignLearningsUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignLearningsScalarWhereInput
    data: XOR<CampaignLearningsUpdateManyMutationInput, CampaignLearningsUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignLearningsScalarWhereInput = {
    AND?: CampaignLearningsScalarWhereInput | CampaignLearningsScalarWhereInput[]
    OR?: CampaignLearningsScalarWhereInput[]
    NOT?: CampaignLearningsScalarWhereInput | CampaignLearningsScalarWhereInput[]
    id?: StringFilter<"CampaignLearnings"> | string
    campaignId?: StringFilter<"CampaignLearnings"> | string
    whatWorked?: StringFilter<"CampaignLearnings"> | string
    whatDidNotWork?: StringFilter<"CampaignLearnings"> | string
    bestPractices?: StringFilter<"CampaignLearnings"> | string
    improvementAreas?: StringFilter<"CampaignLearnings"> | string
    createdAt?: DateTimeFilter<"CampaignLearnings"> | Date | string
  }

  export type InternalCampaignReportUpsertWithWhereUniqueWithoutCampaignInput = {
    where: InternalCampaignReportWhereUniqueInput
    update: XOR<InternalCampaignReportUpdateWithoutCampaignInput, InternalCampaignReportUncheckedUpdateWithoutCampaignInput>
    create: XOR<InternalCampaignReportCreateWithoutCampaignInput, InternalCampaignReportUncheckedCreateWithoutCampaignInput>
  }

  export type InternalCampaignReportUpdateWithWhereUniqueWithoutCampaignInput = {
    where: InternalCampaignReportWhereUniqueInput
    data: XOR<InternalCampaignReportUpdateWithoutCampaignInput, InternalCampaignReportUncheckedUpdateWithoutCampaignInput>
  }

  export type InternalCampaignReportUpdateManyWithWhereWithoutCampaignInput = {
    where: InternalCampaignReportScalarWhereInput
    data: XOR<InternalCampaignReportUpdateManyMutationInput, InternalCampaignReportUncheckedUpdateManyWithoutCampaignInput>
  }

  export type InternalCampaignReportScalarWhereInput = {
    AND?: InternalCampaignReportScalarWhereInput | InternalCampaignReportScalarWhereInput[]
    OR?: InternalCampaignReportScalarWhereInput[]
    NOT?: InternalCampaignReportScalarWhereInput | InternalCampaignReportScalarWhereInput[]
    id?: StringFilter<"InternalCampaignReport"> | string
    campaignId?: StringFilter<"InternalCampaignReport"> | string
    reportTitle?: StringFilter<"InternalCampaignReport"> | string
    executiveSummary?: StringFilter<"InternalCampaignReport"> | string
    kpiHighlights?: StringFilter<"InternalCampaignReport"> | string
    learningHighlights?: StringFilter<"InternalCampaignReport"> | string
    improvementAreas?: StringFilter<"InternalCampaignReport"> | string
    graphsReference?: StringNullableFilter<"InternalCampaignReport"> | string | null
    createdAt?: DateTimeFilter<"InternalCampaignReport"> | Date | string
  }

  export type CampaignCreateWithoutObjectivesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutObjectivesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutObjectivesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutObjectivesInput, CampaignUncheckedCreateWithoutObjectivesInput>
  }

  export type CampaignUpsertWithoutObjectivesInput = {
    update: XOR<CampaignUpdateWithoutObjectivesInput, CampaignUncheckedUpdateWithoutObjectivesInput>
    create: XOR<CampaignCreateWithoutObjectivesInput, CampaignUncheckedCreateWithoutObjectivesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutObjectivesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutObjectivesInput, CampaignUncheckedUpdateWithoutObjectivesInput>
  }

  export type CampaignUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutAudiencesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAudiencesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAudiencesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAudiencesInput, CampaignUncheckedCreateWithoutAudiencesInput>
  }

  export type CampaignUpsertWithoutAudiencesInput = {
    update: XOR<CampaignUpdateWithoutAudiencesInput, CampaignUncheckedUpdateWithoutAudiencesInput>
    create: XOR<CampaignCreateWithoutAudiencesInput, CampaignUncheckedCreateWithoutAudiencesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutAudiencesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutAudiencesInput, CampaignUncheckedUpdateWithoutAudiencesInput>
  }

  export type CampaignUpdateWithoutAudiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAudiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutPromotionsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutPromotionsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutPromotionsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutPromotionsInput, CampaignUncheckedCreateWithoutPromotionsInput>
  }

  export type CampaignUpsertWithoutPromotionsInput = {
    update: XOR<CampaignUpdateWithoutPromotionsInput, CampaignUncheckedUpdateWithoutPromotionsInput>
    create: XOR<CampaignCreateWithoutPromotionsInput, CampaignUncheckedCreateWithoutPromotionsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutPromotionsInput, CampaignUncheckedUpdateWithoutPromotionsInput>
  }

  export type CampaignUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutOffersInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutOffersInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutOffersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutOffersInput, CampaignUncheckedCreateWithoutOffersInput>
  }

  export type CampaignUpsertWithoutOffersInput = {
    update: XOR<CampaignUpdateWithoutOffersInput, CampaignUncheckedUpdateWithoutOffersInput>
    create: XOR<CampaignCreateWithoutOffersInput, CampaignUncheckedCreateWithoutOffersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutOffersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutOffersInput, CampaignUncheckedUpdateWithoutOffersInput>
  }

  export type CampaignUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutBudgetsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutBudgetsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutBudgetsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutBudgetsInput, CampaignUncheckedCreateWithoutBudgetsInput>
  }

  export type CampaignUpsertWithoutBudgetsInput = {
    update: XOR<CampaignUpdateWithoutBudgetsInput, CampaignUncheckedUpdateWithoutBudgetsInput>
    create: XOR<CampaignCreateWithoutBudgetsInput, CampaignUncheckedCreateWithoutBudgetsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutBudgetsInput, CampaignUncheckedUpdateWithoutBudgetsInput>
  }

  export type CampaignUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutChannelsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutChannelsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutChannelsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutChannelsInput, CampaignUncheckedCreateWithoutChannelsInput>
  }

  export type CampaignUpsertWithoutChannelsInput = {
    update: XOR<CampaignUpdateWithoutChannelsInput, CampaignUncheckedUpdateWithoutChannelsInput>
    create: XOR<CampaignCreateWithoutChannelsInput, CampaignUncheckedCreateWithoutChannelsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutChannelsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutChannelsInput, CampaignUncheckedUpdateWithoutChannelsInput>
  }

  export type CampaignUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutTimelinesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTimelinesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTimelinesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTimelinesInput, CampaignUncheckedCreateWithoutTimelinesInput>
  }

  export type CampaignUpsertWithoutTimelinesInput = {
    update: XOR<CampaignUpdateWithoutTimelinesInput, CampaignUncheckedUpdateWithoutTimelinesInput>
    create: XOR<CampaignCreateWithoutTimelinesInput, CampaignUncheckedCreateWithoutTimelinesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTimelinesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTimelinesInput, CampaignUncheckedUpdateWithoutTimelinesInput>
  }

  export type CampaignUpdateWithoutTimelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTimelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutCompliancesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCompliancesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCompliancesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCompliancesInput, CampaignUncheckedCreateWithoutCompliancesInput>
  }

  export type CampaignUpsertWithoutCompliancesInput = {
    update: XOR<CampaignUpdateWithoutCompliancesInput, CampaignUncheckedUpdateWithoutCompliancesInput>
    create: XOR<CampaignCreateWithoutCompliancesInput, CampaignUncheckedCreateWithoutCompliancesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCompliancesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCompliancesInput, CampaignUncheckedUpdateWithoutCompliancesInput>
  }

  export type CampaignUpdateWithoutCompliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCompliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMessagesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
  }

  export type CampaignUpsertWithoutMessagesInput = {
    update: XOR<CampaignUpdateWithoutMessagesInput, CampaignUncheckedUpdateWithoutMessagesInput>
    create: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMessagesInput, CampaignUncheckedUpdateWithoutMessagesInput>
  }

  export type CampaignUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutCreativePlansInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCreativePlansInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCreativePlansInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCreativePlansInput, CampaignUncheckedCreateWithoutCreativePlansInput>
  }

  export type CampaignUpsertWithoutCreativePlansInput = {
    update: XOR<CampaignUpdateWithoutCreativePlansInput, CampaignUncheckedUpdateWithoutCreativePlansInput>
    create: XOR<CampaignCreateWithoutCreativePlansInput, CampaignUncheckedCreateWithoutCreativePlansInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCreativePlansInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCreativePlansInput, CampaignUncheckedUpdateWithoutCreativePlansInput>
  }

  export type CampaignUpdateWithoutCreativePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCreativePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutCreativesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCreativesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCreativesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCreativesInput, CampaignUncheckedCreateWithoutCreativesInput>
  }

  export type CampaignUpsertWithoutCreativesInput = {
    update: XOR<CampaignUpdateWithoutCreativesInput, CampaignUncheckedUpdateWithoutCreativesInput>
    create: XOR<CampaignCreateWithoutCreativesInput, CampaignUncheckedCreateWithoutCreativesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCreativesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCreativesInput, CampaignUncheckedUpdateWithoutCreativesInput>
  }

  export type CampaignUpdateWithoutCreativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCreativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutMediaAssetsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMediaAssetsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMediaAssetsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMediaAssetsInput, CampaignUncheckedCreateWithoutMediaAssetsInput>
  }

  export type CampaignUpsertWithoutMediaAssetsInput = {
    update: XOR<CampaignUpdateWithoutMediaAssetsInput, CampaignUncheckedUpdateWithoutMediaAssetsInput>
    create: XOR<CampaignCreateWithoutMediaAssetsInput, CampaignUncheckedCreateWithoutMediaAssetsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMediaAssetsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMediaAssetsInput, CampaignUncheckedUpdateWithoutMediaAssetsInput>
  }

  export type CampaignUpdateWithoutMediaAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMediaAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutCalendarsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCalendarsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCalendarsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCalendarsInput, CampaignUncheckedCreateWithoutCalendarsInput>
  }

  export type CampaignUpsertWithoutCalendarsInput = {
    update: XOR<CampaignUpdateWithoutCalendarsInput, CampaignUncheckedUpdateWithoutCalendarsInput>
    create: XOR<CampaignCreateWithoutCalendarsInput, CampaignUncheckedCreateWithoutCalendarsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCalendarsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCalendarsInput, CampaignUncheckedUpdateWithoutCalendarsInput>
  }

  export type CampaignUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutTeasersInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTeasersInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTeasersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTeasersInput, CampaignUncheckedCreateWithoutTeasersInput>
  }

  export type CampaignUpsertWithoutTeasersInput = {
    update: XOR<CampaignUpdateWithoutTeasersInput, CampaignUncheckedUpdateWithoutTeasersInput>
    create: XOR<CampaignCreateWithoutTeasersInput, CampaignUncheckedCreateWithoutTeasersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTeasersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTeasersInput, CampaignUncheckedUpdateWithoutTeasersInput>
  }

  export type CampaignUpdateWithoutTeasersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTeasersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutCustomersInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCustomersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCustomersInput, CampaignUncheckedCreateWithoutCustomersInput>
  }

  export type CampaignUpsertWithoutCustomersInput = {
    update: XOR<CampaignUpdateWithoutCustomersInput, CampaignUncheckedUpdateWithoutCustomersInput>
    create: XOR<CampaignCreateWithoutCustomersInput, CampaignUncheckedCreateWithoutCustomersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCustomersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCustomersInput, CampaignUncheckedUpdateWithoutCustomersInput>
  }

  export type CampaignUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutInfluencersInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutInfluencersInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutInfluencersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutInfluencersInput, CampaignUncheckedCreateWithoutInfluencersInput>
  }

  export type CampaignUpsertWithoutInfluencersInput = {
    update: XOR<CampaignUpdateWithoutInfluencersInput, CampaignUncheckedUpdateWithoutInfluencersInput>
    create: XOR<CampaignCreateWithoutInfluencersInput, CampaignUncheckedCreateWithoutInfluencersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutInfluencersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutInfluencersInput, CampaignUncheckedUpdateWithoutInfluencersInput>
  }

  export type CampaignUpdateWithoutInfluencersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutInfluencersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutChecklistsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutChecklistsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutChecklistsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutChecklistsInput, CampaignUncheckedCreateWithoutChecklistsInput>
  }

  export type CampaignUpsertWithoutChecklistsInput = {
    update: XOR<CampaignUpdateWithoutChecklistsInput, CampaignUncheckedUpdateWithoutChecklistsInput>
    create: XOR<CampaignCreateWithoutChecklistsInput, CampaignUncheckedCreateWithoutChecklistsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutChecklistsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutChecklistsInput, CampaignUncheckedUpdateWithoutChecklistsInput>
  }

  export type CampaignUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutActivationsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutActivationsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutActivationsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutActivationsInput, CampaignUncheckedCreateWithoutActivationsInput>
  }

  export type CampaignUpsertWithoutActivationsInput = {
    update: XOR<CampaignUpdateWithoutActivationsInput, CampaignUncheckedUpdateWithoutActivationsInput>
    create: XOR<CampaignCreateWithoutActivationsInput, CampaignUncheckedCreateWithoutActivationsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutActivationsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutActivationsInput, CampaignUncheckedUpdateWithoutActivationsInput>
  }

  export type CampaignUpdateWithoutActivationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutActivationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutEngagementsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutEngagementsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutEngagementsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEngagementsInput, CampaignUncheckedCreateWithoutEngagementsInput>
  }

  export type CampaignUpsertWithoutEngagementsInput = {
    update: XOR<CampaignUpdateWithoutEngagementsInput, CampaignUncheckedUpdateWithoutEngagementsInput>
    create: XOR<CampaignCreateWithoutEngagementsInput, CampaignUncheckedCreateWithoutEngagementsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutEngagementsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutEngagementsInput, CampaignUncheckedUpdateWithoutEngagementsInput>
  }

  export type CampaignUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutReportsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutReportsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutReportsInput, CampaignUncheckedCreateWithoutReportsInput>
  }

  export type CampaignUpsertWithoutReportsInput = {
    update: XOR<CampaignUpdateWithoutReportsInput, CampaignUncheckedUpdateWithoutReportsInput>
    create: XOR<CampaignCreateWithoutReportsInput, CampaignUncheckedCreateWithoutReportsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutReportsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutReportsInput, CampaignUncheckedUpdateWithoutReportsInput>
  }

  export type CampaignUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutFeedbacksInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutFeedbacksInput, CampaignUncheckedCreateWithoutFeedbacksInput>
  }

  export type CampaignUpsertWithoutFeedbacksInput = {
    update: XOR<CampaignUpdateWithoutFeedbacksInput, CampaignUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<CampaignCreateWithoutFeedbacksInput, CampaignUncheckedCreateWithoutFeedbacksInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutFeedbacksInput, CampaignUncheckedUpdateWithoutFeedbacksInput>
  }

  export type CampaignUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutThanksInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutThanksInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutThanksInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutThanksInput, CampaignUncheckedCreateWithoutThanksInput>
  }

  export type CampaignUpsertWithoutThanksInput = {
    update: XOR<CampaignUpdateWithoutThanksInput, CampaignUncheckedUpdateWithoutThanksInput>
    create: XOR<CampaignCreateWithoutThanksInput, CampaignUncheckedCreateWithoutThanksInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutThanksInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutThanksInput, CampaignUncheckedUpdateWithoutThanksInput>
  }

  export type CampaignUpdateWithoutThanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutThanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutRetargetingsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutRetargetingsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutRetargetingsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutRetargetingsInput, CampaignUncheckedCreateWithoutRetargetingsInput>
  }

  export type CampaignUpsertWithoutRetargetingsInput = {
    update: XOR<CampaignUpdateWithoutRetargetingsInput, CampaignUncheckedUpdateWithoutRetargetingsInput>
    create: XOR<CampaignCreateWithoutRetargetingsInput, CampaignUncheckedCreateWithoutRetargetingsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutRetargetingsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutRetargetingsInput, CampaignUncheckedUpdateWithoutRetargetingsInput>
  }

  export type CampaignUpdateWithoutRetargetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutRetargetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutExtensionsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutExtensionsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutExtensionsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutExtensionsInput, CampaignUncheckedCreateWithoutExtensionsInput>
  }

  export type CampaignUpsertWithoutExtensionsInput = {
    update: XOR<CampaignUpdateWithoutExtensionsInput, CampaignUncheckedUpdateWithoutExtensionsInput>
    create: XOR<CampaignCreateWithoutExtensionsInput, CampaignUncheckedCreateWithoutExtensionsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutExtensionsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutExtensionsInput, CampaignUncheckedUpdateWithoutExtensionsInput>
  }

  export type CampaignUpdateWithoutExtensionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutExtensionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutAnalysisReportsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAnalysisReportsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAnalysisReportsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAnalysisReportsInput, CampaignUncheckedCreateWithoutAnalysisReportsInput>
  }

  export type CampaignUpsertWithoutAnalysisReportsInput = {
    update: XOR<CampaignUpdateWithoutAnalysisReportsInput, CampaignUncheckedUpdateWithoutAnalysisReportsInput>
    create: XOR<CampaignCreateWithoutAnalysisReportsInput, CampaignUncheckedCreateWithoutAnalysisReportsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutAnalysisReportsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutAnalysisReportsInput, CampaignUncheckedUpdateWithoutAnalysisReportsInput>
  }

  export type CampaignUpdateWithoutAnalysisReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAnalysisReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutLearningsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutLearningsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    internalReports?: InternalCampaignReportUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutLearningsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutLearningsInput, CampaignUncheckedCreateWithoutLearningsInput>
  }

  export type CampaignUpsertWithoutLearningsInput = {
    update: XOR<CampaignUpdateWithoutLearningsInput, CampaignUncheckedUpdateWithoutLearningsInput>
    create: XOR<CampaignCreateWithoutLearningsInput, CampaignUncheckedCreateWithoutLearningsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutLearningsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutLearningsInput, CampaignUncheckedUpdateWithoutLearningsInput>
  }

  export type CampaignUpdateWithoutLearningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutLearningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    internalReports?: InternalCampaignReportUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutInternalReportsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutInternalReportsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enterpriseContexts?: EnterpriseContextUncheckedCreateNestedManyWithoutCampaignInput
    audienceSegments?: AudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    creativePlans?: CreativeDesignPlanUncheckedCreateNestedManyWithoutCampaignInput
    objectives?: CampaignObjectiveUncheckedCreateNestedManyWithoutCampaignInput
    audiences?: TargetAudienceSegmentUncheckedCreateNestedManyWithoutCampaignInput
    competitors?: CompetitorStrategyUncheckedCreateNestedManyWithoutCampaignInput
    promotions?: PromotionTypeUncheckedCreateNestedManyWithoutCampaignInput
    offers?: CampaignOfferUncheckedCreateNestedManyWithoutCampaignInput
    budgets?: CampaignBudgetUncheckedCreateNestedManyWithoutCampaignInput
    channels?: ChannelPlanUncheckedCreateNestedManyWithoutCampaignInput
    timelines?: CampaignTimelineUncheckedCreateNestedManyWithoutCampaignInput
    compliances?: ComplianceChecklistUncheckedCreateNestedManyWithoutCampaignInput
    creatives?: CreativeAssetUncheckedCreateNestedManyWithoutCampaignInput
    messages?: PromotionalMessageUncheckedCreateNestedManyWithoutCampaignInput
    mediaAssets?: MediaAssetUncheckedCreateNestedManyWithoutCampaignInput
    calendars?: ContentCalendarUncheckedCreateNestedManyWithoutCampaignInput
    teasers?: TeaserContentUncheckedCreateNestedManyWithoutCampaignInput
    customers?: CustomerSegmentListUncheckedCreateNestedManyWithoutCampaignInput
    influencers?: InfluencerPlanUncheckedCreateNestedManyWithoutCampaignInput
    checklists?: OperationalChecklistUncheckedCreateNestedManyWithoutCampaignInput
    activations?: CampaignActivationUncheckedCreateNestedManyWithoutCampaignInput
    engagements?: CustomerEngagementLogUncheckedCreateNestedManyWithoutCampaignInput
    reports?: PerformanceReportUncheckedCreateNestedManyWithoutCampaignInput
    feedbacks?: CustomerFeedbackUncheckedCreateNestedManyWithoutCampaignInput
    thanks?: ThankYouMessageUncheckedCreateNestedManyWithoutCampaignInput
    retargetings?: RetargetingPlanUncheckedCreateNestedManyWithoutCampaignInput
    extensions?: CampaignExtensionPlanUncheckedCreateNestedManyWithoutCampaignInput
    analysisReports?: CampaignAnalysisReportUncheckedCreateNestedManyWithoutCampaignInput
    learnings?: CampaignLearningsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutInternalReportsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutInternalReportsInput, CampaignUncheckedCreateWithoutInternalReportsInput>
  }

  export type CampaignUpsertWithoutInternalReportsInput = {
    update: XOR<CampaignUpdateWithoutInternalReportsInput, CampaignUncheckedUpdateWithoutInternalReportsInput>
    create: XOR<CampaignCreateWithoutInternalReportsInput, CampaignUncheckedCreateWithoutInternalReportsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutInternalReportsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutInternalReportsInput, CampaignUncheckedUpdateWithoutInternalReportsInput>
  }

  export type CampaignUpdateWithoutInternalReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutInternalReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enterpriseContexts?: EnterpriseContextUncheckedUpdateManyWithoutCampaignNestedInput
    audienceSegments?: AudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    creativePlans?: CreativeDesignPlanUncheckedUpdateManyWithoutCampaignNestedInput
    objectives?: CampaignObjectiveUncheckedUpdateManyWithoutCampaignNestedInput
    audiences?: TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignNestedInput
    competitors?: CompetitorStrategyUncheckedUpdateManyWithoutCampaignNestedInput
    promotions?: PromotionTypeUncheckedUpdateManyWithoutCampaignNestedInput
    offers?: CampaignOfferUncheckedUpdateManyWithoutCampaignNestedInput
    budgets?: CampaignBudgetUncheckedUpdateManyWithoutCampaignNestedInput
    channels?: ChannelPlanUncheckedUpdateManyWithoutCampaignNestedInput
    timelines?: CampaignTimelineUncheckedUpdateManyWithoutCampaignNestedInput
    compliances?: ComplianceChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    creatives?: CreativeAssetUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: PromotionalMessageUncheckedUpdateManyWithoutCampaignNestedInput
    mediaAssets?: MediaAssetUncheckedUpdateManyWithoutCampaignNestedInput
    calendars?: ContentCalendarUncheckedUpdateManyWithoutCampaignNestedInput
    teasers?: TeaserContentUncheckedUpdateManyWithoutCampaignNestedInput
    customers?: CustomerSegmentListUncheckedUpdateManyWithoutCampaignNestedInput
    influencers?: InfluencerPlanUncheckedUpdateManyWithoutCampaignNestedInput
    checklists?: OperationalChecklistUncheckedUpdateManyWithoutCampaignNestedInput
    activations?: CampaignActivationUncheckedUpdateManyWithoutCampaignNestedInput
    engagements?: CustomerEngagementLogUncheckedUpdateManyWithoutCampaignNestedInput
    reports?: PerformanceReportUncheckedUpdateManyWithoutCampaignNestedInput
    feedbacks?: CustomerFeedbackUncheckedUpdateManyWithoutCampaignNestedInput
    thanks?: ThankYouMessageUncheckedUpdateManyWithoutCampaignNestedInput
    retargetings?: RetargetingPlanUncheckedUpdateManyWithoutCampaignNestedInput
    extensions?: CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignNestedInput
    analysisReports?: CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignNestedInput
    learnings?: CampaignLearningsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EnterpriseContextCreateManyCampaignInput = {
    id?: string
    companyName: string
    domain: string
    businessModel: string
    background: string
    currentPain: string
    goals: string
    createdAt?: Date | string
  }

  export type AudienceSegmentCreateManyCampaignInput = {
    id?: string
    label: string
    demographics: string
    behavior: string
    painPoints: string
    createdAt?: Date | string
  }

  export type CreativeDesignPlanCreateManyCampaignInput = {
    id?: string
    platform: string
    creativeTitle: string
    headline: string
    visualTheme: string
    cta: string
    mobileOptimizationTip: string
    createdAt?: Date | string
  }

  export type CampaignObjectiveCreateManyCampaignInput = {
    id?: string
    goal: string
  }

  export type TargetAudienceSegmentCreateManyCampaignInput = {
    id?: string
    segment: string
  }

  export type CompetitorStrategyCreateManyCampaignInput = {
    id?: string
    competitor: string
    promotionType: string
    channels: string
    strength: string
    weakness: string
    createdAt?: Date | string
  }

  export type PromotionTypeCreateManyCampaignInput = {
    id?: string
    type: string
  }

  export type CampaignOfferCreateManyCampaignInput = {
    id?: string
    description: string
    offerLimit?: number | null
    offerType?: string | null
    successCriteria?: string | null
    backupOffer?: string | null
    createdAt?: Date | string
  }

  export type CampaignBudgetCreateManyCampaignInput = {
    id?: string
    mediaSpend: number
    creativeSpend: number
    incentiveSpend: number
    logisticsSpend: number
    totalBudget: number
    costPerCustomer: number
    expectedROI?: number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ChannelPlanCreateManyCampaignInput = {
    id?: string
    channels?: ChannelPlanCreatechannelsInput | string[]
    primary: string
    primaryReason: string
    messageStyles?: ChannelPlanCreatemessageStylesInput | string[]
    createdAt?: Date | string
  }

  export type CampaignTimelineCreateManyCampaignInput = {
    id?: string
    milestoneName: string
    milestoneType: string
    plannedDate: Date | string
    createdAt?: Date | string
  }

  export type ComplianceChecklistCreateManyCampaignInput = {
    id?: string
    item: string
    severity: string
    responsibleDepartment: string
    status?: string
    createdAt?: Date | string
  }

  export type CreativeAssetCreateManyCampaignInput = {
    id?: string
    type: string
    assetUrl: string
    createdAt?: Date | string
  }

  export type PromotionalMessageCreateManyCampaignInput = {
    id?: string
    platform: string
    tone: string
    message: string
    callToAction: string
    createdAt?: Date | string
  }

  export type MediaAssetCreateManyCampaignInput = {
    id?: string
    type: string
    title: string
    concept: string
    engagementTip: string
    mobileOptimizationTip: string
    url?: string | null
    createdAt?: Date | string
  }

  export type ContentCalendarCreateManyCampaignInput = {
    id?: string
    contentType: string
    platform: string
    contentRef: string
    scheduledFor: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type TeaserContentCreateManyCampaignInput = {
    id?: string
    message: string
    platform: string
    teaserTheme?: string | null
    tone: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type CustomerSegmentListCreateManyCampaignInput = {
    id?: string
    segment: string
    criteria: string
    count: number
    createdAt?: Date | string
  }

  export type InfluencerPlanCreateManyCampaignInput = {
    id?: string
    influencerName: string
    platform: string
    postType: string
    expectedImpact?: string | null
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type OperationalChecklistCreateManyCampaignInput = {
    id?: string
    system: string
    checklistItem: string
    expectedOutcome: string
    responsibility: string
    status: string
    createdAt?: Date | string
  }

  export type CampaignActivationCreateManyCampaignInput = {
    id?: string
    platform: string
    assetType: string
    assetReference: string
    activationTime: Date | string
    status: string
    activationResult: string
    createdAt?: Date | string
  }

  export type CustomerEngagementLogCreateManyCampaignInput = {
    id?: string
    userId: string
    sessionId: string
    interactionType: string
    message: string
    resolutionStatus: string
    responseTime: number
    csatScore?: number | null
    createdAt?: Date | string
  }

  export type PerformanceReportCreateManyCampaignInput = {
    id?: string
    date: Date | string
    impressions: number
    clicks: number
    qrScans: number
    conversions: number
    chatbotSessions: number
    escalations: number
    escalationRate: number
    avgBotResponseTime: number
    avgHumanResponseTime: number
    csatScoreAverage: number
    anomalies?: string | null
    createdAt?: Date | string
  }

  export type CustomerFeedbackCreateManyCampaignInput = {
    id?: string
    userId: string
    interactionId?: string | null
    feedbackText: string
    rating: number
    collectedVia: string
    createdAt?: Date | string
  }

  export type ThankYouMessageCreateManyCampaignInput = {
    id?: string
    userId: string
    messageBody: string
    sentVia: string
    segment: string
    sentAt?: Date | string
  }

  export type RetargetingPlanCreateManyCampaignInput = {
    id?: string
    audienceSegment: string
    retargetingChannel: string
    offerMessage: string
    scheduledAt: Date | string
    createdAt?: Date | string
  }

  export type CampaignExtensionPlanCreateManyCampaignInput = {
    id?: string
    reason: string
    extendedTo: Date | string
    details: string
    createdAt?: Date | string
  }

  export type CampaignAnalysisReportCreateManyCampaignInput = {
    id?: string
    totalImpressions: number
    totalClicks: number
    totalQrScans: number
    totalConversions: number
    conversionRate: number
    revenueGenerated: number
    campaignSpend: number
    roi: number
    engagementRate: number
    csatAverage: number
    escalationRate: number
    learningsSummary?: string | null
    createdAt?: Date | string
  }

  export type CampaignLearningsCreateManyCampaignInput = {
    id?: string
    whatWorked: string
    whatDidNotWork: string
    bestPractices: string
    improvementAreas: string
    createdAt?: Date | string
  }

  export type InternalCampaignReportCreateManyCampaignInput = {
    id?: string
    reportTitle: string
    executiveSummary: string
    kpiHighlights: string
    learningHighlights: string
    improvementAreas: string
    graphsReference?: string | null
    createdAt?: Date | string
  }

  export type EnterpriseContextUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    businessModel?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    currentPain?: StringFieldUpdateOperationsInput | string
    goals?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseContextUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    businessModel?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    currentPain?: StringFieldUpdateOperationsInput | string
    goals?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseContextUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    businessModel?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    currentPain?: StringFieldUpdateOperationsInput | string
    goals?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudienceSegmentUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    demographics?: StringFieldUpdateOperationsInput | string
    behavior?: StringFieldUpdateOperationsInput | string
    painPoints?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudienceSegmentUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    demographics?: StringFieldUpdateOperationsInput | string
    behavior?: StringFieldUpdateOperationsInput | string
    painPoints?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudienceSegmentUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    demographics?: StringFieldUpdateOperationsInput | string
    behavior?: StringFieldUpdateOperationsInput | string
    painPoints?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeDesignPlanUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    creativeTitle?: StringFieldUpdateOperationsInput | string
    headline?: StringFieldUpdateOperationsInput | string
    visualTheme?: StringFieldUpdateOperationsInput | string
    cta?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeDesignPlanUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    creativeTitle?: StringFieldUpdateOperationsInput | string
    headline?: StringFieldUpdateOperationsInput | string
    visualTheme?: StringFieldUpdateOperationsInput | string
    cta?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeDesignPlanUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    creativeTitle?: StringFieldUpdateOperationsInput | string
    headline?: StringFieldUpdateOperationsInput | string
    visualTheme?: StringFieldUpdateOperationsInput | string
    cta?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignObjectiveUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignObjectiveUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignObjectiveUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
  }

  export type TargetAudienceSegmentUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
  }

  export type TargetAudienceSegmentUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
  }

  export type TargetAudienceSegmentUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
  }

  export type CompetitorStrategyUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    competitor?: StringFieldUpdateOperationsInput | string
    promotionType?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    weakness?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorStrategyUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    competitor?: StringFieldUpdateOperationsInput | string
    promotionType?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    weakness?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorStrategyUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    competitor?: StringFieldUpdateOperationsInput | string
    promotionType?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    strength?: StringFieldUpdateOperationsInput | string
    weakness?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionTypeUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionTypeUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionTypeUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignOfferUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    offerLimit?: NullableIntFieldUpdateOperationsInput | number | null
    offerType?: NullableStringFieldUpdateOperationsInput | string | null
    successCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    backupOffer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOfferUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    offerLimit?: NullableIntFieldUpdateOperationsInput | number | null
    offerType?: NullableStringFieldUpdateOperationsInput | string | null
    successCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    backupOffer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOfferUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    offerLimit?: NullableIntFieldUpdateOperationsInput | number | null
    offerType?: NullableStringFieldUpdateOperationsInput | string | null
    successCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    backupOffer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignBudgetUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaSpend?: FloatFieldUpdateOperationsInput | number
    creativeSpend?: FloatFieldUpdateOperationsInput | number
    incentiveSpend?: FloatFieldUpdateOperationsInput | number
    logisticsSpend?: FloatFieldUpdateOperationsInput | number
    totalBudget?: FloatFieldUpdateOperationsInput | number
    costPerCustomer?: FloatFieldUpdateOperationsInput | number
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignBudgetUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaSpend?: FloatFieldUpdateOperationsInput | number
    creativeSpend?: FloatFieldUpdateOperationsInput | number
    incentiveSpend?: FloatFieldUpdateOperationsInput | number
    logisticsSpend?: FloatFieldUpdateOperationsInput | number
    totalBudget?: FloatFieldUpdateOperationsInput | number
    costPerCustomer?: FloatFieldUpdateOperationsInput | number
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignBudgetUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaSpend?: FloatFieldUpdateOperationsInput | number
    creativeSpend?: FloatFieldUpdateOperationsInput | number
    incentiveSpend?: FloatFieldUpdateOperationsInput | number
    logisticsSpend?: FloatFieldUpdateOperationsInput | number
    totalBudget?: FloatFieldUpdateOperationsInput | number
    costPerCustomer?: FloatFieldUpdateOperationsInput | number
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelPlanUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: ChannelPlanUpdatechannelsInput | string[]
    primary?: StringFieldUpdateOperationsInput | string
    primaryReason?: StringFieldUpdateOperationsInput | string
    messageStyles?: ChannelPlanUpdatemessageStylesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelPlanUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: ChannelPlanUpdatechannelsInput | string[]
    primary?: StringFieldUpdateOperationsInput | string
    primaryReason?: StringFieldUpdateOperationsInput | string
    messageStyles?: ChannelPlanUpdatemessageStylesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelPlanUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: ChannelPlanUpdatechannelsInput | string[]
    primary?: StringFieldUpdateOperationsInput | string
    primaryReason?: StringFieldUpdateOperationsInput | string
    messageStyles?: ChannelPlanUpdatemessageStylesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTimelineUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTimelineUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTimelineUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceChecklistUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    responsibleDepartment?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceChecklistUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    responsibleDepartment?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceChecklistUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    responsibleDepartment?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeAssetUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    assetUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeAssetUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    assetUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeAssetUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    assetUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionalMessageUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    callToAction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionalMessageUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    callToAction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionalMessageUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    callToAction?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    concept?: StringFieldUpdateOperationsInput | string
    engagementTip?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    concept?: StringFieldUpdateOperationsInput | string
    engagementTip?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    concept?: StringFieldUpdateOperationsInput | string
    engagementTip?: StringFieldUpdateOperationsInput | string
    mobileOptimizationTip?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCalendarUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    contentRef?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCalendarUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    contentRef?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCalendarUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    contentRef?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeaserContentUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    teaserTheme?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeaserContentUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    teaserTheme?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeaserContentUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    teaserTheme?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSegmentListUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSegmentListUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSegmentListUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerPlanUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    influencerName?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    expectedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerPlanUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    influencerName?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    expectedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerPlanUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    influencerName?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    postType?: StringFieldUpdateOperationsInput | string
    expectedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationalChecklistUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    checklistItem?: StringFieldUpdateOperationsInput | string
    expectedOutcome?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationalChecklistUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    checklistItem?: StringFieldUpdateOperationsInput | string
    expectedOutcome?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationalChecklistUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    checklistItem?: StringFieldUpdateOperationsInput | string
    expectedOutcome?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivationUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    assetType?: StringFieldUpdateOperationsInput | string
    assetReference?: StringFieldUpdateOperationsInput | string
    activationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    activationResult?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivationUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    assetType?: StringFieldUpdateOperationsInput | string
    assetReference?: StringFieldUpdateOperationsInput | string
    activationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    activationResult?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivationUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    assetType?: StringFieldUpdateOperationsInput | string
    assetReference?: StringFieldUpdateOperationsInput | string
    activationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    activationResult?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerEngagementLogUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolutionStatus?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    csatScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerEngagementLogUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolutionStatus?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    csatScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerEngagementLogUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolutionStatus?: StringFieldUpdateOperationsInput | string
    responseTime?: IntFieldUpdateOperationsInput | number
    csatScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReportUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    qrScans?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    chatbotSessions?: IntFieldUpdateOperationsInput | number
    escalations?: IntFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    avgBotResponseTime?: IntFieldUpdateOperationsInput | number
    avgHumanResponseTime?: IntFieldUpdateOperationsInput | number
    csatScoreAverage?: FloatFieldUpdateOperationsInput | number
    anomalies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReportUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    qrScans?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    chatbotSessions?: IntFieldUpdateOperationsInput | number
    escalations?: IntFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    avgBotResponseTime?: IntFieldUpdateOperationsInput | number
    avgHumanResponseTime?: IntFieldUpdateOperationsInput | number
    csatScoreAverage?: FloatFieldUpdateOperationsInput | number
    anomalies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReportUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    qrScans?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    chatbotSessions?: IntFieldUpdateOperationsInput | number
    escalations?: IntFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    avgBotResponseTime?: IntFieldUpdateOperationsInput | number
    avgHumanResponseTime?: IntFieldUpdateOperationsInput | number
    csatScoreAverage?: FloatFieldUpdateOperationsInput | number
    anomalies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFeedbackUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackText?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    collectedVia?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFeedbackUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackText?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    collectedVia?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerFeedbackUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackText?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    collectedVia?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThankYouMessageUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageBody?: StringFieldUpdateOperationsInput | string
    sentVia?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThankYouMessageUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageBody?: StringFieldUpdateOperationsInput | string
    sentVia?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThankYouMessageUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    messageBody?: StringFieldUpdateOperationsInput | string
    sentVia?: StringFieldUpdateOperationsInput | string
    segment?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetargetingPlanUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    audienceSegment?: StringFieldUpdateOperationsInput | string
    retargetingChannel?: StringFieldUpdateOperationsInput | string
    offerMessage?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetargetingPlanUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    audienceSegment?: StringFieldUpdateOperationsInput | string
    retargetingChannel?: StringFieldUpdateOperationsInput | string
    offerMessage?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetargetingPlanUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    audienceSegment?: StringFieldUpdateOperationsInput | string
    retargetingChannel?: StringFieldUpdateOperationsInput | string
    offerMessage?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignExtensionPlanUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    extendedTo?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignExtensionPlanUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    extendedTo?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignExtensionPlanUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    extendedTo?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalysisReportUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalImpressions?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalQrScans?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    campaignSpend?: FloatFieldUpdateOperationsInput | number
    roi?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    csatAverage?: FloatFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    learningsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalysisReportUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalImpressions?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalQrScans?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    campaignSpend?: FloatFieldUpdateOperationsInput | number
    roi?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    csatAverage?: FloatFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    learningsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAnalysisReportUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalImpressions?: IntFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalQrScans?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    revenueGenerated?: FloatFieldUpdateOperationsInput | number
    campaignSpend?: FloatFieldUpdateOperationsInput | number
    roi?: FloatFieldUpdateOperationsInput | number
    engagementRate?: FloatFieldUpdateOperationsInput | number
    csatAverage?: FloatFieldUpdateOperationsInput | number
    escalationRate?: FloatFieldUpdateOperationsInput | number
    learningsSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLearningsUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatWorked?: StringFieldUpdateOperationsInput | string
    whatDidNotWork?: StringFieldUpdateOperationsInput | string
    bestPractices?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLearningsUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatWorked?: StringFieldUpdateOperationsInput | string
    whatDidNotWork?: StringFieldUpdateOperationsInput | string
    bestPractices?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLearningsUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatWorked?: StringFieldUpdateOperationsInput | string
    whatDidNotWork?: StringFieldUpdateOperationsInput | string
    bestPractices?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalCampaignReportUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportTitle?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    kpiHighlights?: StringFieldUpdateOperationsInput | string
    learningHighlights?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    graphsReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalCampaignReportUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportTitle?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    kpiHighlights?: StringFieldUpdateOperationsInput | string
    learningHighlights?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    graphsReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalCampaignReportUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportTitle?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    kpiHighlights?: StringFieldUpdateOperationsInput | string
    learningHighlights?: StringFieldUpdateOperationsInput | string
    improvementAreas?: StringFieldUpdateOperationsInput | string
    graphsReference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompetitorStrategyDefaultArgs instead
     */
    export type CompetitorStrategyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompetitorStrategyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnterpriseContextDefaultArgs instead
     */
    export type EnterpriseContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnterpriseContextDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudienceSegmentDefaultArgs instead
     */
    export type AudienceSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudienceSegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignObjectiveDefaultArgs instead
     */
    export type CampaignObjectiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignObjectiveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TargetAudienceSegmentDefaultArgs instead
     */
    export type TargetAudienceSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TargetAudienceSegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionTypeDefaultArgs instead
     */
    export type PromotionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignOfferDefaultArgs instead
     */
    export type CampaignOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignOfferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignBudgetDefaultArgs instead
     */
    export type CampaignBudgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignBudgetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelPlanDefaultArgs instead
     */
    export type ChannelPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignTimelineDefaultArgs instead
     */
    export type CampaignTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignTimelineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComplianceChecklistDefaultArgs instead
     */
    export type ComplianceChecklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComplianceChecklistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionalMessageDefaultArgs instead
     */
    export type PromotionalMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionalMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreativeDesignPlanDefaultArgs instead
     */
    export type CreativeDesignPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreativeDesignPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreativeAssetDefaultArgs instead
     */
    export type CreativeAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreativeAssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaAssetDefaultArgs instead
     */
    export type MediaAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaAssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentCalendarDefaultArgs instead
     */
    export type ContentCalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentCalendarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeaserContentDefaultArgs instead
     */
    export type TeaserContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeaserContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerSegmentListDefaultArgs instead
     */
    export type CustomerSegmentListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerSegmentListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InfluencerPlanDefaultArgs instead
     */
    export type InfluencerPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InfluencerPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationalChecklistDefaultArgs instead
     */
    export type OperationalChecklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationalChecklistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignActivationDefaultArgs instead
     */
    export type CampaignActivationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignActivationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerEngagementLogDefaultArgs instead
     */
    export type CustomerEngagementLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerEngagementLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerformanceReportDefaultArgs instead
     */
    export type PerformanceReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerformanceReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerFeedbackDefaultArgs instead
     */
    export type CustomerFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThankYouMessageDefaultArgs instead
     */
    export type ThankYouMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThankYouMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RetargetingPlanDefaultArgs instead
     */
    export type RetargetingPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RetargetingPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignExtensionPlanDefaultArgs instead
     */
    export type CampaignExtensionPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignExtensionPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignAnalysisReportDefaultArgs instead
     */
    export type CampaignAnalysisReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignAnalysisReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignLearningsDefaultArgs instead
     */
    export type CampaignLearningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignLearningsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternalCampaignReportDefaultArgs instead
     */
    export type InternalCampaignReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternalCampaignReportDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}